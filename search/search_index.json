{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acceso a datos Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana. Resultados de aprendizaje y criterios de evaluaci\u00f3n Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo. Unidades did\u00e1cticas / Temporalizaci\u00f3n A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres. Primera evaluaci\u00f3n Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24 Segunda evaluaci\u00f3n Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Inicio"},{"location":"#acceso-a-datos","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana.","title":"Acceso a datos"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","text":"Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo.","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n"},{"location":"#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres.","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"#primera-evaluacion","text":"Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24","title":"Primera evaluaci\u00f3n"},{"location":"#segunda-evaluacion","text":"Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Segunda evaluaci\u00f3n"},{"location":"about/","text":"About Patricia Mart\u00ed p.marti2@edu.gva.es Bibliograf\u00eda y webgraf\u00eda https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"About"},{"location":"about/#about","text":"Patricia Mart\u00ed p.marti2@edu.gva.es","title":"About"},{"location":"about/#bibliografia-y-webgrafia","text":"https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"Bibliograf\u00eda y webgraf\u00eda"},{"location":"ud1/11binaryfiles/","text":"Ficheros binarios Escribir datos en un fichero binario La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O. Escritura en un fichero binario usando el b\u00fafer Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } } Lectura de datos en un fichero binario Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"1.2.- Ficheros binarios"},{"location":"ud1/11binaryfiles/#ficheros-binarios","text":"","title":"Ficheros binarios"},{"location":"ud1/11binaryfiles/#escribir-datos-en-un-fichero-binario","text":"La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O.","title":"Escribir datos en un fichero binario"},{"location":"ud1/11binaryfiles/#escritura-en-un-fichero-binario-usando-el-bufer","text":"Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"Escritura en un fichero binario usando el b\u00fafer"},{"location":"ud1/11binaryfiles/#lectura-de-datos-en-un-fichero-binario","text":"Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"Lectura de datos en un fichero binario"},{"location":"ud1/12characterfiles/","text":"Ficheros de caracteres Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto. Escritura de caracteres La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() . Lectura de datos FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"1.3.- Ficheros de caracteres"},{"location":"ud1/12characterfiles/#ficheros-de-caracteres","text":"Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto.","title":"Ficheros de caracteres"},{"location":"ud1/12characterfiles/#escritura-de-caracteres","text":"La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() .","title":"Escritura de caracteres"},{"location":"ud1/12characterfiles/#lectura-de-datos","text":"FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"Lectura de datos"},{"location":"ud1/13fileclass/","text":"Clase File Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / . Constructor de File File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO crea un fichero Path vs File En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.","title":"1.4.- Clase File"},{"location":"ud1/13fileclass/#clase-file","text":"Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / .","title":"Clase File"},{"location":"ud1/13fileclass/#constructor-de-file","text":"File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO crea un fichero","title":"Constructor de File"},{"location":"ud1/13fileclass/#path-vs-file","text":"En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.","title":"Path vs File"},{"location":"ud1/1io/","text":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros. Tipos de Datos - Caracteres y bytes Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida. Flujos orientados a bytes Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar. Flujos orientados a caracteres Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente. Ficheros Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta. Tipos de acceso a ficheros Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"1.1.- Entrada/Salida (I/O) de la informaci\u00f3n"},{"location":"ud1/1io/#io-inputoutput-entradasalida-de-la-informacion","text":"Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n"},{"location":"ud1/1io/#tipos-de-datos-caracteres-y-bytes","text":"Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.","title":"Tipos de Datos - Caracteres y bytes"},{"location":"ud1/1io/#flujos-orientados-a-bytes","text":"Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar.","title":"Flujos orientados a bytes"},{"location":"ud1/1io/#flujos-orientados-a-caracteres","text":"Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.","title":"Flujos orientados a caracteres"},{"location":"ud1/1io/#ficheros","text":"Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.","title":"Ficheros"},{"location":"ud1/1io/#tipos-de-acceso-a-ficheros","text":"Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"Tipos de acceso a ficheros"}]}