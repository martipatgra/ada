{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acceso a datos Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana. Resultados de aprendizaje y criterios de evaluaci\u00f3n Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo. Unidades did\u00e1cticas / Temporalizaci\u00f3n A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres. Primera evaluaci\u00f3n Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24 Segunda evaluaci\u00f3n Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Inicio"},{"location":"#acceso-a-datos","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana.","title":"Acceso a datos"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","text":"Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo.","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n"},{"location":"#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres.","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"#primera-evaluacion","text":"Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24","title":"Primera evaluaci\u00f3n"},{"location":"#segunda-evaluacion","text":"Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Segunda evaluaci\u00f3n"},{"location":"about/","text":"About Patricia Mart\u00ed p.marti2@edu.gva.es Bibliograf\u00eda y webgraf\u00eda https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"About"},{"location":"about/#about","text":"Patricia Mart\u00ed p.marti2@edu.gva.es","title":"About"},{"location":"about/#bibliografia-y-webgrafia","text":"https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"Bibliograf\u00eda y webgraf\u00eda"},{"location":"ud1/11io/","text":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros. Tipos de Datos - Caracteres y bytes Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida. Flujos orientados a bytes Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar. Flujos orientados a caracteres Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente. Ficheros Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta. Tipos de acceso a ficheros Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases InputStream y OutputStream son secuenciales. Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"1.1.- Entrada/Salida (I/O) de la informaci\u00f3n"},{"location":"ud1/11io/#io-inputoutput-entradasalida-de-la-informacion","text":"Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n"},{"location":"ud1/11io/#tipos-de-datos-caracteres-y-bytes","text":"Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.","title":"Tipos de Datos - Caracteres y bytes"},{"location":"ud1/11io/#flujos-orientados-a-bytes","text":"Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar.","title":"Flujos orientados a bytes"},{"location":"ud1/11io/#flujos-orientados-a-caracteres","text":"Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.","title":"Flujos orientados a caracteres"},{"location":"ud1/11io/#ficheros","text":"Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.","title":"Ficheros"},{"location":"ud1/11io/#tipos-de-acceso-a-ficheros","text":"Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases InputStream y OutputStream son secuenciales. Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"Tipos de acceso a ficheros"},{"location":"ud1/12binaryfiles/","text":"Ficheros binarios Escribir datos en un fichero binario La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O. Escritura en un fichero binario usando el b\u00fafer Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } } Lectura de datos en un fichero binario Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"1.2.- Ficheros binarios"},{"location":"ud1/12binaryfiles/#ficheros-binarios","text":"","title":"Ficheros binarios"},{"location":"ud1/12binaryfiles/#escribir-datos-en-un-fichero-binario","text":"La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O.","title":"Escribir datos en un fichero binario"},{"location":"ud1/12binaryfiles/#escritura-en-un-fichero-binario-usando-el-bufer","text":"Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"Escritura en un fichero binario usando el b\u00fafer"},{"location":"ud1/12binaryfiles/#lectura-de-datos-en-un-fichero-binario","text":"Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"Lectura de datos en un fichero binario"},{"location":"ud1/13characterfiles/","text":"Ficheros de caracteres Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto. Escritura de caracteres La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() . Lectura de datos FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"1.3.- Ficheros de caracteres"},{"location":"ud1/13characterfiles/#ficheros-de-caracteres","text":"Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto.","title":"Ficheros de caracteres"},{"location":"ud1/13characterfiles/#escritura-de-caracteres","text":"La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() .","title":"Escritura de caracteres"},{"location":"ud1/13characterfiles/#lectura-de-datos","text":"FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"Lectura de datos"},{"location":"ud1/14fileclass/","text":"File vs Path En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes. Clase File Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / . Constructor de File File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO CREA UN FICHERO Desventajas de la clase File Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones. Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase File no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas. Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada. Path vs File Cuando construimos un objeto File lo hacemos a trav\u00e9s del constructor, mientras que en la clase Path se usa un m\u00e9todo est\u00e1tico. File file = new File ( \"ada.txt\" ); Path path = Paths . get ( \"ada.txt\" );","title":"1.4.- Clase File"},{"location":"ud1/14fileclass/#file-vs-path","text":"En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.","title":"File vs Path"},{"location":"ud1/14fileclass/#clase-file","text":"Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / .","title":"Clase File"},{"location":"ud1/14fileclass/#constructor-de-file","text":"File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO CREA UN FICHERO","title":"Constructor de File"},{"location":"ud1/14fileclass/#desventajas-de-la-clase-file","text":"Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones. Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase File no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas. Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada.","title":"Desventajas de la clase File"},{"location":"ud1/14fileclass/#path-vs-file","text":"Cuando construimos un objeto File lo hacemos a trav\u00e9s del constructor, mientras que en la clase Path se usa un m\u00e9todo est\u00e1tico. File file = new File ( \"ada.txt\" ); Path path = Paths . get ( \"ada.txt\" );","title":"Path vs File"},{"location":"ud1/15javanio/","text":"java.nio java.nio.file.Path : Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema. java.nio.file.Files : En combinaci\u00f3n con Path , realiza operaciones en ficheros o directorios. java.nio.file.FileSystem : Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear Path y otros objetos que acceden al sistema de ficheros. Todos los m\u00e9todos que acceden al sistema de ficheros lanzan una excepci\u00f3n de tipo IOException . Path Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase File , Path tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos. Path puede realizar todas las operaciones que se pueden realizar con la clase File . Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre. FileSystems . Cargar un fichero con FileSystems Path path = FileSystems . getDefault (). getPath ( \"fichero.txt\" ); Escritura en un fichero Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedWriter bw = Files . newBufferedWriter ( p )) { for ( int i = 0 ; i < 10 ; i ++ ) { bw . write ( String . valueOf ( i )); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Lectura de un fichero Con buffer: Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedReader br = Files . newBufferedReader ( p )) { String input ; while (( input = br . readLine ()) != null ) { System . out . println ( input ); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try { List < String > lines = Files . readAllLines ( p ); for ( String line : lines ) { System . out . println ( line ); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"1.5.- java.nio"},{"location":"ud1/15javanio/#javanio","text":"java.nio.file.Path : Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema. java.nio.file.Files : En combinaci\u00f3n con Path , realiza operaciones en ficheros o directorios. java.nio.file.FileSystem : Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear Path y otros objetos que acceden al sistema de ficheros. Todos los m\u00e9todos que acceden al sistema de ficheros lanzan una excepci\u00f3n de tipo IOException .","title":"java.nio"},{"location":"ud1/15javanio/#path","text":"Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase File , Path tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos. Path puede realizar todas las operaciones que se pueden realizar con la clase File . Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre.","title":"Path"},{"location":"ud1/15javanio/#filesystems-cargar-un-fichero-con-filesystems","text":"Path path = FileSystems . getDefault (). getPath ( \"fichero.txt\" );","title":"FileSystems. Cargar un fichero con FileSystems"},{"location":"ud1/15javanio/#escritura-en-un-fichero","text":"Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedWriter bw = Files . newBufferedWriter ( p )) { for ( int i = 0 ; i < 10 ; i ++ ) { bw . write ( String . valueOf ( i )); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"Escritura en un fichero"},{"location":"ud1/15javanio/#lectura-de-un-fichero","text":"Con buffer: Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedReader br = Files . newBufferedReader ( p )) { String input ; while (( input = br . readLine ()) != null ) { System . out . println ( input ); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try { List < String > lines = Files . readAllLines ( p ); for ( String line : lines ) { System . out . println ( line ); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"Lectura de un fichero"},{"location":"ud1/16randomaccessfile/","text":"Acceso aleatorio a ficheros Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java. Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial . Los datos de un fichero de acceso secuencial NO se pueden actualizar . Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase RandomAccessFile . Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes. Puntero de la clase RandomAccessFile Un fichero de acceso aleatorio consta de una secuencia de bytes . \u00c9stos, admiten un puntero especial conocido como puntero de fichero ( file pointer ). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero. Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir. En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero. El puntero se puede mover utilizando el m\u00e9todo seek() . Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte). Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n. RandomAccessFile raf = .... raf . seek ( position ); //mueve el puntero a una posici\u00f3n raf . seek ( 0 ); //mueve el puntero al inicio del fichero raf . seek ( raf . length ()); //mueve el puntero al final del fichero Constructor de la clase RandomAccessFile Para construir un objeto de la clase tenemos que especificar el modo ( mode ) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido. r: el fichero es de solo lectura. rw: se abre en modo lectura-escritura. rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico. RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\"); Ejemplo de un programa que a\u00f1ade texto al final de un fichero public static void main ( String [] args ) { RandomAccessFile file = null ; try { file = new RandomAccessFile ( \"file.txt\" , \"rw\" ); file . seek ( file . length ()); // Moving file pointer to the end. file . writeBytes ( \"\\nJava\" ); // Append text. file . close (); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"1.6.- Ficheros de acceso aleatorio"},{"location":"ud1/16randomaccessfile/#acceso-aleatorio-a-ficheros","text":"Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java. Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial . Los datos de un fichero de acceso secuencial NO se pueden actualizar . Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase RandomAccessFile . Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes.","title":"Acceso aleatorio a ficheros"},{"location":"ud1/16randomaccessfile/#puntero-de-la-clase-randomaccessfile","text":"Un fichero de acceso aleatorio consta de una secuencia de bytes . \u00c9stos, admiten un puntero especial conocido como puntero de fichero ( file pointer ). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero. Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir. En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero. El puntero se puede mover utilizando el m\u00e9todo seek() . Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte). Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n. RandomAccessFile raf = .... raf . seek ( position ); //mueve el puntero a una posici\u00f3n raf . seek ( 0 ); //mueve el puntero al inicio del fichero raf . seek ( raf . length ()); //mueve el puntero al final del fichero","title":"Puntero de la clase RandomAccessFile"},{"location":"ud1/16randomaccessfile/#constructor-de-la-clase-randomaccessfile","text":"Para construir un objeto de la clase tenemos que especificar el modo ( mode ) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido. r: el fichero es de solo lectura. rw: se abre en modo lectura-escritura. rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico. RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\");","title":"Constructor de la clase RandomAccessFile"},{"location":"ud1/16randomaccessfile/#ejemplo-de-un-programa-que-anade-texto-al-final-de-un-fichero","text":"public static void main ( String [] args ) { RandomAccessFile file = null ; try { file = new RandomAccessFile ( \"file.txt\" , \"rw\" ); file . seek ( file . length ()); // Moving file pointer to the end. file . writeBytes ( \"\\nJava\" ); // Append text. file . close (); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"Ejemplo de un programa que a\u00f1ade texto al final de un fichero"},{"location":"ud1/17configfiles/","text":"Ficheros de configuraci\u00f3n En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d , en donde cada l\u00ednea tiene una pareja clave=valor . En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal. Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado datasource.properties , que almacena informaci\u00f3n sobre la base de datos: La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =. Java nos proporciona la clase Properties , para leer de forma sencilla los ficheros de configuraci\u00f3n. Cargar el fichero de configuraci\u00f3n Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties. Properties properties = new Properties (); Esta clase tiene un m\u00e9todo load() que permite cargar el fichero. No tenemos m\u00e1s que pasarle un InputStream o un Reader de java. properties . load ( new FileReader ( \"datasource.properties\" )); Leer una propiedad El m\u00e9todo properties.getProperty(String) nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\" , obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero). Si la clave no existe, obtendremos null como resultado. Sin embargo, tenemos una variante de getProperty() que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo: properties . getProperty ( \"db.username\" , \"default value\" )); Al m\u00e9todo getProperty() le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado. Leer todas las propiedades La clase Properties tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto Enumeration que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo keys() y luego realiza un bucle para ir sacando por pantalla todos los valores. Enumeration < Object > keys = properties . keys (); while ( keys . hasMoreElements ()) { Object key = keys . nextElement (); System . out . println ( key + \" = \" + properties . get ( key )); } A\u00f1adir o modificar una propiedad Para a\u00f1adir/modificar el valor de una propiedad, la clase Properties tiene un m\u00e9todo llamado setProperty(String key, String value) que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente. properties . setProperty ( \"db.port\" , \"4020\" ); Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase Properties tiene dos m\u00e9todos: save() y store() . El m\u00e9todo save() est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a store() pas\u00e1ndole un OutputStream o un Writer de java. properties . store ( new FileWriter ( \"datasource.properties\" ), \"Added database port\" ); El m\u00e9todo store() admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente: Contiene el comentario que pusimos en la llamada a store() y la fecha, que la inserta de regalo.","title":"1.7.- Ficheros de configuraci\u00f3n"},{"location":"ud1/17configfiles/#ficheros-de-configuracion","text":"En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d , en donde cada l\u00ednea tiene una pareja clave=valor . En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal. Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado datasource.properties , que almacena informaci\u00f3n sobre la base de datos: La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =. Java nos proporciona la clase Properties , para leer de forma sencilla los ficheros de configuraci\u00f3n.","title":"Ficheros de configuraci\u00f3n"},{"location":"ud1/17configfiles/#cargar-el-fichero-de-configuracion","text":"Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties. Properties properties = new Properties (); Esta clase tiene un m\u00e9todo load() que permite cargar el fichero. No tenemos m\u00e1s que pasarle un InputStream o un Reader de java. properties . load ( new FileReader ( \"datasource.properties\" ));","title":"Cargar el fichero de configuraci\u00f3n"},{"location":"ud1/17configfiles/#leer-una-propiedad","text":"El m\u00e9todo properties.getProperty(String) nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\" , obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero). Si la clave no existe, obtendremos null como resultado. Sin embargo, tenemos una variante de getProperty() que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo: properties . getProperty ( \"db.username\" , \"default value\" )); Al m\u00e9todo getProperty() le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado.","title":"Leer una propiedad"},{"location":"ud1/17configfiles/#leer-todas-las-propiedades","text":"La clase Properties tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto Enumeration que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo keys() y luego realiza un bucle para ir sacando por pantalla todos los valores. Enumeration < Object > keys = properties . keys (); while ( keys . hasMoreElements ()) { Object key = keys . nextElement (); System . out . println ( key + \" = \" + properties . get ( key )); }","title":"Leer todas las propiedades"},{"location":"ud1/17configfiles/#anadir-o-modificar-una-propiedad","text":"Para a\u00f1adir/modificar el valor de una propiedad, la clase Properties tiene un m\u00e9todo llamado setProperty(String key, String value) que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente. properties . setProperty ( \"db.port\" , \"4020\" ); Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase Properties tiene dos m\u00e9todos: save() y store() . El m\u00e9todo save() est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a store() pas\u00e1ndole un OutputStream o un Writer de java. properties . store ( new FileWriter ( \"datasource.properties\" ), \"Added database port\" ); El m\u00e9todo store() admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente: Contiene el comentario que pusimos en la llamada a store() y la fecha, que la inserta de regalo.","title":"A\u00f1adir o modificar una propiedad"},{"location":"ud1/18xmlfiles/","text":"Ficheros XML XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n. Estructura de un documento XML Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <nombre> , donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando. Documento XML v\u00e1lido Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones: Cada etiqueta de apertura tiene una etiqueta de cierre. Todas las etiquetas est\u00e1n completamente anidadas. Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial. El XML es sensible a may\u00fasculas y min\u00fasculas. Partes de un documento XML Pr\u00f3logo Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas. El pr\u00f3logo de un documento XML contiene: Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML. Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo. Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo: <?xml version=\"1.0\" encoding=\"UTF-8\"?> Cuerpo A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento. Elementos Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos. Atributos Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas. <person sex= \"female\" > <firstname> Anna </firstname> <lastname> Smith </lastname> </person> En el ejemplo, el elemento person tiene un atributo sex . Comentarios Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato: <!-- Comment --> Ejemplo de un documento XML < ?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"> <!-- This is a comment --> <products> <product> <name> Cereales </name> <price> 3.45 </price> </product> <product> <name> Colacao </name> <price> 1.45 </price> </product> <product> <name> Agua mineral </name> <price> 1.00 </price> </product> </products> Url XML El est\u00e1ndar XML Java XML Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos. En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming). DOM El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria. DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria. SAX La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial. El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM. StAX Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM. Ejemplo lectura XML desde una API private static Document loadXMLDocument ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (); DocumentBuilder builder = factory . newDocumentBuilder (); return builder . parse ( input ); } catch ( Exception e ) { throw new RuntimeException ( e ); } } Escritura de un documento XML private static void writeXml ( Document doc , OutputStream output ) throws TransformerException { TransformerFactory transformerFactory = TransformerFactory . newInstance (); Transformer transformer = transformerFactory . newTransformer (); transformer . setOutputProperty ( OutputKeys . INDENT , \"yes\" ); DOMSource source = new DOMSource ( doc ); StreamResult result = new StreamResult ( output ); transformer . transform ( source , result ); }","title":"1.8.- XML"},{"location":"ud1/18xmlfiles/#ficheros-xml","text":"XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.","title":"Ficheros XML"},{"location":"ud1/18xmlfiles/#estructura-de-un-documento-xml","text":"Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <nombre> , donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.","title":"Estructura de un documento XML"},{"location":"ud1/18xmlfiles/#documento-xml-valido","text":"Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones: Cada etiqueta de apertura tiene una etiqueta de cierre. Todas las etiquetas est\u00e1n completamente anidadas. Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial. El XML es sensible a may\u00fasculas y min\u00fasculas.","title":"Documento XML v\u00e1lido"},{"location":"ud1/18xmlfiles/#partes-de-un-documento-xml","text":"","title":"Partes de un documento XML"},{"location":"ud1/18xmlfiles/#prologo","text":"Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas. El pr\u00f3logo de un documento XML contiene: Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML. Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo. Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo: <?xml version=\"1.0\" encoding=\"UTF-8\"?>","title":"Pr\u00f3logo"},{"location":"ud1/18xmlfiles/#cuerpo","text":"A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.","title":"Cuerpo"},{"location":"ud1/18xmlfiles/#elementos","text":"Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.","title":"Elementos"},{"location":"ud1/18xmlfiles/#atributos","text":"Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas. <person sex= \"female\" > <firstname> Anna </firstname> <lastname> Smith </lastname> </person> En el ejemplo, el elemento person tiene un atributo sex .","title":"Atributos"},{"location":"ud1/18xmlfiles/#comentarios","text":"Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato: <!-- Comment -->","title":"Comentarios"},{"location":"ud1/18xmlfiles/#ejemplo-de-un-documento-xml","text":"< ?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"> <!-- This is a comment --> <products> <product> <name> Cereales </name> <price> 3.45 </price> </product> <product> <name> Colacao </name> <price> 1.45 </price> </product> <product> <name> Agua mineral </name> <price> 1.00 </price> </product> </products>","title":"Ejemplo de un documento XML"},{"location":"ud1/18xmlfiles/#url-xml","text":"El est\u00e1ndar XML","title":"Url XML"},{"location":"ud1/18xmlfiles/#java-xml","text":"Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos. En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming).","title":"Java XML"},{"location":"ud1/18xmlfiles/#dom","text":"El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria. DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.","title":"DOM"},{"location":"ud1/18xmlfiles/#sax","text":"La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial. El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.","title":"SAX"},{"location":"ud1/18xmlfiles/#stax","text":"Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.","title":"StAX"},{"location":"ud1/18xmlfiles/#ejemplo-lectura-xml-desde-una-api","text":"private static Document loadXMLDocument ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (); DocumentBuilder builder = factory . newDocumentBuilder (); return builder . parse ( input ); } catch ( Exception e ) { throw new RuntimeException ( e ); } }","title":"Ejemplo lectura XML desde una API"},{"location":"ud1/18xmlfiles/#escritura-de-un-documento-xml","text":"private static void writeXml ( Document doc , OutputStream output ) throws TransformerException { TransformerFactory transformerFactory = TransformerFactory . newInstance (); Transformer transformer = transformerFactory . newTransformer (); transformer . setOutputProperty ( OutputKeys . INDENT , \"yes\" ); DOMSource source = new DOMSource ( doc ); StreamResult result = new StreamResult ( output ); transformer . transform ( source , result ); }","title":"Escritura de un documento XML"},{"location":"ud1/19jsonfiles/","text":"Ficheros JSON JSON ( JavaScript Object Notation ) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos. JSON se utiliza hoy en d\u00eda en cada API web \u00fanica. JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra: Una colecci\u00f3n de pares de name/value . En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa. Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia. Tipos de datos disponibles N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456 Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\" Booleanos: Representan valores booleanos y pueden tener dos valores: true y false null: Representan el valor nulo. Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes. Objetos: Son colecciones no ordenadas de pares de la forma nombre:valor separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo. Formato JSON Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con {(llave izquierda) y termina con} (llave derecha). Cada nombre va seguido de: (dos puntos) y los pares de name/value est\u00e1n separados por, (coma). Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con [(corchete izquierdo) y termina con] (corchete derecho). Los valores est\u00e1n separados por (coma). Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar. Ejemplo de fichero JSON # Fichero JSON { \"web-app\" : { \"servlet\" : [ { \"servlet-name\" : \"cofaxCDS\" , \"servlet-class\" : \"org.cofax.cds.CDSServlet\" , \"init-param\" : { \"configGlossary:installationAt\" : \"Philadelphia, PA\" , \"configGlossary:adminEmail\" : \"ksm@pobox.com\" , \"configGlossary:poweredBy\" : \"Cofax\" , \"configGlossary:poweredByIcon\" : \"/images/cofax.gif\" , \"configGlossary:staticPath\" : \"/content/static\" , \"templateProcessorClass\" : \"org.cofax.WysiwygTemplate\" , \"templateLoaderClass\" : \"org.cofax.FilesTemplateLoader\" , \"templatePath\" : \"templates\" , \"templateOverridePath\" : \"\" , \"defaultListTemplate\" : \"listTemplate.htm\" , \"defaultFileTemplate\" : \"articleTemplate.htm\" , \"useJSP\" : false , \"dataStoreMaxConns\" : 100 } }, null , { \"servlet-name\" : \"cofaxEmail\" , \"servlet-class\" : \"org.cofax.cds.EmailServlet\" , \"init-param\" : { \"mailHost\" : \"mail1\" , \"mailHostOverride\" : \"mail2\" } }], \"servlet-mapping\" : { \"cofaxCDS\" : \"/\" , \"cofaxEmail\" : \"/cofaxutil/aemail/*\" , \"cofaxAdmin\" : \"/admin/*\" , \"fileServlet\" : \"/static/*\" , \"cofaxTools\" : \"/tools/*\" }, \"taglib\" : { \"taglib-uri\" : \"cofax.tld\" , \"taglib-location\" : \"/WEB-INF/tlds/cofax.tld\" } } } El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase Servlet , donde la clase Servlet estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc. Existen varias librer\u00edas en Java para parsear ficheros JSON. Entre las m\u00e1s comunes est\u00e1n: Gson, Jackson, JSON.simple, org.json, JsonPATH, etc. URL oficial The JSON Specification JSON vs XML Java JSON Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros. En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n). Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n. Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json . Los archivos en este paquete implementan codificadores/decodificadores JSON en Java. Leer un JSON a partir de una API //Este m\u00e9todo accede a una URL y se descarga el contenido en forma de String public static String stream ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { InputStreamReader isr = new InputStreamReader ( input ); BufferedReader reader = new BufferedReader ( isr ); StringBuilder json = new StringBuilder (); int c ; while (( c = reader . read ()) != - 1 ) { json . append (( char ) c ); } return json . toString (); } catch ( IOException e ) { throw new RuntimeException ( e ); } } public static void main ( String [] args ) { String caturl = \"https://catfact.ninja/facts\" ; //parseamos un string a un JSONObject JSONObject jsonObject = new JSONObject ( stream ( caturl )); JSONArray a = jsonObject . getJSONArray ( \"data\" ); JSONObject o = ( JSONObject ) a . get ( 0 ); System . out . println ( o . getString ( \"fact\" )); } Un JSONObject es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.","title":"1.9.- JSON"},{"location":"ud1/19jsonfiles/#ficheros-json","text":"JSON ( JavaScript Object Notation ) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos. JSON se utiliza hoy en d\u00eda en cada API web \u00fanica. JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra: Una colecci\u00f3n de pares de name/value . En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa. Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia.","title":"Ficheros JSON"},{"location":"ud1/19jsonfiles/#tipos-de-datos-disponibles","text":"N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456 Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\" Booleanos: Representan valores booleanos y pueden tener dos valores: true y false null: Representan el valor nulo. Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes. Objetos: Son colecciones no ordenadas de pares de la forma nombre:valor separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.","title":"Tipos de datos disponibles"},{"location":"ud1/19jsonfiles/#formato-json","text":"Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con {(llave izquierda) y termina con} (llave derecha). Cada nombre va seguido de: (dos puntos) y los pares de name/value est\u00e1n separados por, (coma). Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con [(corchete izquierdo) y termina con] (corchete derecho). Los valores est\u00e1n separados por (coma). Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar.","title":"Formato JSON"},{"location":"ud1/19jsonfiles/#ejemplo-de-fichero-json","text":"# Fichero JSON { \"web-app\" : { \"servlet\" : [ { \"servlet-name\" : \"cofaxCDS\" , \"servlet-class\" : \"org.cofax.cds.CDSServlet\" , \"init-param\" : { \"configGlossary:installationAt\" : \"Philadelphia, PA\" , \"configGlossary:adminEmail\" : \"ksm@pobox.com\" , \"configGlossary:poweredBy\" : \"Cofax\" , \"configGlossary:poweredByIcon\" : \"/images/cofax.gif\" , \"configGlossary:staticPath\" : \"/content/static\" , \"templateProcessorClass\" : \"org.cofax.WysiwygTemplate\" , \"templateLoaderClass\" : \"org.cofax.FilesTemplateLoader\" , \"templatePath\" : \"templates\" , \"templateOverridePath\" : \"\" , \"defaultListTemplate\" : \"listTemplate.htm\" , \"defaultFileTemplate\" : \"articleTemplate.htm\" , \"useJSP\" : false , \"dataStoreMaxConns\" : 100 } }, null , { \"servlet-name\" : \"cofaxEmail\" , \"servlet-class\" : \"org.cofax.cds.EmailServlet\" , \"init-param\" : { \"mailHost\" : \"mail1\" , \"mailHostOverride\" : \"mail2\" } }], \"servlet-mapping\" : { \"cofaxCDS\" : \"/\" , \"cofaxEmail\" : \"/cofaxutil/aemail/*\" , \"cofaxAdmin\" : \"/admin/*\" , \"fileServlet\" : \"/static/*\" , \"cofaxTools\" : \"/tools/*\" }, \"taglib\" : { \"taglib-uri\" : \"cofax.tld\" , \"taglib-location\" : \"/WEB-INF/tlds/cofax.tld\" } } } El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase Servlet , donde la clase Servlet estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc. Existen varias librer\u00edas en Java para parsear ficheros JSON. Entre las m\u00e1s comunes est\u00e1n: Gson, Jackson, JSON.simple, org.json, JsonPATH, etc.","title":"Ejemplo de fichero JSON"},{"location":"ud1/19jsonfiles/#url-oficial","text":"The JSON Specification","title":"URL oficial"},{"location":"ud1/19jsonfiles/#json-vs-xml","text":"","title":"JSON vs XML"},{"location":"ud1/19jsonfiles/#java-json","text":"Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros. En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n). Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n. Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json . Los archivos en este paquete implementan codificadores/decodificadores JSON en Java.","title":"Java JSON"},{"location":"ud1/19jsonfiles/#leer-un-json-a-partir-de-una-api","text":"//Este m\u00e9todo accede a una URL y se descarga el contenido en forma de String public static String stream ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { InputStreamReader isr = new InputStreamReader ( input ); BufferedReader reader = new BufferedReader ( isr ); StringBuilder json = new StringBuilder (); int c ; while (( c = reader . read ()) != - 1 ) { json . append (( char ) c ); } return json . toString (); } catch ( IOException e ) { throw new RuntimeException ( e ); } } public static void main ( String [] args ) { String caturl = \"https://catfact.ninja/facts\" ; //parseamos un string a un JSONObject JSONObject jsonObject = new JSONObject ( stream ( caturl )); JSONArray a = jsonObject . getJSONArray ( \"data\" ); JSONObject o = ( JSONObject ) a . get ( 0 ); System . out . println ( o . getString ( \"fact\" )); } Un JSONObject es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.","title":"Leer un JSON a partir de una API"},{"location":"ud1/20createjar/","text":"C\u00f3mo crear un jar en IntelliJ Vamos a File --> Project Structure En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --> \"From modules with dependencies\" Le decimos cu\u00e1l es la clase main y aceptamos. Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --> \"Build Artifact\". Seleccionamos \"Build\".","title":"1.10.- Crear un .jar"},{"location":"ud1/20createjar/#como-crear-un-jar-en-intellij","text":"Vamos a File --> Project Structure En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --> \"From modules with dependencies\" Le decimos cu\u00e1l es la clase main y aceptamos. Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --> \"Build Artifact\". Seleccionamos \"Build\".","title":"C\u00f3mo crear un jar en IntelliJ"}]}