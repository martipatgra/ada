{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acceso a datos Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana. Resultados de aprendizaje y criterios de evaluaci\u00f3n Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo. Unidades did\u00e1cticas / Temporalizaci\u00f3n A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres. Primera evaluaci\u00f3n Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24 Segunda evaluaci\u00f3n Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Inicio"},{"location":"#acceso-a-datos","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Acceso a Datos , que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas, a raz\u00f3n de 6 horas semanales. Se ha planificado bas\u00e1ndose en 3 sesiones de 2 horas lectivas por semana.","title":"Acceso a datos"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","text":"Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. Gestiona la persistencia de los datos identificando herramientas de mapeo objeto relacional (ORM) y desarrollando aplicaciones que las utilizan. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos objeto relacionales y orientadas a objetos valorando sus caracter\u00edsticas y utilizando los mecanismos de acceso incorporados. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos nativas XML evaluando y utilizando clases espec\u00edficas. Programa componentes de acceso a datos identificando las caracter\u00edsticas que debe poseer un componente y utilizando herramientas de desarrollo.","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n"},{"location":"#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en una serie de unidades did\u00e1cticas distribuidas en dos trimestres.","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"#primera-evaluacion","text":"Compuesta por las 3 primeras unidades, donde se estudiar\u00e1n el acceso a datos a trav\u00e9s de ficheros y bases de datos relacionales. Tambi\u00e9n ser ver\u00e1n aspectos de mapeo objeto-relacional. Unidad T\u00edtulo Sesiones Horas 1 Acceso a ficheros 10 20 2 Acceso a bases de datos relacionales 13 26 3 Mapeo objeto-relacional 12 24","title":"Primera evaluaci\u00f3n"},{"location":"#segunda-evaluacion","text":"Incluye 3 unidades. Unidad T\u00edtulo Sesiones Horas 4 Acceso a bases de datos no relacional. 10 14 5 Acceso a datos en aplicaciones web. API Rest 13 26 6 Programaci\u00f3n de componentes de acceso 12 10","title":"Segunda evaluaci\u00f3n"},{"location":"about/","text":"About Patricia Mart\u00ed p.marti2@edu.gva.es Bibliograf\u00eda y webgraf\u00eda https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"About"},{"location":"about/#about","text":"Patricia Mart\u00ed p.marti2@edu.gva.es","title":"About"},{"location":"about/#bibliografia-y-webgrafia","text":"https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"Bibliograf\u00eda y webgraf\u00eda"},{"location":"ud1/11io/","text":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros. Tipos de Datos - Caracteres y bytes Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida. Flujos orientados a bytes Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar. Flujos orientados a caracteres Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente. Ficheros Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta. Tipos de acceso a ficheros Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases InputStream y OutputStream son secuenciales. Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"1.1.- Entrada/Salida (I/O) de la informaci\u00f3n"},{"location":"ud1/11io/#io-inputoutput-entradasalida-de-la-informacion","text":"Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream ). Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa. En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete java.io era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado java.NIO (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s java.NIO . Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n"},{"location":"ud1/11io/#tipos-de-datos-caracteres-y-bytes","text":"Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes. Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams) . Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\". Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto. Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream . Clases principales de InputStream: Clases principales de OutputStream: Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer . Clases principales de Reader : Clases principales de Writer: La siguiente figura muestra la jerarqu\u00eda del paquete java.io . Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.","title":"Tipos de Datos - Caracteres y bytes"},{"location":"ud1/11io/#flujos-orientados-a-bytes","text":"Dise\u00f1ado para entrada y salida de prop\u00f3sito general. Los datos pueden ser tipos de datos primitivos o bytes sin procesar.","title":"Flujos orientados a bytes"},{"location":"ud1/11io/#flujos-orientados-a-caracteres","text":"Destinado a datos de caracteres. Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.","title":"Flujos orientados a caracteres"},{"location":"ud1/11io/#ficheros","text":"Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.","title":"Ficheros"},{"location":"ud1/11io/#tipos-de-acceso-a-ficheros","text":"Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases InputStream y OutputStream son secuenciales. Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.","title":"Tipos de acceso a ficheros"},{"location":"ud1/12binaryfiles/","text":"Ficheros binarios Escribir datos en un fichero binario La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O. Escritura en un fichero binario usando el b\u00fafer Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } } Lectura de datos en un fichero binario Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"1.2.- Ficheros binarios"},{"location":"ud1/12binaryfiles/#ficheros-binarios","text":"","title":"Ficheros binarios"},{"location":"ud1/12binaryfiles/#escribir-datos-en-un-fichero-binario","text":"La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de OutputStream . Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase FileOutputStream . public static void main ( String [] args ) { try { DataOutputStream fos = new DataOutputStream ( new FileOutputStream ( \"datos.dat\" )); fos . writeInt ( 0 ); fos . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } En el ejemplo, el constructor FileOutputStream abre el fichero datos.dat para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un DataOutputStream se conecta al FileOutputStream . DataOutputStream tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia. El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo. Warning Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos. La excepci\u00f3n IOException se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O.","title":"Escribir datos en un fichero binario"},{"location":"ud1/12binaryfiles/#escritura-en-un-fichero-binario-usando-el-bufer","text":"Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos BufferedOutputStream . Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez. Cuando se cierra el stream close() , es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta. public static void writeBuffer () { try { DataOutputStream out = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( \"datosBufer.dat\" ))); for ( int i = 0 ; i < 1000 ; i ++ ) { out . writeInt ( i ); } out . close (); } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"Escritura en un fichero binario usando el b\u00fafer"},{"location":"ud1/12binaryfiles/#lectura-de-datos-en-un-fichero-binario","text":"Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de InputStream para leer bytes para ese tipo de datos. InputStream , como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, PipedInputStream representa datos provenientes de otro programa en ejecuci\u00f3n. public static void main ( String [] args ) { try { DataInputStream dis = new DataInputStream ( new FileInputStream ( \"datos.dat\" )); System . out . println ( dis . readInt ()); dis . close (); } catch ( FileNotFoundException e ) { //todas pueden derivar de IOException System . out . println ( e . getMessage ()); } catch ( IOException e ) { System . out . println ( e . getMessage ()); } } Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase BufferedInputStream .","title":"Lectura de datos en un fichero binario"},{"location":"ud1/13characterfiles/","text":"Ficheros de caracteres Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto. Escritura de caracteres La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() . Lectura de datos FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"1.3.- Ficheros de caracteres"},{"location":"ud1/13characterfiles/#ficheros-de-caracteres","text":"Las clases Java FileWriter y FileReader se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream ). Se recomienda no utilizar las clases FileInputStream y FileOutputStream si vamos a leer o escribir informaci\u00f3n de texto.","title":"Ficheros de caracteres"},{"location":"ud1/13characterfiles/#escritura-de-caracteres","text":"La clase Java FileWriter del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo. Esta clase hereda de la clase OutputStream . Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables. FileWriter est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase FileOutputStream . public static void main ( String [] args ) { String str = \"Este es un ejemplo de escritura usando FileWriter.\" ; try { FileWriter fw = new FileWriter ( \"output.txt\" ); fw . write ( str ); fw . close (); } catch ( IOException e ) { System . out . println ( \"Error E/S: \" + e ); } } Cuando se cierra el stream close() se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo flush() .","title":"Escritura de caracteres"},{"location":"ud1/13characterfiles/#lectura-de-datos","text":"FileReader es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase InputStreamReader . FileReader est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos FileInputStream . int ch ; try { FileReader fr = new FileReader ( \"output.txt\" ); ch = fr . read (); while ( ch != - 1 ) { //fin de fichero System . out . print (( char ) ch ); ch = fr . read (); } fr . close (); } catch ( IOException fe ) { System . out . println ( \"Error de E/S\" ); } Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases BufferedReader y BufferedWriter para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.","title":"Lectura de datos"},{"location":"ud1/14fileclass/","text":"File vs Path En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes. Clase File Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / . Constructor de File File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO CREA UN FICHERO Desventajas de la clase File Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones. Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase File no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas. Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada. Path vs File Cuando construimos un objeto File lo hacemos a trav\u00e9s del constructor, mientras que en la clase Path se usa un m\u00e9todo est\u00e1tico. File file = new File ( \"ada.txt\" ); Path path = Paths . get ( \"ada.txt\" );","title":"1.4.- Clase File"},{"location":"ud1/14fileclass/#file-vs-path","text":"En Java, Path y File son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.","title":"File vs Path"},{"location":"ud1/14fileclass/#clase-file","text":"Las primeras versiones de Java incluyen el paquete java.io , que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase File es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos. Un objeto File NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo. Ejemplo en Windows: File f = new File ( \"C:\\\\Users\\\\temp\\\\data.txt\" ); En Linux el car\u00e1cter separador es / .","title":"Clase File"},{"location":"ud1/14fileclass/#constructor-de-file","text":"File ( String pathName ) //Constructor pathName es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo. Warning Construir un objeto de la clase File NO CREA UN FICHERO","title":"Constructor de File"},{"location":"ud1/14fileclass/#desventajas-de-la-clase-file","text":"Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones. Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase File no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas. Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada.","title":"Desventajas de la clase File"},{"location":"ud1/14fileclass/#path-vs-file","text":"Cuando construimos un objeto File lo hacemos a trav\u00e9s del constructor, mientras que en la clase Path se usa un m\u00e9todo est\u00e1tico. File file = new File ( \"ada.txt\" ); Path path = Paths . get ( \"ada.txt\" );","title":"Path vs File"},{"location":"ud1/15javanio/","text":"java.nio java.nio.file.Path : Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema. java.nio.file.Files : En combinaci\u00f3n con Path , realiza operaciones en ficheros o directorios. java.nio.file.FileSystem : Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear Path y otros objetos que acceden al sistema de ficheros. Todos los m\u00e9todos que acceden al sistema de ficheros lanzan una excepci\u00f3n de tipo IOException . Path Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase File , Path tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos. Path puede realizar todas las operaciones que se pueden realizar con la clase File . Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre. FileSystems . Cargar un fichero con FileSystems Path path = FileSystems . getDefault (). getPath ( \"fichero.txt\" ); Escritura en un fichero Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedWriter bw = Files . newBufferedWriter ( p )) { for ( int i = 0 ; i < 10 ; i ++ ) { bw . write ( String . valueOf ( i )); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Lectura de un fichero Con buffer: Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedReader br = Files . newBufferedReader ( p )) { String input ; while (( input = br . readLine ()) != null ) { System . out . println ( input ); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try { List < String > lines = Files . readAllLines ( p ); for ( String line : lines ) { System . out . println ( line ); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"1.5.- java.nio"},{"location":"ud1/15javanio/#javanio","text":"java.nio.file.Path : Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema. java.nio.file.Files : En combinaci\u00f3n con Path , realiza operaciones en ficheros o directorios. java.nio.file.FileSystem : Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear Path y otros objetos que acceden al sistema de ficheros. Todos los m\u00e9todos que acceden al sistema de ficheros lanzan una excepci\u00f3n de tipo IOException .","title":"java.nio"},{"location":"ud1/15javanio/#path","text":"Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase File , Path tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos. Path puede realizar todas las operaciones que se pueden realizar con la clase File . Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre.","title":"Path"},{"location":"ud1/15javanio/#filesystems-cargar-un-fichero-con-filesystems","text":"Path path = FileSystems . getDefault (). getPath ( \"fichero.txt\" );","title":"FileSystems. Cargar un fichero con FileSystems"},{"location":"ud1/15javanio/#escritura-en-un-fichero","text":"Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedWriter bw = Files . newBufferedWriter ( p )) { for ( int i = 0 ; i < 10 ; i ++ ) { bw . write ( String . valueOf ( i )); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"Escritura en un fichero"},{"location":"ud1/15javanio/#lectura-de-un-fichero","text":"Con buffer: Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try ( BufferedReader br = Files . newBufferedReader ( p )) { String input ; while (( input = br . readLine ()) != null ) { System . out . println ( input ); } } catch ( IOException e ) { throw new RuntimeException ( e ); } Path p = FileSystems . getDefault (). getPath ( \"ficPrueba.txt\" ); try { List < String > lines = Files . readAllLines ( p ); for ( String line : lines ) { System . out . println ( line ); } } catch ( IOException e ) { throw new RuntimeException ( e ); }","title":"Lectura de un fichero"},{"location":"ud1/16randomaccessfile/","text":"Acceso aleatorio a ficheros Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java. Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial . Los datos de un fichero de acceso secuencial NO se pueden actualizar . Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase RandomAccessFile . Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes. Puntero de la clase RandomAccessFile Un fichero de acceso aleatorio consta de una secuencia de bytes . \u00c9stos, admiten un puntero especial conocido como puntero de fichero ( file pointer ). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero. Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir. En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero. El puntero se puede mover utilizando el m\u00e9todo seek() . Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte). Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n. RandomAccessFile raf = .... raf . seek ( position ); //mueve el puntero a una posici\u00f3n raf . seek ( 0 ); //mueve el puntero al inicio del fichero raf . seek ( raf . length ()); //mueve el puntero al final del fichero Constructor de la clase RandomAccessFile Para construir un objeto de la clase tenemos que especificar el modo ( mode ) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido. r: el fichero es de solo lectura. rw: se abre en modo lectura-escritura. rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico. RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\"); Ejemplo de un programa que a\u00f1ade texto al final de un fichero public static void main ( String [] args ) { RandomAccessFile file = null ; try { file = new RandomAccessFile ( \"file.txt\" , \"rw\" ); file . seek ( file . length ()); // Moving file pointer to the end. file . writeBytes ( \"\\nJava\" ); // Append text. file . close (); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"1.6.- Ficheros de acceso aleatorio"},{"location":"ud1/16randomaccessfile/#acceso-aleatorio-a-ficheros","text":"Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java. Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial . Los datos de un fichero de acceso secuencial NO se pueden actualizar . Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase RandomAccessFile . Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes.","title":"Acceso aleatorio a ficheros"},{"location":"ud1/16randomaccessfile/#puntero-de-la-clase-randomaccessfile","text":"Un fichero de acceso aleatorio consta de una secuencia de bytes . \u00c9stos, admiten un puntero especial conocido como puntero de fichero ( file pointer ). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero. Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir. En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero. El puntero se puede mover utilizando el m\u00e9todo seek() . Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte). Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n. RandomAccessFile raf = .... raf . seek ( position ); //mueve el puntero a una posici\u00f3n raf . seek ( 0 ); //mueve el puntero al inicio del fichero raf . seek ( raf . length ()); //mueve el puntero al final del fichero","title":"Puntero de la clase RandomAccessFile"},{"location":"ud1/16randomaccessfile/#constructor-de-la-clase-randomaccessfile","text":"Para construir un objeto de la clase tenemos que especificar el modo ( mode ) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido. r: el fichero es de solo lectura. rw: se abre en modo lectura-escritura. rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico. RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\");","title":"Constructor de la clase RandomAccessFile"},{"location":"ud1/16randomaccessfile/#ejemplo-de-un-programa-que-anade-texto-al-final-de-un-fichero","text":"public static void main ( String [] args ) { RandomAccessFile file = null ; try { file = new RandomAccessFile ( \"file.txt\" , \"rw\" ); file . seek ( file . length ()); // Moving file pointer to the end. file . writeBytes ( \"\\nJava\" ); // Append text. file . close (); } catch ( IOException e ) { throw new RuntimeException ( e ); } }","title":"Ejemplo de un programa que a\u00f1ade texto al final de un fichero"},{"location":"ud1/17configfiles/","text":"Ficheros de configuraci\u00f3n En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d , en donde cada l\u00ednea tiene una pareja clave=valor . En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal. Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado datasource.properties , que almacena informaci\u00f3n sobre la base de datos: La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =. Java nos proporciona la clase Properties , para leer de forma sencilla los ficheros de configuraci\u00f3n. Cargar el fichero de configuraci\u00f3n Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties. Properties properties = new Properties (); Esta clase tiene un m\u00e9todo load() que permite cargar el fichero. No tenemos m\u00e1s que pasarle un InputStream o un Reader de java. properties . load ( new FileReader ( \"datasource.properties\" )); Leer una propiedad El m\u00e9todo properties.getProperty(String) nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\" , obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero). Si la clave no existe, obtendremos null como resultado. Sin embargo, tenemos una variante de getProperty() que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo: properties . getProperty ( \"db.username\" , \"default value\" )); Al m\u00e9todo getProperty() le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado. Leer todas las propiedades La clase Properties tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto Enumeration que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo keys() y luego realiza un bucle para ir sacando por pantalla todos los valores. Enumeration < Object > keys = properties . keys (); while ( keys . hasMoreElements ()) { Object key = keys . nextElement (); System . out . println ( key + \" = \" + properties . get ( key )); } A\u00f1adir o modificar una propiedad Para a\u00f1adir/modificar el valor de una propiedad, la clase Properties tiene un m\u00e9todo llamado setProperty(String key, String value) que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente. properties . setProperty ( \"db.port\" , \"4020\" ); Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase Properties tiene dos m\u00e9todos: save() y store() . El m\u00e9todo save() est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a store() pas\u00e1ndole un OutputStream o un Writer de java. properties . store ( new FileWriter ( \"datasource.properties\" ), \"Added database port\" ); El m\u00e9todo store() admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente: Contiene el comentario que pusimos en la llamada a store() y la fecha, que la inserta de regalo.","title":"1.7.- Ficheros de configuraci\u00f3n"},{"location":"ud1/17configfiles/#ficheros-de-configuracion","text":"En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d , en donde cada l\u00ednea tiene una pareja clave=valor . En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal. Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado datasource.properties , que almacena informaci\u00f3n sobre la base de datos: La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =. Java nos proporciona la clase Properties , para leer de forma sencilla los ficheros de configuraci\u00f3n.","title":"Ficheros de configuraci\u00f3n"},{"location":"ud1/17configfiles/#cargar-el-fichero-de-configuracion","text":"Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties. Properties properties = new Properties (); Esta clase tiene un m\u00e9todo load() que permite cargar el fichero. No tenemos m\u00e1s que pasarle un InputStream o un Reader de java. properties . load ( new FileReader ( \"datasource.properties\" ));","title":"Cargar el fichero de configuraci\u00f3n"},{"location":"ud1/17configfiles/#leer-una-propiedad","text":"El m\u00e9todo properties.getProperty(String) nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\" , obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero). Si la clave no existe, obtendremos null como resultado. Sin embargo, tenemos una variante de getProperty() que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo: properties . getProperty ( \"db.username\" , \"default value\" )); Al m\u00e9todo getProperty() le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado.","title":"Leer una propiedad"},{"location":"ud1/17configfiles/#leer-todas-las-propiedades","text":"La clase Properties tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto Enumeration que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo keys() y luego realiza un bucle para ir sacando por pantalla todos los valores. Enumeration < Object > keys = properties . keys (); while ( keys . hasMoreElements ()) { Object key = keys . nextElement (); System . out . println ( key + \" = \" + properties . get ( key )); }","title":"Leer todas las propiedades"},{"location":"ud1/17configfiles/#anadir-o-modificar-una-propiedad","text":"Para a\u00f1adir/modificar el valor de una propiedad, la clase Properties tiene un m\u00e9todo llamado setProperty(String key, String value) que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente. properties . setProperty ( \"db.port\" , \"4020\" ); Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase Properties tiene dos m\u00e9todos: save() y store() . El m\u00e9todo save() est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a store() pas\u00e1ndole un OutputStream o un Writer de java. properties . store ( new FileWriter ( \"datasource.properties\" ), \"Added database port\" ); El m\u00e9todo store() admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente: Contiene el comentario que pusimos en la llamada a store() y la fecha, que la inserta de regalo.","title":"A\u00f1adir o modificar una propiedad"},{"location":"ud1/18xmlfiles/","text":"Ficheros XML XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n. Estructura de un documento XML Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <nombre> , donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando. Documento XML v\u00e1lido Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones: Cada etiqueta de apertura tiene una etiqueta de cierre. Todas las etiquetas est\u00e1n completamente anidadas. Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial. El XML es sensible a may\u00fasculas y min\u00fasculas. Partes de un documento XML Pr\u00f3logo Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas. El pr\u00f3logo de un documento XML contiene: Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML. Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo. Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo: <?xml version=\"1.0\" encoding=\"UTF-8\"?> Cuerpo A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento. Elementos Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos. Atributos Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas. <person sex= \"female\" > <firstname> Patricia </firstname> <lastname> Marti </lastname> </person> En el ejemplo, el elemento person tiene un atributo sex . Comentarios Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato: <!-- Comment --> Ejemplo de un documento XML < ?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"> <!-- This is a comment --> <products> <product> <name> Cereales </name> <price> 3.45 </price> </product> <product> <name> Colacao </name> <price> 1.45 </price> </product> <product> <name> Agua mineral </name> <price> 1.00 </price> </product> </products> Url XML El est\u00e1ndar XML Java XML Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos. En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming). DOM El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria. DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria. SAX La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial. El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM. StAX Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM. Ejemplo lectura XML desde una API private static Document loadXMLDocument ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (); DocumentBuilder builder = factory . newDocumentBuilder (); return builder . parse ( input ); } catch ( Exception e ) { throw new RuntimeException ( e ); } } Escritura de un documento XML private static void writeXml ( Document doc , OutputStream output ) throws TransformerException { TransformerFactory transformerFactory = TransformerFactory . newInstance (); Transformer transformer = transformerFactory . newTransformer (); transformer . setOutputProperty ( OutputKeys . INDENT , \"yes\" ); DOMSource source = new DOMSource ( doc ); StreamResult result = new StreamResult ( output ); transformer . transform ( source , result ); }","title":"1.8.- XML"},{"location":"ud1/18xmlfiles/#ficheros-xml","text":"XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.","title":"Ficheros XML"},{"location":"ud1/18xmlfiles/#estructura-de-un-documento-xml","text":"Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <nombre> , donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.","title":"Estructura de un documento XML"},{"location":"ud1/18xmlfiles/#documento-xml-valido","text":"Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones: Cada etiqueta de apertura tiene una etiqueta de cierre. Todas las etiquetas est\u00e1n completamente anidadas. Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial. El XML es sensible a may\u00fasculas y min\u00fasculas.","title":"Documento XML v\u00e1lido"},{"location":"ud1/18xmlfiles/#partes-de-un-documento-xml","text":"","title":"Partes de un documento XML"},{"location":"ud1/18xmlfiles/#prologo","text":"Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas. El pr\u00f3logo de un documento XML contiene: Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML. Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo. Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo: <?xml version=\"1.0\" encoding=\"UTF-8\"?>","title":"Pr\u00f3logo"},{"location":"ud1/18xmlfiles/#cuerpo","text":"A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.","title":"Cuerpo"},{"location":"ud1/18xmlfiles/#elementos","text":"Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.","title":"Elementos"},{"location":"ud1/18xmlfiles/#atributos","text":"Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas. <person sex= \"female\" > <firstname> Patricia </firstname> <lastname> Marti </lastname> </person> En el ejemplo, el elemento person tiene un atributo sex .","title":"Atributos"},{"location":"ud1/18xmlfiles/#comentarios","text":"Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato: <!-- Comment -->","title":"Comentarios"},{"location":"ud1/18xmlfiles/#ejemplo-de-un-documento-xml","text":"< ?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"> <!-- This is a comment --> <products> <product> <name> Cereales </name> <price> 3.45 </price> </product> <product> <name> Colacao </name> <price> 1.45 </price> </product> <product> <name> Agua mineral </name> <price> 1.00 </price> </product> </products>","title":"Ejemplo de un documento XML"},{"location":"ud1/18xmlfiles/#url-xml","text":"El est\u00e1ndar XML","title":"Url XML"},{"location":"ud1/18xmlfiles/#java-xml","text":"Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos. En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming).","title":"Java XML"},{"location":"ud1/18xmlfiles/#dom","text":"El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria. DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.","title":"DOM"},{"location":"ud1/18xmlfiles/#sax","text":"La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial. El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.","title":"SAX"},{"location":"ud1/18xmlfiles/#stax","text":"Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.","title":"StAX"},{"location":"ud1/18xmlfiles/#ejemplo-lectura-xml-desde-una-api","text":"private static Document loadXMLDocument ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (); DocumentBuilder builder = factory . newDocumentBuilder (); return builder . parse ( input ); } catch ( Exception e ) { throw new RuntimeException ( e ); } }","title":"Ejemplo lectura XML desde una API"},{"location":"ud1/18xmlfiles/#escritura-de-un-documento-xml","text":"private static void writeXml ( Document doc , OutputStream output ) throws TransformerException { TransformerFactory transformerFactory = TransformerFactory . newInstance (); Transformer transformer = transformerFactory . newTransformer (); transformer . setOutputProperty ( OutputKeys . INDENT , \"yes\" ); DOMSource source = new DOMSource ( doc ); StreamResult result = new StreamResult ( output ); transformer . transform ( source , result ); }","title":"Escritura de un documento XML"},{"location":"ud1/19jsonfiles/","text":"Ficheros JSON JSON ( JavaScript Object Notation ) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos. JSON se utiliza hoy en d\u00eda en cada API web \u00fanica. JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra: Una colecci\u00f3n de pares de name/value . En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa. Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia. Tipos de datos disponibles N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456 Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\" Booleanos: Representan valores booleanos y pueden tener dos valores: true y false null: Representan el valor nulo. Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes. Objetos: Son colecciones no ordenadas de pares de la forma nombre:valor separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo. Formato JSON Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con {(llave izquierda) y termina con} (llave derecha). Cada nombre va seguido de: (dos puntos) y los pares de name/value est\u00e1n separados por, (coma). Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con [(corchete izquierdo) y termina con] (corchete derecho). Los valores est\u00e1n separados por (coma). Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar. Ejemplo de fichero JSON # Fichero JSON { \"web-app\" : { \"servlet\" : [ { \"servlet-name\" : \"cofaxCDS\" , \"servlet-class\" : \"org.cofax.cds.CDSServlet\" , \"init-param\" : { \"configGlossary:installationAt\" : \"Philadelphia, PA\" , \"configGlossary:adminEmail\" : \"p.marti2@edu.gva.es\" , \"configGlossary:poweredBy\" : \"Patricia Marti\" , \"configGlossary:poweredByIcon\" : \"/images/cofax.gif\" , \"configGlossary:staticPath\" : \"/content/static\" , \"templateProcessorClass\" : \"org.cofax.WysiwygTemplate\" , \"templateLoaderClass\" : \"org.cofax.FilesTemplateLoader\" , \"templatePath\" : \"templates\" , \"templateOverridePath\" : \"\" , \"defaultListTemplate\" : \"listTemplate.htm\" , \"defaultFileTemplate\" : \"articleTemplate.htm\" , \"useJSP\" : false , \"dataStoreMaxConns\" : 100 } }, null , { \"servlet-name\" : \"cofaxEmail\" , \"servlet-class\" : \"org.cofax.cds.EmailServlet\" , \"init-param\" : { \"mailHost\" : \"mail1\" , \"mailHostOverride\" : \"mail2\" } }], \"servlet-mapping\" : { \"cofaxCDS\" : \"/\" , \"cofaxEmail\" : \"/cofaxutil/aemail/*\" , \"cofaxAdmin\" : \"/admin/*\" , \"fileServlet\" : \"/static/*\" , \"cofaxTools\" : \"/tools/*\" }, \"taglib\" : { \"taglib-uri\" : \"cofax.tld\" , \"taglib-location\" : \"/WEB-INF/tlds/cofax.tld\" } } } El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase Servlet , donde la clase Servlet estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc. Existen varias librer\u00edas en Java para parsear ficheros JSON. Entre las m\u00e1s comunes est\u00e1n: Gson, Jackson, JSON.simple, org.json, JsonPATH, etc. URL oficial The JSON Specification JSON vs XML Java JSON Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros. En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n). Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n. Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json . Los archivos en este paquete implementan codificadores/decodificadores JSON en Java. Leer un JSON a partir de una API //Este m\u00e9todo accede a una URL y se descarga el contenido en forma de String public static String stream ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { InputStreamReader isr = new InputStreamReader ( input ); BufferedReader reader = new BufferedReader ( isr ); StringBuilder json = new StringBuilder (); int c ; while (( c = reader . read ()) != - 1 ) { json . append (( char ) c ); } return json . toString (); } catch ( IOException e ) { throw new RuntimeException ( e ); } } public static void main ( String [] args ) { String caturl = \"https://catfact.ninja/facts\" ; //parseamos un string a un JSONObject JSONObject jsonObject = new JSONObject ( stream ( caturl )); JSONArray a = jsonObject . getJSONArray ( \"data\" ); JSONObject o = ( JSONObject ) a . get ( 0 ); System . out . println ( o . getString ( \"fact\" )); } Un JSONObject es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.","title":"1.9.- JSON"},{"location":"ud1/19jsonfiles/#ficheros-json","text":"JSON ( JavaScript Object Notation ) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos. JSON se utiliza hoy en d\u00eda en cada API web \u00fanica. JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra: Una colecci\u00f3n de pares de name/value . En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa. Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia.","title":"Ficheros JSON"},{"location":"ud1/19jsonfiles/#tipos-de-datos-disponibles","text":"N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456 Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\" Booleanos: Representan valores booleanos y pueden tener dos valores: true y false null: Representan el valor nulo. Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes. Objetos: Son colecciones no ordenadas de pares de la forma nombre:valor separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.","title":"Tipos de datos disponibles"},{"location":"ud1/19jsonfiles/#formato-json","text":"Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con {(llave izquierda) y termina con} (llave derecha). Cada nombre va seguido de: (dos puntos) y los pares de name/value est\u00e1n separados por, (coma). Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con [(corchete izquierdo) y termina con] (corchete derecho). Los valores est\u00e1n separados por (coma). Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar.","title":"Formato JSON"},{"location":"ud1/19jsonfiles/#ejemplo-de-fichero-json","text":"# Fichero JSON { \"web-app\" : { \"servlet\" : [ { \"servlet-name\" : \"cofaxCDS\" , \"servlet-class\" : \"org.cofax.cds.CDSServlet\" , \"init-param\" : { \"configGlossary:installationAt\" : \"Philadelphia, PA\" , \"configGlossary:adminEmail\" : \"p.marti2@edu.gva.es\" , \"configGlossary:poweredBy\" : \"Patricia Marti\" , \"configGlossary:poweredByIcon\" : \"/images/cofax.gif\" , \"configGlossary:staticPath\" : \"/content/static\" , \"templateProcessorClass\" : \"org.cofax.WysiwygTemplate\" , \"templateLoaderClass\" : \"org.cofax.FilesTemplateLoader\" , \"templatePath\" : \"templates\" , \"templateOverridePath\" : \"\" , \"defaultListTemplate\" : \"listTemplate.htm\" , \"defaultFileTemplate\" : \"articleTemplate.htm\" , \"useJSP\" : false , \"dataStoreMaxConns\" : 100 } }, null , { \"servlet-name\" : \"cofaxEmail\" , \"servlet-class\" : \"org.cofax.cds.EmailServlet\" , \"init-param\" : { \"mailHost\" : \"mail1\" , \"mailHostOverride\" : \"mail2\" } }], \"servlet-mapping\" : { \"cofaxCDS\" : \"/\" , \"cofaxEmail\" : \"/cofaxutil/aemail/*\" , \"cofaxAdmin\" : \"/admin/*\" , \"fileServlet\" : \"/static/*\" , \"cofaxTools\" : \"/tools/*\" }, \"taglib\" : { \"taglib-uri\" : \"cofax.tld\" , \"taglib-location\" : \"/WEB-INF/tlds/cofax.tld\" } } } El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase Servlet , donde la clase Servlet estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc. Existen varias librer\u00edas en Java para parsear ficheros JSON. Entre las m\u00e1s comunes est\u00e1n: Gson, Jackson, JSON.simple, org.json, JsonPATH, etc.","title":"Ejemplo de fichero JSON"},{"location":"ud1/19jsonfiles/#url-oficial","text":"The JSON Specification","title":"URL oficial"},{"location":"ud1/19jsonfiles/#json-vs-xml","text":"","title":"JSON vs XML"},{"location":"ud1/19jsonfiles/#java-json","text":"Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros. En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n). Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n. Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json . Los archivos en este paquete implementan codificadores/decodificadores JSON en Java.","title":"Java JSON"},{"location":"ud1/19jsonfiles/#leer-un-json-a-partir-de-una-api","text":"//Este m\u00e9todo accede a una URL y se descarga el contenido en forma de String public static String stream ( String url ) { try ( InputStream input = new URL ( url ). openStream ()) { InputStreamReader isr = new InputStreamReader ( input ); BufferedReader reader = new BufferedReader ( isr ); StringBuilder json = new StringBuilder (); int c ; while (( c = reader . read ()) != - 1 ) { json . append (( char ) c ); } return json . toString (); } catch ( IOException e ) { throw new RuntimeException ( e ); } } public static void main ( String [] args ) { String caturl = \"https://catfact.ninja/facts\" ; //parseamos un string a un JSONObject JSONObject jsonObject = new JSONObject ( stream ( caturl )); JSONArray a = jsonObject . getJSONArray ( \"data\" ); JSONObject o = ( JSONObject ) a . get ( 0 ); System . out . println ( o . getString ( \"fact\" )); } Un JSONObject es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.","title":"Leer un JSON a partir de una API"},{"location":"ud1/20createjar/","text":"C\u00f3mo crear un jar en IntelliJ Vamos a File --> Project Structure En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --> \"From modules with dependencies\" Le decimos cu\u00e1l es la clase main y aceptamos. Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --> \"Build Artifact\". Seleccionamos \"Build\". El .jar estar\u00e1 en la carpeta del proyecto dentro de /out/artifacts/...","title":"1.10.- Crear un .jar"},{"location":"ud1/20createjar/#como-crear-un-jar-en-intellij","text":"Vamos a File --> Project Structure En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --> \"From modules with dependencies\" Le decimos cu\u00e1l es la clase main y aceptamos. Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --> \"Build Artifact\". Seleccionamos \"Build\". El .jar estar\u00e1 en la carpeta del proyecto dentro de /out/artifacts/...","title":"C\u00f3mo crear un jar en IntelliJ"},{"location":"ud1/21tryresources/","text":"\ud83e\udd73 try-with-resources La sentencia try-with-resources es una sentencia try que declara uno o m\u00e1s recursos (resources). Un recurso es un objeto que debe cerrarse despu\u00e9s de que el programa termine con \u00e9l. La instrucci\u00f3n try-with-resources garantiza que cada recurso se cierre al final de la instrucci\u00f3n. Cualquier objeto que implemente java.lang.AutoCloseable, que incluye todos los objetos que implementen java.io.Closeable, se puede utilizar como recurso, por lo que no ser\u00eda necesario realizar la sentencia recurso.close() . Antes de Java SE 7, se pod\u00eda usar un bloque finally para asegurarse de que un recurso se cerraba, independientemente de si el try generaba excepci\u00f3n o no. El siguiente ejemplo, creamos el objeto FileWriter en la l\u00ednea 2, en vez de hacerlo en la 4 porque el finally de la l\u00ednea 8 se encuentra en otro scope y la variable fw no existe. public static void main ( String [] args ) { FileWriter fw = null ; try { fw = new FileWriter ( \"prueba.txt\" ); fw . write ( \"texto de prueba\" ); } catch ( IOException e ) { e . printStackTrace (); } finally { try { if ( fw != null ) { System . out . println ( \"El fichero se cierra\" ); fw . close (); } } catch ( IOException e ) { e . printStackTrace (); } } } Al hacer el close() manualmente, vemos que el c\u00f3digo queda bastante engorroso, ya que la sentencia close lanza una excepci\u00f3n que hay que capturar. Con try-with-resources el c\u00f3digo queda m\u00e1s limpio. Importante diferencia entre try-with-resources y try con finally \ud83e\udd14 Existe una ligera mejora al usar try-with-resources. Si en el c\u00f3digo anterior se lanzara una excepci\u00f3n al escribir el fichero, \u00e9sta se capturar\u00eda y se ejecutar\u00eda el finally a continuaci\u00f3n. Si \u00e9ste a su vez, lanzara tambi\u00e9n una excepci\u00f3n al llamar al m\u00e9todo close , se reenviar\u00eda esta, NO la primera que se gener\u00f3. Esto cambia ligeramente en el try-with-resources, puesto que enviar\u00eda la primera excepci\u00f3n que se gener\u00f3. Lo cual tiene sentido, puesto que fue la causante del error. As\u00ed quedar\u00eda el c\u00f3digo usando try-with-resources: public static void main ( String [] args ) throws IOException { try ( FileWriter fw = new FileWriter ( \"prueba.txt\" ); FileWriter fw2 = new FileWriter ( \"prueba2.txt\" );) { //si quisiera poner un segundo writer quedar\u00eda as\u00ed fw . write ( \"texto de prueba\" ); } } Nota \ud83e\udd13 Podemos declarar varios recursos dentro de un mismo try como se ve en el ejemplo.","title":"1.11.- try-with-resources"},{"location":"ud1/21tryresources/#try-with-resources","text":"La sentencia try-with-resources es una sentencia try que declara uno o m\u00e1s recursos (resources). Un recurso es un objeto que debe cerrarse despu\u00e9s de que el programa termine con \u00e9l. La instrucci\u00f3n try-with-resources garantiza que cada recurso se cierre al final de la instrucci\u00f3n. Cualquier objeto que implemente java.lang.AutoCloseable, que incluye todos los objetos que implementen java.io.Closeable, se puede utilizar como recurso, por lo que no ser\u00eda necesario realizar la sentencia recurso.close() . Antes de Java SE 7, se pod\u00eda usar un bloque finally para asegurarse de que un recurso se cerraba, independientemente de si el try generaba excepci\u00f3n o no. El siguiente ejemplo, creamos el objeto FileWriter en la l\u00ednea 2, en vez de hacerlo en la 4 porque el finally de la l\u00ednea 8 se encuentra en otro scope y la variable fw no existe. public static void main ( String [] args ) { FileWriter fw = null ; try { fw = new FileWriter ( \"prueba.txt\" ); fw . write ( \"texto de prueba\" ); } catch ( IOException e ) { e . printStackTrace (); } finally { try { if ( fw != null ) { System . out . println ( \"El fichero se cierra\" ); fw . close (); } } catch ( IOException e ) { e . printStackTrace (); } } } Al hacer el close() manualmente, vemos que el c\u00f3digo queda bastante engorroso, ya que la sentencia close lanza una excepci\u00f3n que hay que capturar. Con try-with-resources el c\u00f3digo queda m\u00e1s limpio. Importante diferencia entre try-with-resources y try con finally \ud83e\udd14 Existe una ligera mejora al usar try-with-resources. Si en el c\u00f3digo anterior se lanzara una excepci\u00f3n al escribir el fichero, \u00e9sta se capturar\u00eda y se ejecutar\u00eda el finally a continuaci\u00f3n. Si \u00e9ste a su vez, lanzara tambi\u00e9n una excepci\u00f3n al llamar al m\u00e9todo close , se reenviar\u00eda esta, NO la primera que se gener\u00f3. Esto cambia ligeramente en el try-with-resources, puesto que enviar\u00eda la primera excepci\u00f3n que se gener\u00f3. Lo cual tiene sentido, puesto que fue la causante del error. As\u00ed quedar\u00eda el c\u00f3digo usando try-with-resources: public static void main ( String [] args ) throws IOException { try ( FileWriter fw = new FileWriter ( \"prueba.txt\" ); FileWriter fw2 = new FileWriter ( \"prueba2.txt\" );) { //si quisiera poner un segundo writer quedar\u00eda as\u00ed fw . write ( \"texto de prueba\" ); } } Nota \ud83e\udd13 Podemos declarar varios recursos dentro de un mismo try como se ve en el ejemplo.","title":"\ud83e\udd73 try-with-resources"},{"location":"ud2/21persistencia/","text":"\ud83d\udcbe Persistencia de la informaci\u00f3n La persistencia es la capacidad de guardar el estado de un objeto en alg\u00fan tipo de almacenamiento, para poder restaurarlo en alg\u00fan momento posteriormente. Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos. Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente. Tipos de bases de datos Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que se pueda hacer una r\u00e1pida b\u00fasqueda y recuperar con ayuda de un ordenador. Hoy en d\u00eda, las bases de datos tambi\u00e9n sirven para desarrollar an\u00e1lisis. Las bases de datos m\u00e1s modernas tienen motores espec\u00edficos para sacar informes de datos complejos. Adem\u00e1s, es importante saber que hay varios tipos de base de datos: la relacional; la distribuida; NoSQL; orientada a objetos; y, gr\u00e1ficas. La existencia de estas diversas bases de datos se debe a la variedad de forma de trabajo que se requiere de ellas. Las bases de datos relacionales representan la informaci\u00f3n en forma de tablas, con filas y columnas que se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL , para poder realizar las consultas que deseemos a la base de datos. El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS), gestiona el modo en que los datos se almacenan, mantienen y recuperan. En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS). Tradicionalmente, la programaci\u00f3n de bases de datos ha sido un caos debido a la gran cantidad de productos de bases de datos en el mercado, cada uno con sus caracter\u00edsticas y lenguaje diferente.","title":"2.1.- Persistencia de la informaci\u00f3n"},{"location":"ud2/21persistencia/#persistencia-de-la-informacion","text":"La persistencia es la capacidad de guardar el estado de un objeto en alg\u00fan tipo de almacenamiento, para poder restaurarlo en alg\u00fan momento posteriormente. Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos. Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.","title":"\ud83d\udcbe Persistencia de la informaci\u00f3n"},{"location":"ud2/21persistencia/#tipos-de-bases-de-datos","text":"Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que se pueda hacer una r\u00e1pida b\u00fasqueda y recuperar con ayuda de un ordenador. Hoy en d\u00eda, las bases de datos tambi\u00e9n sirven para desarrollar an\u00e1lisis. Las bases de datos m\u00e1s modernas tienen motores espec\u00edficos para sacar informes de datos complejos. Adem\u00e1s, es importante saber que hay varios tipos de base de datos: la relacional; la distribuida; NoSQL; orientada a objetos; y, gr\u00e1ficas. La existencia de estas diversas bases de datos se debe a la variedad de forma de trabajo que se requiere de ellas. Las bases de datos relacionales representan la informaci\u00f3n en forma de tablas, con filas y columnas que se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL , para poder realizar las consultas que deseemos a la base de datos. El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS), gestiona el modo en que los datos se almacenan, mantienen y recuperan. En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS). Tradicionalmente, la programaci\u00f3n de bases de datos ha sido un caos debido a la gran cantidad de productos de bases de datos en el mercado, cada uno con sus caracter\u00edsticas y lenguaje diferente.","title":"Tipos de bases de datos"},{"location":"ud2/22mapeo/","text":"\u26d3\ufe0f Desfase objeto - relacional Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos. El desfase objeto-relacional consiste en la diferencia de aspectos que existen entre la programaci\u00f3n orientada a objetos y la base de datos. Hay que recordar que el modelo relacional trata con relaciones y conjuntos y que, en las BD relacionales tenemos reglas de integridad: Todas las tablas deben tener una clave primaria La clave primaria tiene que ser \u00fanica y no puede ser NULL Para relacionar dos tablas usamos una foreign key Sin embargo, el modelo de Programaci\u00f3n Orientada a Objetos trata con objetos y las asociaciones entre ellos. Por esta raz\u00f3n, el problema entre estos dos modelos surge en el momento de querer persistir los objetos. Mapeo objeto - relacional Al trabajar con POO y BDR tenemos que estar continuamente gestionando los objetos para escribir la sentencia SQL, o recolectar todos los atributos para componer un objeto cuando leemos informaci\u00f3n desde la base de datos. A este conjunto de t\u00e9cnicas se le conoce como mapeo objeto-relacional. Y puede hacerse ayud\u00e1ndose de alguna herramienta o bien manualmente por el programador.","title":"2.2.- Desfase objeto-relacional"},{"location":"ud2/22mapeo/#desfase-objeto-relacional","text":"Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos. El desfase objeto-relacional consiste en la diferencia de aspectos que existen entre la programaci\u00f3n orientada a objetos y la base de datos. Hay que recordar que el modelo relacional trata con relaciones y conjuntos y que, en las BD relacionales tenemos reglas de integridad: Todas las tablas deben tener una clave primaria La clave primaria tiene que ser \u00fanica y no puede ser NULL Para relacionar dos tablas usamos una foreign key Sin embargo, el modelo de Programaci\u00f3n Orientada a Objetos trata con objetos y las asociaciones entre ellos. Por esta raz\u00f3n, el problema entre estos dos modelos surge en el momento de querer persistir los objetos.","title":"\u26d3\ufe0f Desfase objeto - relacional"},{"location":"ud2/22mapeo/#mapeo-objeto-relacional","text":"Al trabajar con POO y BDR tenemos que estar continuamente gestionando los objetos para escribir la sentencia SQL, o recolectar todos los atributos para componer un objeto cuando leemos informaci\u00f3n desde la base de datos. A este conjunto de t\u00e9cnicas se le conoce como mapeo objeto-relacional. Y puede hacerse ayud\u00e1ndose de alguna herramienta o bien manualmente por el programador.","title":"Mapeo objeto - relacional"},{"location":"ud2/23conectores/","text":"\u2699\ufe0f Conectores o drivers Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos. Algunos de los m\u00e1s conocidos son: ODBC (Open Database Connectivity) . Es un est\u00e1ndar viejo. Esta tecnolog\u00eda proporciona una interfaz com\u00fan para tener acceso a bases de datos SQL heterog\u00e9neas. ODBC est\u00e1 basado en SQL (Structured Query Language) como un est\u00e1ndar para tener acceso a datos. ODBC permite la conexi\u00f3n f\u00e1cil desde varios lenguajes de programaci\u00f3n y se utiliza mucho en el entorno Windows. JDBC (Java Data Base Connectivity) . En este curso, nos vamos a centrar en JDBC, puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos. Y, adem\u00e1s, Java 8 ha eliminado el puente JDBC-ODBC, lo que significa que los controladores ODBC de Microsoft ya no funcionan. JDBC Casi de forma simult\u00e1nea a ODBC, la empresa Sun Microsystems, en 1997 sac\u00f3 a la luz JDBC, un API conector de bases de datos, implementado espec\u00edficamente para usar con el lenguaje Java. Se trata de un API bastante similar a ODBC en cuanto a funcionalidad, pero adaptado a las especificidades de Java. Es decir, la funcionalidad se encuentra capsulada en clases (ya que Java es un lenguaje totalmente orientado a objetos) y, adem\u00e1s, no depende de ninguna plataforma espec\u00edfica, de acuerdo con la caracter\u00edstica multiplataforma defendida por Java. Es una API que permite la ejecuci\u00f3n de operaciones contra una base de datos desde Java independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se acceda. Es importante destacar tambi\u00e9n que JDBC no exige ninguna instalaci\u00f3n, ni ning\u00fan cambio sustancial en el c\u00f3digo a la hora de utilizar uno u otro controlador. Esta caracter\u00edstica se sustenta, en primer lugar, en la utilidad de Java que permite cargar program\u00e1ticamente cualquier clase a partir de su nombre; en segundo lugar, en la funcionalidad de la clase DriverManager (de la API JDBC), que sin necesidad de indicarle el driver espec\u00edfico que hay que utilizar es capaz de encontrarlo y seleccionarlo de entre todos los que el sistema tenga cargados en memoria. A pesar de eso tampoco es mucho problema ya que actualmente podemos encontrar un driver JDBC para pr\u00e1cticamente cualquier SGBDR existente. El conector lo proporciona el fabricante de la base de datos o bien un tercero. Conexi\u00f3n con la BBDD desde JDBC Antes de empezar a desarrollar aplicaciones JDBC es necesario aseguramos que tenemos instalado el SGBD, y adem\u00e1s que tenemos acceso desde el lugar donde estemos desarrollando la aplicaci\u00f3n. Una vez verificado el sistema gestor de base de datos, ser\u00e1 necesario obtener el controlador JDBC del sistema gestor. Generalmente, cada fabricante pondr\u00e1 a disposici\u00f3n de sus usuarios los diferentes tipos de controladores que tenga para sus productos. Sea cual sea el tipo de controlador que finalmente necesita, \u00e9ste tendr\u00e1 como m\u00ednimo una biblioteca en formato .jar con todas las clases de la API JDBC. Habr\u00e1 que a\u00f1adir el archivo .jar como biblioteca de nuestra aplicaci\u00f3n. Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven: MySQL JDBC Establecimiento y cierre de conexi\u00f3n Las clases que afectan a la gesti\u00f3n de la conexi\u00f3n con la BBDD son: DriverManager : esta clase se utiliza para registrar el controlador para un tipo de base de datos espec\u00edfico (por ejemplo, MySQL en este tutorial) y para establecer una conexi\u00f3n de base de datos con el servidor a trav\u00e9s de su m\u00e9todo getConnection() . Connection , es una interfaz que representa una conexi\u00f3n a la base de datos establecida (sesi\u00f3n) desde la cual podemos crear declaraciones para ejecutar consultas y recuperar resultados, obtener metadatos sobre la base de datos, cerrar conexi\u00f3n, etc.Los objetos Connection mantendr\u00e1n la capacidad de comunicarse con el sistema gestor mientras permanezcan abiertos. Esto es, desde que se crean hasta que se cierran utilizando el m\u00e9todo close. El objeto Connection est\u00e1 totalmente vinculado a una fuente de datos, por eso en pedir la conexi\u00f3n hay que especificar de qu\u00e9 fuente se trata siguiendo el protocolo JDBC e indicando la url de los datos, y en su caso el usuario y password. Example \ud83e\udd13 jdbc : bbdd :// server : port / schema jdbc :postgresql://localhost:5432/severo La url seguir\u00e1 el protocolo JDBC, comenzar\u00e1 siempre por la palabra jdbc seguida de dos puntos. El resto depender\u00e1 del tipo de controlador utilizado, del host donde se aloje el SGBD, del puerto que este use para escuchar las peticiones y del nombre de la base de datos o esquema con el que queremos trabajar. import java.sql.Connection ; import java.sql.DriverManager ; import java.sql.SQLException ; ... public static void main ( String [] args ) { String user = \"patricia\" ; String password = \"marti\" ; String url = \"jdbc:mysql://localhost/severo_ad\" ; try ( final Connection connection = DriverManager . getConnection ( url , user , password )) { System . out . println ( connection . getCatalog ()); } catch ( SQLException ex ) { System . out . println ( \"SQLException: \" + ex . getMessage ()); System . out . println ( \"SQLState: \" + ex . getSQLState ()); System . out . println ( \"VendorError: \" + ex . getErrorCode ()); } } Operaciones b\u00e1sicas El API JDBC distingue dos tipos de consultas: Consultas : SELECT Actualizaciones : INSERT, UPDATE, DELETE, sentencias DDL. Interfaces y clases principales de JDBC Statement y PreparedStatement : estas interfaces se utilizan para ejecutar consultas SQL est\u00e1ticas y consultas SQL parametrizadas, respectivamente. Statement es la superinterfaz de la interfaz PreparedStatement , que se utiliza para consultas parametrizadas. Sus m\u00e9todos com\u00fanmente utilizados son: boolean execute(String sql) : ejecuta una sentencia SQL general. Devuelve verdadero si la consulta devuelve un ResultSet , falso si la consulta devuelve un recuento de actualizaciones o no devuelve nada. Este m\u00e9todo solo se puede utilizar con una sentencia. int executeUpdate(String sql) : ejecuta una sentencia INSERT, UPDATE o DELETE y devuelve un conteo actualizado que indica el n\u00famero de filas afectadas (por ejemplo, 1 fila insertada, 2 filas actualizadas o 0 filas afectadas). Statement stmt = con . createStatement (); String q1 = \"insert into userid values (1,root,Patricia Marti)\" ; int x = stmt . executeUpdate ( q1 ); ResultSet executeQuery(String sql) : ejecuta una sentencia SELECT y devuelve un objeto ResultSet que contiene los resultados devueltos por la consulta. Statement stmt = con . createStatement (); String q1 = \"select * from userid where id = '\" + id + \"' AND pwd = '\" + pwd + \"'\" ; ResultSet rs = stmt . executeQuery ( q1 ); ResultSet : contiene los datos de la tabla devueltos por una consulta SELECT. Este objeto se usa para iterar sobre las filas en el conjunto de resultados usando el m\u00e9todo next() . \ud83e\udd13 SQLException: Es la excepci\u00f3n que se lanza cuando hay alg\u00fan problema entre la base de datos y el programa Java JDBC. Contiene los siguientes m\u00e9todos: .getMessage() , nos indica la descripci\u00f3n del mensaje de error. .getSQLState() , devuelve un c\u00f3digo SQL est\u00e1ndar definido por ISO/ANSI y el Open Group que identifica de forma un\u00edvoca el error que se ha producido. SQLState Official .getErrorCode( ), es un c\u00f3digo de error que lanza la base de datos. En este caso el c\u00f3digo de error es diferente dependiendo del proveedor de base de datos que estemos utilizando. .getCause() , nos devuelve una lista de objetos que han provocado el error. .getNextException() , devuelve la cadena de excepciones que se ha producido. De tal manera que podemos navegar sobre ella para ver en detalle de esas excepciones. Liberaci\u00f3n de recursos Danger \ud83d\ude2c Se debe cerrar expl\u00edcitamente Statement , ResultSet y Connection cuando ya no se necesiten, a menos que se declaren con un try-catch-with-resources. Las instancias de Connection y las de Statement almacenan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras permanecen activas mantienen en el SGBD un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. El cierre de estos objetos permite liberar recursos tanto del cliente como del servidor. Aunque se haya cerrado la conexi\u00f3n, los objetos Statements que no se hab\u00edan cerrado expresamente permanecen m\u00e1s tiempo en memoria que los objetos cerrados previamente, ya que el garbage collector de Java deber\u00e1 hacer m\u00e1s comprobaciones para asegurar que ya no dispone de dependencias ni internas ni externas y se puede eliminar. Es por ello que se recomienda proceder siempre a cerrarlo manualmente utilizando el m\u00e9todo close() . El cierre de los objetos Statement asegura la liberaci\u00f3n inmediata de los recursos y la anulaci\u00f3n de las dependencias. Si en un mismo m\u00e9todo queremos cerrar un objeto Statement y Connection , lo haremos siguiendo estos pasos: Cerramos el Statement y la instancia Connection . Failure \ud83d\ude35\u200d\ud83d\udcab Si lo hici\u00e9ramos al rev\u00e9s, cuando intent\u00e1ramos cerrar el Statement nos saltar\u00eda una excepci\u00f3n de tipo SQLException , ya que el cierre de la conexi\u00f3n lo habr\u00eda dejado inaccesible. Cuando se cierra un objeto Statement , su objeto ResultSet actual, si existe, tambi\u00e9n se cierra. Pero eso no ocurre cuando se cierra la conexi\u00f3n. try ( Connection connection = dataSource . getConnection (); Statement statement = connection . createStatement ()) { try ( ResultSet resultSet = statement . executeQuery ( \"SELECT * FROM ....\" )) { // Do actions. } }","title":"2.3.- Manejo de conectores - JDBC"},{"location":"ud2/23conectores/#conectores-o-drivers","text":"Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos. Algunos de los m\u00e1s conocidos son: ODBC (Open Database Connectivity) . Es un est\u00e1ndar viejo. Esta tecnolog\u00eda proporciona una interfaz com\u00fan para tener acceso a bases de datos SQL heterog\u00e9neas. ODBC est\u00e1 basado en SQL (Structured Query Language) como un est\u00e1ndar para tener acceso a datos. ODBC permite la conexi\u00f3n f\u00e1cil desde varios lenguajes de programaci\u00f3n y se utiliza mucho en el entorno Windows. JDBC (Java Data Base Connectivity) . En este curso, nos vamos a centrar en JDBC, puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos. Y, adem\u00e1s, Java 8 ha eliminado el puente JDBC-ODBC, lo que significa que los controladores ODBC de Microsoft ya no funcionan.","title":"\u2699\ufe0f Conectores o drivers"},{"location":"ud2/23conectores/#jdbc","text":"Casi de forma simult\u00e1nea a ODBC, la empresa Sun Microsystems, en 1997 sac\u00f3 a la luz JDBC, un API conector de bases de datos, implementado espec\u00edficamente para usar con el lenguaje Java. Se trata de un API bastante similar a ODBC en cuanto a funcionalidad, pero adaptado a las especificidades de Java. Es decir, la funcionalidad se encuentra capsulada en clases (ya que Java es un lenguaje totalmente orientado a objetos) y, adem\u00e1s, no depende de ninguna plataforma espec\u00edfica, de acuerdo con la caracter\u00edstica multiplataforma defendida por Java. Es una API que permite la ejecuci\u00f3n de operaciones contra una base de datos desde Java independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se acceda. Es importante destacar tambi\u00e9n que JDBC no exige ninguna instalaci\u00f3n, ni ning\u00fan cambio sustancial en el c\u00f3digo a la hora de utilizar uno u otro controlador. Esta caracter\u00edstica se sustenta, en primer lugar, en la utilidad de Java que permite cargar program\u00e1ticamente cualquier clase a partir de su nombre; en segundo lugar, en la funcionalidad de la clase DriverManager (de la API JDBC), que sin necesidad de indicarle el driver espec\u00edfico que hay que utilizar es capaz de encontrarlo y seleccionarlo de entre todos los que el sistema tenga cargados en memoria. A pesar de eso tampoco es mucho problema ya que actualmente podemos encontrar un driver JDBC para pr\u00e1cticamente cualquier SGBDR existente. El conector lo proporciona el fabricante de la base de datos o bien un tercero.","title":"JDBC"},{"location":"ud2/23conectores/#conexion-con-la-bbdd-desde-jdbc","text":"Antes de empezar a desarrollar aplicaciones JDBC es necesario aseguramos que tenemos instalado el SGBD, y adem\u00e1s que tenemos acceso desde el lugar donde estemos desarrollando la aplicaci\u00f3n. Una vez verificado el sistema gestor de base de datos, ser\u00e1 necesario obtener el controlador JDBC del sistema gestor. Generalmente, cada fabricante pondr\u00e1 a disposici\u00f3n de sus usuarios los diferentes tipos de controladores que tenga para sus productos. Sea cual sea el tipo de controlador que finalmente necesita, \u00e9ste tendr\u00e1 como m\u00ednimo una biblioteca en formato .jar con todas las clases de la API JDBC. Habr\u00e1 que a\u00f1adir el archivo .jar como biblioteca de nuestra aplicaci\u00f3n. Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven: MySQL JDBC","title":"Conexi\u00f3n con la BBDD desde JDBC"},{"location":"ud2/23conectores/#establecimiento-y-cierre-de-conexion","text":"Las clases que afectan a la gesti\u00f3n de la conexi\u00f3n con la BBDD son: DriverManager : esta clase se utiliza para registrar el controlador para un tipo de base de datos espec\u00edfico (por ejemplo, MySQL en este tutorial) y para establecer una conexi\u00f3n de base de datos con el servidor a trav\u00e9s de su m\u00e9todo getConnection() . Connection , es una interfaz que representa una conexi\u00f3n a la base de datos establecida (sesi\u00f3n) desde la cual podemos crear declaraciones para ejecutar consultas y recuperar resultados, obtener metadatos sobre la base de datos, cerrar conexi\u00f3n, etc.Los objetos Connection mantendr\u00e1n la capacidad de comunicarse con el sistema gestor mientras permanezcan abiertos. Esto es, desde que se crean hasta que se cierran utilizando el m\u00e9todo close. El objeto Connection est\u00e1 totalmente vinculado a una fuente de datos, por eso en pedir la conexi\u00f3n hay que especificar de qu\u00e9 fuente se trata siguiendo el protocolo JDBC e indicando la url de los datos, y en su caso el usuario y password. Example \ud83e\udd13 jdbc : bbdd :// server : port / schema jdbc :postgresql://localhost:5432/severo La url seguir\u00e1 el protocolo JDBC, comenzar\u00e1 siempre por la palabra jdbc seguida de dos puntos. El resto depender\u00e1 del tipo de controlador utilizado, del host donde se aloje el SGBD, del puerto que este use para escuchar las peticiones y del nombre de la base de datos o esquema con el que queremos trabajar. import java.sql.Connection ; import java.sql.DriverManager ; import java.sql.SQLException ; ... public static void main ( String [] args ) { String user = \"patricia\" ; String password = \"marti\" ; String url = \"jdbc:mysql://localhost/severo_ad\" ; try ( final Connection connection = DriverManager . getConnection ( url , user , password )) { System . out . println ( connection . getCatalog ()); } catch ( SQLException ex ) { System . out . println ( \"SQLException: \" + ex . getMessage ()); System . out . println ( \"SQLState: \" + ex . getSQLState ()); System . out . println ( \"VendorError: \" + ex . getErrorCode ()); } }","title":"Establecimiento y cierre de conexi\u00f3n"},{"location":"ud2/23conectores/#operaciones-basicas","text":"El API JDBC distingue dos tipos de consultas: Consultas : SELECT Actualizaciones : INSERT, UPDATE, DELETE, sentencias DDL.","title":"Operaciones b\u00e1sicas"},{"location":"ud2/23conectores/#interfaces-y-clases-principales-de-jdbc","text":"Statement y PreparedStatement : estas interfaces se utilizan para ejecutar consultas SQL est\u00e1ticas y consultas SQL parametrizadas, respectivamente. Statement es la superinterfaz de la interfaz PreparedStatement , que se utiliza para consultas parametrizadas. Sus m\u00e9todos com\u00fanmente utilizados son: boolean execute(String sql) : ejecuta una sentencia SQL general. Devuelve verdadero si la consulta devuelve un ResultSet , falso si la consulta devuelve un recuento de actualizaciones o no devuelve nada. Este m\u00e9todo solo se puede utilizar con una sentencia. int executeUpdate(String sql) : ejecuta una sentencia INSERT, UPDATE o DELETE y devuelve un conteo actualizado que indica el n\u00famero de filas afectadas (por ejemplo, 1 fila insertada, 2 filas actualizadas o 0 filas afectadas). Statement stmt = con . createStatement (); String q1 = \"insert into userid values (1,root,Patricia Marti)\" ; int x = stmt . executeUpdate ( q1 ); ResultSet executeQuery(String sql) : ejecuta una sentencia SELECT y devuelve un objeto ResultSet que contiene los resultados devueltos por la consulta. Statement stmt = con . createStatement (); String q1 = \"select * from userid where id = '\" + id + \"' AND pwd = '\" + pwd + \"'\" ; ResultSet rs = stmt . executeQuery ( q1 ); ResultSet : contiene los datos de la tabla devueltos por una consulta SELECT. Este objeto se usa para iterar sobre las filas en el conjunto de resultados usando el m\u00e9todo next() . \ud83e\udd13 SQLException: Es la excepci\u00f3n que se lanza cuando hay alg\u00fan problema entre la base de datos y el programa Java JDBC. Contiene los siguientes m\u00e9todos: .getMessage() , nos indica la descripci\u00f3n del mensaje de error. .getSQLState() , devuelve un c\u00f3digo SQL est\u00e1ndar definido por ISO/ANSI y el Open Group que identifica de forma un\u00edvoca el error que se ha producido. SQLState Official .getErrorCode( ), es un c\u00f3digo de error que lanza la base de datos. En este caso el c\u00f3digo de error es diferente dependiendo del proveedor de base de datos que estemos utilizando. .getCause() , nos devuelve una lista de objetos que han provocado el error. .getNextException() , devuelve la cadena de excepciones que se ha producido. De tal manera que podemos navegar sobre ella para ver en detalle de esas excepciones.","title":"Interfaces y clases principales de JDBC"},{"location":"ud2/23conectores/#liberacion-de-recursos","text":"Danger \ud83d\ude2c Se debe cerrar expl\u00edcitamente Statement , ResultSet y Connection cuando ya no se necesiten, a menos que se declaren con un try-catch-with-resources. Las instancias de Connection y las de Statement almacenan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras permanecen activas mantienen en el SGBD un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. El cierre de estos objetos permite liberar recursos tanto del cliente como del servidor. Aunque se haya cerrado la conexi\u00f3n, los objetos Statements que no se hab\u00edan cerrado expresamente permanecen m\u00e1s tiempo en memoria que los objetos cerrados previamente, ya que el garbage collector de Java deber\u00e1 hacer m\u00e1s comprobaciones para asegurar que ya no dispone de dependencias ni internas ni externas y se puede eliminar. Es por ello que se recomienda proceder siempre a cerrarlo manualmente utilizando el m\u00e9todo close() . El cierre de los objetos Statement asegura la liberaci\u00f3n inmediata de los recursos y la anulaci\u00f3n de las dependencias. Si en un mismo m\u00e9todo queremos cerrar un objeto Statement y Connection , lo haremos siguiendo estos pasos: Cerramos el Statement y la instancia Connection . Failure \ud83d\ude35\u200d\ud83d\udcab Si lo hici\u00e9ramos al rev\u00e9s, cuando intent\u00e1ramos cerrar el Statement nos saltar\u00eda una excepci\u00f3n de tipo SQLException , ya que el cierre de la conexi\u00f3n lo habr\u00eda dejado inaccesible. Cuando se cierra un objeto Statement , su objeto ResultSet actual, si existe, tambi\u00e9n se cierra. Pero eso no ocurre cuando se cierra la conexi\u00f3n. try ( Connection connection = dataSource . getConnection (); Statement statement = connection . createStatement ()) { try ( ResultSet resultSet = statement . executeQuery ( \"SELECT * FROM ....\" )) { // Do actions. } }","title":"Liberaci\u00f3n de recursos"},{"location":"ud2/24transactions/","text":"\u26a1Transacciones En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es cualquier conjunto de sentencias SQL que se ejecutan como si de una sola se tratara. La idea principal es poder ejecutar varias sentencias, que est\u00e1n relacionadas de alguna manera, de forma que, si cualquiera de ellas fallara o produjera un error, no se ejecutara ninguna m\u00e1s e incluso se deshicieran todos los cambios que hayan podido efectuar las que ya se hab\u00edan ejecutado dentro de la misma transacci\u00f3n, por eso decimos, que las transacciones se consideran unitarias . Es decir, las operaciones que componen la transacci\u00f3n se deben ejecutar todas o ninguna. Esto ayuda a preservarla integridad de los datos e impide posibles desfases entre clientes y servidor. De entrada, cualquier sentencia SQL se considera una transacci\u00f3n en s\u00ed misma y si se produce un error durante su ejecuci\u00f3n se anular\u00e1n todas las operaciones simples derivadas de la ejecuci\u00f3n de la sentencia. Una transacci\u00f3n tiene dos finales posibles, COMMIT o ROLLBACK . Si se finaliza correctamente y sin problemas se har\u00e1 con COMMIT , con lo que los cambios se realizan en la base de datos, y si por alguna raz\u00f3n hay un fallo, se deshacen los cambios efectuados hasta ese momento, con la ejecuci\u00f3n de ROLLBACK . Por defecto, al menos en MySQL , en una conexi\u00f3n trabajamos en modo autocommit con valor true . Eso significa que cada consulta es una transacci\u00f3n en la base de datos, es decir, que los cambios se aplicar\u00e1n en la base de datos una vez que la query se haya ejecutado correctamente. Por tanto, si queremos definir una transacci\u00f3n de varias operaciones, estableceremos el modo autocommit a false con el m\u00e9todo setAutoCommit de la clase Connection . En modo no autocommit las transacciones quedan definidas por las ejecuciones de los m\u00e9todos commit y rollback . Una transacci\u00f3n abarca desde el \u00faltimo commit o rollback hasta el siguiente commit. Los m\u00e9todos commit o rollback forman parte de la clase Connection . En la siguiente porci\u00f3n de c\u00f3digo, se puede ver un ejemplo sencillo de c\u00f3mo se puede utilizar commit y rollback : tras las operaciones se realiza el commit , y si ocurre una excepci\u00f3n, al capturarla realizar\u00edamos el rollback . public static void execute ( String [] sqlqueries ) throws SQLException { boolean autocommit = true ; String user = \"patricia\" ; String password = \"marti\" ; String url = \"jdbc:mysql://localhost/severo_ad\" ; try ( final Connection con = DriverManager . getConnection ( url , user , password )) { try ( Statement stmt = con . createStatement ()) { autocommit = con . getAutoCommit (); con . setAutoCommit ( false ); for ( String query : sqlqueries ) { stmt . executeUpdate ( query ); } con . commit (); con . setAutoCommit ( autocommit ); } catch ( SQLException ex ) { con . rollback (); throw ex ; } } }","title":"2.4.- Transacciones"},{"location":"ud2/24transactions/#transacciones","text":"En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es cualquier conjunto de sentencias SQL que se ejecutan como si de una sola se tratara. La idea principal es poder ejecutar varias sentencias, que est\u00e1n relacionadas de alguna manera, de forma que, si cualquiera de ellas fallara o produjera un error, no se ejecutara ninguna m\u00e1s e incluso se deshicieran todos los cambios que hayan podido efectuar las que ya se hab\u00edan ejecutado dentro de la misma transacci\u00f3n, por eso decimos, que las transacciones se consideran unitarias . Es decir, las operaciones que componen la transacci\u00f3n se deben ejecutar todas o ninguna. Esto ayuda a preservarla integridad de los datos e impide posibles desfases entre clientes y servidor. De entrada, cualquier sentencia SQL se considera una transacci\u00f3n en s\u00ed misma y si se produce un error durante su ejecuci\u00f3n se anular\u00e1n todas las operaciones simples derivadas de la ejecuci\u00f3n de la sentencia. Una transacci\u00f3n tiene dos finales posibles, COMMIT o ROLLBACK . Si se finaliza correctamente y sin problemas se har\u00e1 con COMMIT , con lo que los cambios se realizan en la base de datos, y si por alguna raz\u00f3n hay un fallo, se deshacen los cambios efectuados hasta ese momento, con la ejecuci\u00f3n de ROLLBACK . Por defecto, al menos en MySQL , en una conexi\u00f3n trabajamos en modo autocommit con valor true . Eso significa que cada consulta es una transacci\u00f3n en la base de datos, es decir, que los cambios se aplicar\u00e1n en la base de datos una vez que la query se haya ejecutado correctamente. Por tanto, si queremos definir una transacci\u00f3n de varias operaciones, estableceremos el modo autocommit a false con el m\u00e9todo setAutoCommit de la clase Connection . En modo no autocommit las transacciones quedan definidas por las ejecuciones de los m\u00e9todos commit y rollback . Una transacci\u00f3n abarca desde el \u00faltimo commit o rollback hasta el siguiente commit. Los m\u00e9todos commit o rollback forman parte de la clase Connection . En la siguiente porci\u00f3n de c\u00f3digo, se puede ver un ejemplo sencillo de c\u00f3mo se puede utilizar commit y rollback : tras las operaciones se realiza el commit , y si ocurre una excepci\u00f3n, al capturarla realizar\u00edamos el rollback . public static void execute ( String [] sqlqueries ) throws SQLException { boolean autocommit = true ; String user = \"patricia\" ; String password = \"marti\" ; String url = \"jdbc:mysql://localhost/severo_ad\" ; try ( final Connection con = DriverManager . getConnection ( url , user , password )) { try ( Statement stmt = con . createStatement ()) { autocommit = con . getAutoCommit (); con . setAutoCommit ( false ); for ( String query : sqlqueries ) { stmt . executeUpdate ( query ); } con . commit (); con . setAutoCommit ( autocommit ); } catch ( SQLException ex ) { con . rollback (); throw ex ; } } }","title":"\u26a1Transacciones"},{"location":"ud2/25procedures/","text":"\ud83d\udcd8Procedimientos y funciones almacenadas Un procedimiento almacenado es un procedimiento o subprograma que est\u00e1 almacenado en la base de datos. Muchos sistemas gestores de bases de datos los soportan, por ejemplo: MySQL, Oracle, etc. Adem\u00e1s, estos procedimientos suelen ser de dos clases: Procedimientos almacenados. Funciones, las cuales devuelven un valor que se puede emplear en otras sentencias SQL. \ud83d\udcc1 Procedimientos almacenados La ejecuci\u00f3n de procedimientos almacenados sigue la misma estructura que cualquiera de las sentencias SQL de los ejemplos anteriores, con la excepci\u00f3n de que usaremos la clase CallableStatement para representar al procedimiento y el m\u00e9todo execute() de la misma para ejecutarlo. CallableStatement extiende de PreparedStatement . Procedure.java CallableStatement stmt = con . prepareCall ( \"{call insertUser(?,?)}\" ); stmt . setInt ( 1 , 1011 ); stmt . setString ( 2 , \"Patricia\" ); stmt . execute (); \ud83d\udcc1 Funciones En el caso de las funciones almacenadas, para su ejecuci\u00f3n seguiremos la misma estructura que hemos visto en el caso de las consultas SQL para el caso concreto de las funciones agregadas, ya que nuestras funciones nos devolver\u00e1n siempre un solo valor (o null en el caso de que no devuelvan nada). Function.sql create or replace function sum4 ( n1 in number , n2 in number ) return number is temp number ( 8 ); begin temp : = n1 + n2 ; return temp ; end ; / Sum.java CallableStatement stmt = con . prepareCall ( \"{?= call sum4(?,?)}\" ); stmt . setInt ( 2 , 10 ); stmt . setInt ( 3 , 43 ); stmt . registerOutParameter ( 1 , Types . INTEGER ); //valor de retorno stmt . execute (); System . out . println ( stmt . getInt ( 1 ));","title":"2.5.- Procedimientos y funciones almacenadas"},{"location":"ud2/25procedures/#procedimientos-y-funciones-almacenadas","text":"Un procedimiento almacenado es un procedimiento o subprograma que est\u00e1 almacenado en la base de datos. Muchos sistemas gestores de bases de datos los soportan, por ejemplo: MySQL, Oracle, etc. Adem\u00e1s, estos procedimientos suelen ser de dos clases: Procedimientos almacenados. Funciones, las cuales devuelven un valor que se puede emplear en otras sentencias SQL.","title":"\ud83d\udcd8Procedimientos y funciones almacenadas"},{"location":"ud2/25procedures/#procedimientos-almacenados","text":"La ejecuci\u00f3n de procedimientos almacenados sigue la misma estructura que cualquiera de las sentencias SQL de los ejemplos anteriores, con la excepci\u00f3n de que usaremos la clase CallableStatement para representar al procedimiento y el m\u00e9todo execute() de la misma para ejecutarlo. CallableStatement extiende de PreparedStatement . Procedure.java CallableStatement stmt = con . prepareCall ( \"{call insertUser(?,?)}\" ); stmt . setInt ( 1 , 1011 ); stmt . setString ( 2 , \"Patricia\" ); stmt . execute ();","title":"\ud83d\udcc1 Procedimientos almacenados"},{"location":"ud2/25procedures/#funciones","text":"En el caso de las funciones almacenadas, para su ejecuci\u00f3n seguiremos la misma estructura que hemos visto en el caso de las consultas SQL para el caso concreto de las funciones agregadas, ya que nuestras funciones nos devolver\u00e1n siempre un solo valor (o null en el caso de que no devuelvan nada). Function.sql create or replace function sum4 ( n1 in number , n2 in number ) return number is temp number ( 8 ); begin temp : = n1 + n2 ; return temp ; end ; / Sum.java CallableStatement stmt = con . prepareCall ( \"{?= call sum4(?,?)}\" ); stmt . setInt ( 2 , 10 ); stmt . setInt ( 3 , 43 ); stmt . registerOutParameter ( 1 , Types . INTEGER ); //valor de retorno stmt . execute (); System . out . println ( stmt . getInt ( 1 ));","title":"\ud83d\udcc1 Funciones"},{"location":"ud2/26rendimiento/","text":"\ud83e\udde0 Mejora del rendimiento Otro aspecto importante que mide la calidad de las aplicaciones es la eficiencia con la que se consigue comunicar con el SGBD. Para optimizar la conexi\u00f3n es importante reconocer qu\u00e9 procesos pueden actuar de cuello de botella y bajo qu\u00e9 circunstancias o qu\u00e9 otras agilizan las respuestas de los SGBD. En primer lugar, analizaremos la petici\u00f3n de conexi\u00f3n a un SGBD porque se trata de un proceso costoso pero inevitable que hay que considerar. En segundo lugar, estudiaremos las sentencias predefinidas ( PreparedStatement ) , porqu\u00e9 su uso facilita la creaci\u00f3n de datos clave e \u00edndices temporales de modo que sea posible anticiparse a la demanda o disponer de los datos de forma mucho m\u00e1s r\u00e1pida. \ud83e\ude90 Ciclo de vida de una conexi\u00f3n El establecimiento de una conexi\u00f3n es un procedimiento bastante lento, tanto en la parte cliente como la parte servidor. En la parte cliente, DriverManager debe descubrir el controlador correcto de entre todos los que tenga que gestionar. La mayor\u00eda de veces las aplicaciones trabajar\u00e1n s\u00f3lo con un \u00fanico controlador, pero hay que tener en cuenta que DriverManager no conoce a priori qu\u00e9 URL de conexi\u00f3n corresponde a cada controlador, y para averiguarlo env\u00eda una petici\u00f3n de conexi\u00f3n a cada controlador que tenga registrado, el controlador que no le devuelve error ser\u00e1 el correcto. En el lado servidor, se crear\u00e1 un contexto espec\u00edfico y se habilitar\u00e1n un conjunto de recursos para cada cliente conectado. Es decir, que durante la petici\u00f3n de conexi\u00f3n del SGBD debe gastar un tiempo considerable antes de no dejar operativa la comunicaci\u00f3n cliente-servidor. Este elevado gasto de tiempo concentrado en el momento de la petici\u00f3n de conexi\u00f3n nos hace plantear si podemos considerar ineficiente abrir y cerrar la conexi\u00f3n cada vez que tengamos que ejecutar una sentencia SQL, como hemos hecho hasta ahora. Desafortunadamente no hay una \u00fanica respuesta, sino que depende de la frecuencia de uso de la conexi\u00f3n y el n\u00famero de conexiones contra un mismo SGBD coexistiendo al mismo tiempo. Como en todo, se trata de encontrar el punto de equilibrio entre la cantidad de recursos empleados por conexi\u00f3n y la rentabilidad que se saca en mantenerlas abiertas . Si el n\u00famero de clientes, y por tanto de conexiones, es bajo y la frecuencia de uso es alta, ser\u00e1 preferible mantener las conexiones abiertas mucho tiempo. Por el contrario, si el n\u00famero de conexiones es muy alto y el uso infrecuente, lo que ser\u00e1 preferible ser\u00e1 abrir y cerrar la conexi\u00f3n cada vez que se necesite. Mientras tanto, habr\u00e1 una multitud de casos en que la soluci\u00f3n consistir\u00e1 en mantener las conexiones abiertas, pero no permanentemente. Se puede dar un tiempo de vida a cada conexi\u00f3n , o bien cerrarlas despu\u00e9s de restar inactiva una cantidad determinada de tiempo, o se puede usar el criterio de mantener un n\u00famero m\u00e1ximo de conexiones abiertas , cerrando las m\u00e1s antiguas o las m\u00e1s inactivas cuando se sobrepase el l\u00edmite. \ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota Por otra parte, hay que tener en cuenta tambi\u00e9n que una misma aplicaci\u00f3n puede trabajar con varias conexiones simult\u00e1neamente para incrementar la eficiencia. Cada conexi\u00f3n abre un hilo de ejecuci\u00f3n independiente, por lo que es posible el env\u00edo simult\u00e1neo de peticiones. \u26a1 Sentencias predefinidas PreparedStatement presenta ventajas sobre su antecesor Statement cuando tengamos que trabajar con sentencias que haya que ejecutar varias veces. \u2b50Statement\u2b50 \u2b50PreparedStatement\u2b50 Statement is usually parsed and executed each time. PreparedStatement is parsed once and executed with different parameters repeatedly. A statement is a static Sql statement.It does not support parameters. A PreparedStatement is a dynamic Sql statement.It does supports parameters. It is slower because every time the statements get parsed and executed. This is faster because this is precompiled once and gets executed with different parameters. Statement verifies metadata against database everytime. PreparedStatement verifies metadata against database only once. If we want to execute sql statement once it is recommended to use statement. If we want to execute sql statements repeatedly it is recommended to use PreparedStatement. La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda el SGBD ser\u00e1 compilada antes de ser ejecutada. Usando un objeto Statement , cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda executeUpdate o bien v\u00eda executeQuery, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres. En cambio, al PreparedStament la sentencia nunca var\u00eda y por lo tanto se puede compilar y almacenar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarla. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n. La parametrizaci\u00f3n, adem\u00e1s, ayuda a crear sentencias muy gen\u00e9ricas que se puedan reutilizar f\u00e1cilmente. En algunos sistemas gestores, adem\u00e1s, usar PreparedStatement puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema almacene las respuestas en la cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida. Important \ud83e\udd14 The use of a Statement in JDBC should be 100% localized to being used for DDL (ALTER, CREATE, GRANT, etc) as these are the only statement types that cannot accept BIND VARIABLES. PreparedStatements or CallableStatements should be used for EVERY OTHER type of statement (DML, Queries). As these are the statement types that accept bind variables. This is a fact, a rule, a law -- use prepared statements EVERYWHERE. Use STATEMENTS almost no where . \ud83d\udcdd Ejemplos de problemas con Statement 1. Statement acepta cadenas como consultas SQL. Por lo tanto, el c\u00f3digo se vuelve menos legible cuando concatenamos cadenas SQL: public void insert ( PersonEntity personEntity ) { String query = \"INSERT INTO persons(id, name, age, email) VALUES(\" + personEntity . getId () + \", '\" + personEntity . getName () + \", '\" + personEntity . getAge () + \", '\" + personEntity . getEmail () + \"')\" ; Statement statement = connection . createStatement (); statement . executeUpdate ( query ); } 2. Es vulnerable a la inyecci\u00f3n de SQL . public void check ( String name ) { String query = \"SELECT * FROM users WHERE name = '\" + name + \"';\" ; Statement statement = connection . createStatement (); statement . executeUpdate ( query ); } Si un usuario malintencionado escribe como nombre de usuario a consultar: Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '% Se generar\u00eda la siguiente consulta SQL, (el color verde es lo que pretende el programador, el azul es el dato, y el rojo, el c\u00f3digo SQL inyectado): En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.'","title":"2.6.- Mejora del rendimiento"},{"location":"ud2/26rendimiento/#mejora-del-rendimiento","text":"Otro aspecto importante que mide la calidad de las aplicaciones es la eficiencia con la que se consigue comunicar con el SGBD. Para optimizar la conexi\u00f3n es importante reconocer qu\u00e9 procesos pueden actuar de cuello de botella y bajo qu\u00e9 circunstancias o qu\u00e9 otras agilizan las respuestas de los SGBD. En primer lugar, analizaremos la petici\u00f3n de conexi\u00f3n a un SGBD porque se trata de un proceso costoso pero inevitable que hay que considerar. En segundo lugar, estudiaremos las sentencias predefinidas ( PreparedStatement ) , porqu\u00e9 su uso facilita la creaci\u00f3n de datos clave e \u00edndices temporales de modo que sea posible anticiparse a la demanda o disponer de los datos de forma mucho m\u00e1s r\u00e1pida.","title":"\ud83e\udde0 Mejora del rendimiento"},{"location":"ud2/26rendimiento/#ciclo-de-vida-de-una-conexion","text":"El establecimiento de una conexi\u00f3n es un procedimiento bastante lento, tanto en la parte cliente como la parte servidor. En la parte cliente, DriverManager debe descubrir el controlador correcto de entre todos los que tenga que gestionar. La mayor\u00eda de veces las aplicaciones trabajar\u00e1n s\u00f3lo con un \u00fanico controlador, pero hay que tener en cuenta que DriverManager no conoce a priori qu\u00e9 URL de conexi\u00f3n corresponde a cada controlador, y para averiguarlo env\u00eda una petici\u00f3n de conexi\u00f3n a cada controlador que tenga registrado, el controlador que no le devuelve error ser\u00e1 el correcto. En el lado servidor, se crear\u00e1 un contexto espec\u00edfico y se habilitar\u00e1n un conjunto de recursos para cada cliente conectado. Es decir, que durante la petici\u00f3n de conexi\u00f3n del SGBD debe gastar un tiempo considerable antes de no dejar operativa la comunicaci\u00f3n cliente-servidor. Este elevado gasto de tiempo concentrado en el momento de la petici\u00f3n de conexi\u00f3n nos hace plantear si podemos considerar ineficiente abrir y cerrar la conexi\u00f3n cada vez que tengamos que ejecutar una sentencia SQL, como hemos hecho hasta ahora. Desafortunadamente no hay una \u00fanica respuesta, sino que depende de la frecuencia de uso de la conexi\u00f3n y el n\u00famero de conexiones contra un mismo SGBD coexistiendo al mismo tiempo. Como en todo, se trata de encontrar el punto de equilibrio entre la cantidad de recursos empleados por conexi\u00f3n y la rentabilidad que se saca en mantenerlas abiertas . Si el n\u00famero de clientes, y por tanto de conexiones, es bajo y la frecuencia de uso es alta, ser\u00e1 preferible mantener las conexiones abiertas mucho tiempo. Por el contrario, si el n\u00famero de conexiones es muy alto y el uso infrecuente, lo que ser\u00e1 preferible ser\u00e1 abrir y cerrar la conexi\u00f3n cada vez que se necesite. Mientras tanto, habr\u00e1 una multitud de casos en que la soluci\u00f3n consistir\u00e1 en mantener las conexiones abiertas, pero no permanentemente. Se puede dar un tiempo de vida a cada conexi\u00f3n , o bien cerrarlas despu\u00e9s de restar inactiva una cantidad determinada de tiempo, o se puede usar el criterio de mantener un n\u00famero m\u00e1ximo de conexiones abiertas , cerrando las m\u00e1s antiguas o las m\u00e1s inactivas cuando se sobrepase el l\u00edmite. \ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota Por otra parte, hay que tener en cuenta tambi\u00e9n que una misma aplicaci\u00f3n puede trabajar con varias conexiones simult\u00e1neamente para incrementar la eficiencia. Cada conexi\u00f3n abre un hilo de ejecuci\u00f3n independiente, por lo que es posible el env\u00edo simult\u00e1neo de peticiones.","title":"\ud83e\ude90 Ciclo de vida de una conexi\u00f3n"},{"location":"ud2/26rendimiento/#sentencias-predefinidas","text":"PreparedStatement presenta ventajas sobre su antecesor Statement cuando tengamos que trabajar con sentencias que haya que ejecutar varias veces. \u2b50Statement\u2b50 \u2b50PreparedStatement\u2b50 Statement is usually parsed and executed each time. PreparedStatement is parsed once and executed with different parameters repeatedly. A statement is a static Sql statement.It does not support parameters. A PreparedStatement is a dynamic Sql statement.It does supports parameters. It is slower because every time the statements get parsed and executed. This is faster because this is precompiled once and gets executed with different parameters. Statement verifies metadata against database everytime. PreparedStatement verifies metadata against database only once. If we want to execute sql statement once it is recommended to use statement. If we want to execute sql statements repeatedly it is recommended to use PreparedStatement. La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda el SGBD ser\u00e1 compilada antes de ser ejecutada. Usando un objeto Statement , cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda executeUpdate o bien v\u00eda executeQuery, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres. En cambio, al PreparedStament la sentencia nunca var\u00eda y por lo tanto se puede compilar y almacenar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarla. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n. La parametrizaci\u00f3n, adem\u00e1s, ayuda a crear sentencias muy gen\u00e9ricas que se puedan reutilizar f\u00e1cilmente. En algunos sistemas gestores, adem\u00e1s, usar PreparedStatement puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema almacene las respuestas en la cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida. Important \ud83e\udd14 The use of a Statement in JDBC should be 100% localized to being used for DDL (ALTER, CREATE, GRANT, etc) as these are the only statement types that cannot accept BIND VARIABLES. PreparedStatements or CallableStatements should be used for EVERY OTHER type of statement (DML, Queries). As these are the statement types that accept bind variables. This is a fact, a rule, a law -- use prepared statements EVERYWHERE. Use STATEMENTS almost no where .","title":"\u26a1 Sentencias predefinidas"},{"location":"ud2/26rendimiento/#ejemplos-de-problemas-con-statement","text":"1. Statement acepta cadenas como consultas SQL. Por lo tanto, el c\u00f3digo se vuelve menos legible cuando concatenamos cadenas SQL: public void insert ( PersonEntity personEntity ) { String query = \"INSERT INTO persons(id, name, age, email) VALUES(\" + personEntity . getId () + \", '\" + personEntity . getName () + \", '\" + personEntity . getAge () + \", '\" + personEntity . getEmail () + \"')\" ; Statement statement = connection . createStatement (); statement . executeUpdate ( query ); } 2. Es vulnerable a la inyecci\u00f3n de SQL . public void check ( String name ) { String query = \"SELECT * FROM users WHERE name = '\" + name + \"';\" ; Statement statement = connection . createStatement (); statement . executeUpdate ( query ); } Si un usuario malintencionado escribe como nombre de usuario a consultar: Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '% Se generar\u00eda la siguiente consulta SQL, (el color verde es lo que pretende el programador, el azul es el dato, y el rojo, el c\u00f3digo SQL inyectado): En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.'","title":"\ud83d\udcdd Ejemplos de problemas con Statement"},{"location":"ud2/27projectstructure/","text":"\ud83e\udded Estructura de un proyecto con JDBC Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador) . En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes: 1\ufe0f\u20e3 - Creando la BBDD Lo primero que tendremos que hacer asegurarnos de que tenemos el servidor de base de datos instalado y la base de datos creada con las tablas que necesitemos para nuestra aplicaci\u00f3n. Creamos tambi\u00e9n la tabla login con la que vamos a trabajar en los ejemplos: CREATE TABLE ` login ` ( ` id ` int NOT NULL AUTO_INCREMENT , ` user_name ` varchar ( 50 ) NOT NULL , ` password ` varchar ( 255 ) NOT NULL , ` created_at ` datetime DEFAULT CURRENT_TIMESTAMP , PRIMARY KEY ( ` id ` ), UNIQUE KEY ` user_name ` ( ` user_name ` ) ); 2\ufe0f\u20e3 - Clase Connection Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, implementaremos la clase de conexi\u00f3n a la base de datos utilizando el patr\u00f3n singleton. Esta clase estar\u00e1 ubicada dentro del paquete util . Ejemplo de conexi\u00f3n a la BBDD usando Singleton: DatabaseConnection.java public class DatabaseConnection { private static Connection connection = null ; private DatabaseConnection () {} static { String url = \"jdbc:mysql://localhost/severo\" ; String user = \"patricia\" ; String password = \"marti\" ; try { connection = DriverManager . getConnection ( url , user , password ); } catch ( SQLException e ) { e . printStackTrace (); } } public static Connection getConnection () { return connection ; } public static void close () throws SQLException { connection . close (); } } 3\ufe0f\u20e3 - Creando el modelo El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio . Para el ejemplo, el modelo de Login debe contener los atributos que contiene la tabla login como variables de la clase Normalmente los modelos de la clase se encuentran en un paquete llamado model . Login.java public class Login { private int id ; private String username ; private String password ; private LocalDateTime createdAt ; //constructors //getters y setters @Override public String toString () { return \"Login{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", createdAt=\" + createdAt + '}' ; } } 4\ufe0f\u20e3 - Clases para la manipulaci\u00f3n de la base de datos Dentro del paquete mysql a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla login. LoginAccessDB.java public class LoginAccessDB { private static Connection con = DatabaseConnection . getConnection (); public List < Login > getLogins () throws SQLException { String sql = \"SELECT * FROM login\" ; try ( Statement statement = con . createStatement ()) { List < Login > lg = new ArrayList <> (); ResultSet resultSet = statement . executeQuery ( sql ); while ( resultSet . next ()) { Login login = new Login (); login . setId ( resultSet . getInt ( 1 )); login . setUsername ( resultSet . getString ( \"username\" )); login . setPassword ( resultSet . getString ( \"password\" )); login . setCreatedAt ( resultSet . getTimestamp ( \"created_at\" ). toLocalDateTime ()); lg . add ( login ); } return lg ; } } } \ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota M\u00e1s adelante veremos que hay clases que siguen el patr\u00f3n DAO que se encargan del acceso a base de datos. 5\ufe0f\u20e3 - Test Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro main o punto de entrada al programa. MainApp.java public class MainApp { public static void main ( String [] args ) { LoginAccessDB loginHandleDB = new LoginAccessDB (); try { for ( Login l : loginHandleDB . getLogins ()) { System . out . println ( l ); } } catch ( SQLException ex ) { System . out . println ( \"SQLException: \" + ex . getMessage ()); System . out . println ( \"SQLState: \" + ex . getSQLState ()); System . out . println ( \"VendorError: \" + ex . getErrorCode ()); } } } 6\ufe0f\u20e3 - Fichero README Readme : el propio nombre, l\u00e9eme , indica su prop\u00f3sito: ser le\u00eddo . El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto , por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta. Consejo El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas. \u00bfQu\u00e9 suelen incluir los ficheros README? Suelen incluir informaci\u00f3n sobre: Una descripci\u00f3n general del sistema o proyecto. El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado. Los requisitos del entorno de desarrollo para la integraci\u00f3n. Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n. Bugs conocidos y posibles correcciones de errores. Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha. Informaci\u00f3n sobre derechos de autor y licencias. C\u00f3mo escribir un fichero README El contenido del fichero README debe estar en ingl\u00e9s. C\u00f3mo crear un fichero README Exportar la BBDD de MySQL En MySQL workbench seleccionamos Server --> Data Export Selecciono el esquema de BBDD que quiero exportar y hago click en Start export Workbench me muestra d\u00f3nde se ha generado el fichero:","title":"2.7.- Estructura de los proyectos"},{"location":"ud2/27projectstructure/#estructura-de-un-proyecto-con-jdbc","text":"Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador) . En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes:","title":"\ud83e\udded Estructura de un proyecto con JDBC"},{"location":"ud2/27projectstructure/#1-creando-la-bbdd","text":"Lo primero que tendremos que hacer asegurarnos de que tenemos el servidor de base de datos instalado y la base de datos creada con las tablas que necesitemos para nuestra aplicaci\u00f3n. Creamos tambi\u00e9n la tabla login con la que vamos a trabajar en los ejemplos: CREATE TABLE ` login ` ( ` id ` int NOT NULL AUTO_INCREMENT , ` user_name ` varchar ( 50 ) NOT NULL , ` password ` varchar ( 255 ) NOT NULL , ` created_at ` datetime DEFAULT CURRENT_TIMESTAMP , PRIMARY KEY ( ` id ` ), UNIQUE KEY ` user_name ` ( ` user_name ` ) );","title":"1\ufe0f\u20e3 - Creando la BBDD"},{"location":"ud2/27projectstructure/#2-clase-connection","text":"Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, implementaremos la clase de conexi\u00f3n a la base de datos utilizando el patr\u00f3n singleton. Esta clase estar\u00e1 ubicada dentro del paquete util . Ejemplo de conexi\u00f3n a la BBDD usando Singleton: DatabaseConnection.java public class DatabaseConnection { private static Connection connection = null ; private DatabaseConnection () {} static { String url = \"jdbc:mysql://localhost/severo\" ; String user = \"patricia\" ; String password = \"marti\" ; try { connection = DriverManager . getConnection ( url , user , password ); } catch ( SQLException e ) { e . printStackTrace (); } } public static Connection getConnection () { return connection ; } public static void close () throws SQLException { connection . close (); } }","title":"2\ufe0f\u20e3 - Clase Connection"},{"location":"ud2/27projectstructure/#3-creando-el-modelo","text":"El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio . Para el ejemplo, el modelo de Login debe contener los atributos que contiene la tabla login como variables de la clase Normalmente los modelos de la clase se encuentran en un paquete llamado model . Login.java public class Login { private int id ; private String username ; private String password ; private LocalDateTime createdAt ; //constructors //getters y setters @Override public String toString () { return \"Login{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", createdAt=\" + createdAt + '}' ; } }","title":"3\ufe0f\u20e3 - Creando el modelo"},{"location":"ud2/27projectstructure/#4-clases-para-la-manipulacion-de-la-base-de-datos","text":"Dentro del paquete mysql a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla login. LoginAccessDB.java public class LoginAccessDB { private static Connection con = DatabaseConnection . getConnection (); public List < Login > getLogins () throws SQLException { String sql = \"SELECT * FROM login\" ; try ( Statement statement = con . createStatement ()) { List < Login > lg = new ArrayList <> (); ResultSet resultSet = statement . executeQuery ( sql ); while ( resultSet . next ()) { Login login = new Login (); login . setId ( resultSet . getInt ( 1 )); login . setUsername ( resultSet . getString ( \"username\" )); login . setPassword ( resultSet . getString ( \"password\" )); login . setCreatedAt ( resultSet . getTimestamp ( \"created_at\" ). toLocalDateTime ()); lg . add ( login ); } return lg ; } } } \ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota M\u00e1s adelante veremos que hay clases que siguen el patr\u00f3n DAO que se encargan del acceso a base de datos.","title":"4\ufe0f\u20e3 - Clases para la manipulaci\u00f3n de la base de datos"},{"location":"ud2/27projectstructure/#5-test","text":"Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro main o punto de entrada al programa. MainApp.java public class MainApp { public static void main ( String [] args ) { LoginAccessDB loginHandleDB = new LoginAccessDB (); try { for ( Login l : loginHandleDB . getLogins ()) { System . out . println ( l ); } } catch ( SQLException ex ) { System . out . println ( \"SQLException: \" + ex . getMessage ()); System . out . println ( \"SQLState: \" + ex . getSQLState ()); System . out . println ( \"VendorError: \" + ex . getErrorCode ()); } } }","title":"5\ufe0f\u20e3 - Test"},{"location":"ud2/27projectstructure/#6-fichero-readme","text":"Readme : el propio nombre, l\u00e9eme , indica su prop\u00f3sito: ser le\u00eddo . El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto , por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta. Consejo El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas.","title":"6\ufe0f\u20e3 - Fichero README"},{"location":"ud2/27projectstructure/#que-suelen-incluir-los-ficheros-readme","text":"Suelen incluir informaci\u00f3n sobre: Una descripci\u00f3n general del sistema o proyecto. El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado. Los requisitos del entorno de desarrollo para la integraci\u00f3n. Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n. Bugs conocidos y posibles correcciones de errores. Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha. Informaci\u00f3n sobre derechos de autor y licencias.","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?"},{"location":"ud2/27projectstructure/#como-escribir-un-fichero-readme","text":"El contenido del fichero README debe estar en ingl\u00e9s. C\u00f3mo crear un fichero README","title":"C\u00f3mo escribir un fichero README"},{"location":"ud2/27projectstructure/#exportar-la-bbdd-de-mysql","text":"En MySQL workbench seleccionamos Server --> Data Export Selecciono el esquema de BBDD que quiero exportar y hago click en Start export Workbench me muestra d\u00f3nde se ha generado el fichero:","title":"Exportar la BBDD de MySQL"},{"location":"ud3/31mapeo/","text":"\ud83d\udcbe Herramientas mapeo objeto - relacional (ORM) Problemas con JDBC Aunque JDBC nos permit\u00eda abstraer la conexi\u00f3n del driver con la base de datos correcta, todav\u00eda presenta limitaciones : N\u00famero importante de l\u00edneas de c\u00f3digo Invertir tiempo en los dos modelos relacional y orientado a objetos Cu\u00e1nto mayor crece la base de datos m\u00e1s complicado se hace el mantenimiento Manejo de conexi\u00f3n, cierre de conexi\u00f3n, etc Seguimos teniendo desfase en el mapeo objeto modelo relacional, JDBC no solventa del todo este desfase puesto que todav\u00eda tenemos que descomponer el objeto para construir la sentencia INSERT, DELETE o UPDATE que queremos utilizar. \u00bfPor qu\u00e9 necesitamos un ORM? Las herramientas ORM ( Object Relational Mapping ) intentan aprovechar la madurez y la eficiencia de las bases de datos relacionales minimizando en lo posible el desfase objeto relacional. Se trata de bibliotecas y marcos de programaci\u00f3n que definen un formato para expresar m\u00faltiples situaciones de transformaci\u00f3n entre ambos paradigmas. En cierta forma podr\u00edamos decir que implementan una base de datos orientada a objetos virtual para que aportan caracter\u00edsticas propias del paradigma OO , pero el sustrato donde se acaban almacenando los objetos es un SGBD relacional. ORM Un ORM intenta hacer todas estas tareas pesadas por nosotros. Deberemos definir la forma en la que estableceremos la correspondencia entre las clases y las tablas una s\u00f3la vez (indicando qu\u00e9 propiedad se corresponde con qu\u00e9 columna, qu\u00e9 clase con qu\u00e9 tabla, etc). Despu\u00e9s, podremos hacer cosas como utilizar POJO 's(Plain Old Java Objects) de nuestra aplicaci\u00f3n y decirle a nuestro ORM que los haga persistentes, con una instrucci\u00f3n similar a esta save(myObject) . Es decir, una herramienta ORM puede leer o escribir en la base de datos utilizando objetos directamente . Una herramienta ORM permite tomar un objeto Java y hacerlo persistente, cargar el objeto de la base de datos en memoria y hacer consultas a las tablas de la base de datos. Ventajas de ORM \u2747\ufe0f Ayudan a reducir el tiempo de desarrollo de software. La mayor\u00eda de las herramientas ORM disponibles, permiten la creaci\u00f3n del modelo a trav\u00e9s del esquema de la base de datos, es decir, el usuario crea la base de datos y la herramienta autom\u00e1ticamente lee el esquema de tablas y relaciones y crea un modelo ajustado. \u2747\ufe0f Abstracci\u00f3n de la base de datos. \u2747\ufe0f Reutilizaci\u00f3n. \u2747\ufe0f Permiten persistir objetos a trav\u00e9s de un m\u00e9todo save o persist y generar el SQL correspondiente. \u2747\ufe0f Permiten recuperar los objetos persistidos a trav\u00e9s de un m\u00e9todo load o get. \u2747\ufe0f Lenguaje propio para realizar las consultas. \u2747\ufe0f Independencia de la base de datos. \u2747\ufe0f Incentivan la portabilidad y escalabilidad de los programas de software. Desventajas de ORM \u2734\ufe0f Tiempo utilizado en el aprendizaje . Este tipo de herramientas suelen ser complejas por lo que su correcta utilizaci\u00f3n lleva un tiempo que hay que emplear en ver el funcionamiento correcto y ver todo el partido que se le puede sacar. \u2734\ufe0f Menor rendimiento (aplicaciones algo m\u00e1s lentas) . Esto es debido a que todas las consultas que se hagan sobre la base de datos, el sistema primero deber\u00e1 de transformarlas al lenguaje propio de la herramienta, luego leer los registros y por \u00faltimo crear los objetos. \u2734\ufe0f Sistemas complejos . Normalmente la utilidad de ORM desciende con la mayor complejidad del sistema relacional.","title":"3.1.- Herramientas ORM"},{"location":"ud3/31mapeo/#herramientas-mapeo-objeto-relacional-orm","text":"","title":"\ud83d\udcbe Herramientas mapeo objeto - relacional (ORM)"},{"location":"ud3/31mapeo/#problemas-con-jdbc","text":"Aunque JDBC nos permit\u00eda abstraer la conexi\u00f3n del driver con la base de datos correcta, todav\u00eda presenta limitaciones : N\u00famero importante de l\u00edneas de c\u00f3digo Invertir tiempo en los dos modelos relacional y orientado a objetos Cu\u00e1nto mayor crece la base de datos m\u00e1s complicado se hace el mantenimiento Manejo de conexi\u00f3n, cierre de conexi\u00f3n, etc Seguimos teniendo desfase en el mapeo objeto modelo relacional, JDBC no solventa del todo este desfase puesto que todav\u00eda tenemos que descomponer el objeto para construir la sentencia INSERT, DELETE o UPDATE que queremos utilizar.","title":"Problemas con JDBC"},{"location":"ud3/31mapeo/#por-que-necesitamos-un-orm","text":"Las herramientas ORM ( Object Relational Mapping ) intentan aprovechar la madurez y la eficiencia de las bases de datos relacionales minimizando en lo posible el desfase objeto relacional. Se trata de bibliotecas y marcos de programaci\u00f3n que definen un formato para expresar m\u00faltiples situaciones de transformaci\u00f3n entre ambos paradigmas. En cierta forma podr\u00edamos decir que implementan una base de datos orientada a objetos virtual para que aportan caracter\u00edsticas propias del paradigma OO , pero el sustrato donde se acaban almacenando los objetos es un SGBD relacional.","title":"\u00bfPor qu\u00e9 necesitamos un ORM?"},{"location":"ud3/31mapeo/#orm","text":"Un ORM intenta hacer todas estas tareas pesadas por nosotros. Deberemos definir la forma en la que estableceremos la correspondencia entre las clases y las tablas una s\u00f3la vez (indicando qu\u00e9 propiedad se corresponde con qu\u00e9 columna, qu\u00e9 clase con qu\u00e9 tabla, etc). Despu\u00e9s, podremos hacer cosas como utilizar POJO 's(Plain Old Java Objects) de nuestra aplicaci\u00f3n y decirle a nuestro ORM que los haga persistentes, con una instrucci\u00f3n similar a esta save(myObject) . Es decir, una herramienta ORM puede leer o escribir en la base de datos utilizando objetos directamente . Una herramienta ORM permite tomar un objeto Java y hacerlo persistente, cargar el objeto de la base de datos en memoria y hacer consultas a las tablas de la base de datos.","title":"ORM"},{"location":"ud3/31mapeo/#ventajas-de-orm","text":"\u2747\ufe0f Ayudan a reducir el tiempo de desarrollo de software. La mayor\u00eda de las herramientas ORM disponibles, permiten la creaci\u00f3n del modelo a trav\u00e9s del esquema de la base de datos, es decir, el usuario crea la base de datos y la herramienta autom\u00e1ticamente lee el esquema de tablas y relaciones y crea un modelo ajustado. \u2747\ufe0f Abstracci\u00f3n de la base de datos. \u2747\ufe0f Reutilizaci\u00f3n. \u2747\ufe0f Permiten persistir objetos a trav\u00e9s de un m\u00e9todo save o persist y generar el SQL correspondiente. \u2747\ufe0f Permiten recuperar los objetos persistidos a trav\u00e9s de un m\u00e9todo load o get. \u2747\ufe0f Lenguaje propio para realizar las consultas. \u2747\ufe0f Independencia de la base de datos. \u2747\ufe0f Incentivan la portabilidad y escalabilidad de los programas de software.","title":"Ventajas de ORM"},{"location":"ud3/31mapeo/#desventajas-de-orm","text":"\u2734\ufe0f Tiempo utilizado en el aprendizaje . Este tipo de herramientas suelen ser complejas por lo que su correcta utilizaci\u00f3n lleva un tiempo que hay que emplear en ver el funcionamiento correcto y ver todo el partido que se le puede sacar. \u2734\ufe0f Menor rendimiento (aplicaciones algo m\u00e1s lentas) . Esto es debido a que todas las consultas que se hagan sobre la base de datos, el sistema primero deber\u00e1 de transformarlas al lenguaje propio de la herramienta, luego leer los registros y por \u00faltimo crear los objetos. \u2734\ufe0f Sistemas complejos . Normalmente la utilidad de ORM desciende con la mayor complejidad del sistema relacional.","title":"Desventajas de ORM"},{"location":"ud3/32jpa/","text":"Jakarta - JPA (Java Persistence API) JPA es una especificaci\u00f3n que ofrece Java para implementar un Framework Object Relational Mapping (ORM), \u00e9sta especificaci\u00f3n indica c\u00f3mo se debe realizar la persistencia de los objetos en programas Java. F\u00edjate que se ha destacado la palabra \"especificaci\u00f3n\" porque JPA no tiene una implementaci\u00f3n concreta , sino que, existen diversas tecnolog\u00edas que implementan JPA para darle concreci\u00f3n. Persistencia en este contexto cubre tres \u00e1reas: La API en s\u00ed misma, definida en el paquete jakarta.persistence El lenguaje de consulta Java Persistence Query Language ( JPQL ). Metadatos objeto/relacional. Importante The JPA was renamed as Jakarta Persistence in 2019 and version 3.0 was released in 2020. This included the renaming of packages and properties from javax.persistence to jakarta.persistence. \u00bfC\u00f3mo funciona JPA? Dado que es una especificaci\u00f3n, JPA no proporciona clase alguna para poder trabajar con la informaci\u00f3n. Lo que hace es proveernos de una serie de interfaces que podemos utilizar para implementar la capa de persistencia de nuestra aplicaci\u00f3n , apoy\u00e1ndonos en alguna implementaci\u00f3n concreta de JPA. Es decir, en la pr\u00e1ctica significa que lo que vamos a utilizar es una biblioteca de persistencia que implemente JPA, no JPA directamente. Arquitectura \ud83d\udd05 Entidades - Entity El concepto de entidad est\u00e1 muy relacionado con los SGBD y los modelos relacionales, sobre todo en sus fases de dise\u00f1o inicial con el que se denomina modelo Entidad-Relaci\u00f3n. Para JPA, las entidades son aquellos objetos de los que se desea almacenar su estado y que acabar\u00e1n transform\u00e1ndose en tablas y relaciones . En JPA todas las entidades son persistentes , pero no todos los objetos lo son. Para hacer que un objeto sea persistente hay que calificarlo de entidad o bien debe formar parte del estado de una entidad (en forma de atributo, por ejemplo). Todas las entidades se deben poder identificar de forma \u00fanica a partir de su estado. Normalmente, ser\u00e1 suficiente con una peque\u00f1a parte de sus atributos para lograr la identificaci\u00f3n. La selecci\u00f3n de atributos que cumplan este objetivo se denominan identificadores, y en el SGBD actuar\u00e1n como clave primaria. \ud83d\udd05 EntityManagerFactory y EntityManager JPA implementa una interfaz llamada EntityManager que actuar\u00e1 de gestor de las entidades de la aplicaci\u00f3n. Sobre esta clase recae toda la funcionalidad referida a los procesos de persistencia y sincronizaci\u00f3n de las entidades. Se trata, seguramente, de la clase m\u00e1s importante de la biblioteca JPA . Un EntityManager asume toda la funcionalidad que una aplicaci\u00f3n pueda necesitar, pero \u00fanicamente a nivel local. JPA no permite instanciar los EntityManager directamente , sino que obliga a instanciarlos desde un EntityManagerFactory , el cual a su vez s\u00f3lo podr\u00e1 ser instanciado por la clase Persistence . Por consiguiente , el EntityManager ser\u00e1 el encargado de realizar todas las operaciones de tipo CRUD ( insertar , borrar ,seleccionar y actualizar etc) sobre las entidades. La responsabilidad del EntityManagerFactory est\u00e1 restringida a la creaci\u00f3n de gestores de entidades capaces de compartir un contexto de persistencia de forma coordinada. En una aplicaci\u00f3n, tambi\u00e9n en las distribuidas, s\u00f3lo puede haber una \u00fanica instancia de EntityManagerFactory por cada SGBD que haya que controlar. Cualquier intento de duplicar la EntityManagerFactory podr\u00eda dar resultados inconsistentes y totalmente inesperados . Es por ello que JPA obliga a instanciar los EntityManagerFactory usando el m\u00e9todo est\u00e1tico de la clase Persistence llamado createEntityManagerFactory . Importante La primera vez que se instancie un EntityManager se conectar\u00e1 al SGBD y comprobar\u00e1 si existen todas las tablas necesarias para mantener la persistencia de las entidades que este EntityManager controle. En caso de que falte alguna, se generar\u00e1n las sentencias de creaci\u00f3n adecuadas de acuerdo con los metadatos le\u00eddas del mapeo. JPA y PersiscenteContext \u00bfQu\u00e9 es un PersistenceContext? . En primer lugar hay que tener en cuenta que un EntityManager persistir\u00e1 un \u201cconjunto de objetos\u201d \u00bfPero qu\u00e9 objetos? Aquellos que hayan sufrido modificaciones a nivel de sus propiedades o atributos y no est\u00e9n sincronizados. Esto es a lo que comunmente se le denomina PersistenceContext . Para conseguir que alguno de nuestros objetos pase a ubicarse dentro del PersistenceContext bastar\u00e1 con invocar los m\u00e9todos persist, merge, sobre \u00e9l. public static void main ( String [] args ) { Persona yo = new Persona ( \"Patricia\" , 12 ); EntityManagerFactory emf = Persistence . createEntityManagerFactory ( \"UnidadPersonas\" ); EntityManager em = emf . createEntityManager (); try { em . getTransaction (). begin (); em . persist ( yo ); em . getTransaction (). commit (); } catch ( Exception e ) { e . printStackTrace (); } finally { em . close (); } } \ud83d\udd05 Fichero de persistencia La configuraci\u00f3n de cada EntityManagerFactory se consigue a trav\u00e9s de un archivo XML llamado persistence.xml (ver figura). Se encuentra situado en un directorio de la aplicaci\u00f3n llamado META-INF de un proyecto Java. Este fichero se encarga de conectarnos a la base de datos y define el conjunto de entidades que vamos a gestionar, Por tanto, dentro de este archivo escribiremos todas las configuraciones de conexi\u00f3n necesarias para cada SGBD. Cada configuraci\u00f3n constituir\u00e1 lo que llamamos una unidad de persistencia . Las unidades de persistencia se identifican por medio de un nombre, el cual pasaremos como par\u00e1metro al m\u00e9todo createEntityMangerFactory de la clase Persistence, de modo que el EntityManagerFactory creado estar\u00e1 configurado para conectarse a un SGBD espec\u00edfico . Nota Muchas aplicaciones Java conectan a varias bases de datos, por tanto tendr\u00e1n diferentes EntityManagerFactorys. Cada uno estar\u00e1 ligado un PersistenceUnit diferente. El formato XML del archivo sigue el esquema que puede verse en la figura. Del elemento ra\u00edz llamado Persistence se pueden describir tantos Persistence-Unit como sea necesario. Dentro de un Persistence-Unit encontramos el elemento Provider , que contendr\u00e1 la clase principal de la herramienta que implementar\u00e1 JPA. Tambi\u00e9n podemos incluir el conjunto de clases de nuestra aplicaci\u00f3n a considerar entidades y que ser\u00e1n los objetos de la persistencia. Finalmente, el esquema presenta una manera de parametrizar la configuraci\u00f3n en funci\u00f3n de los diferentes providers o herramientas de implementaci\u00f3n de JPA. Nos referimos al elemento Properties. Ejemplo: persistence.xml <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <persistence xmlns= \"https://jakarta.ee/xml/ns/persistence\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd\" version= \"3.0\" > <persistence-unit name= \"default\" > <class> es.severo.entity.Tramite </class> <properties> <property name= \"hibernate.connection.url\" value= \"jdbc:mysql://localhost:3306/testdb2\" /> <property name= \"hibernate.connection.driver_class\" value= \"com.mysql.cj.jdbc.Driver\" /> <property name= \"hibernate.connection.username\" value= \"root\" ></property> <property name= \"hibernate.connection.password\" value= \"root\" ></property> <property name= \"hibernate.show_sql\" value= \"true\" /> </properties> </persistence-unit> </persistence> Tag name Description \ud83c\udf00 <persistence-unit> Se define una con un nombre que debe ser \u00fanico por cada proveedor que usemos. A esta persistence-unit se le puede poner un atributo transaction-type, cuyos valores pueden ser RESOURCE_LOCAL o JTA. \ud83c\udf00 <provider> Proveedor de persistencia. JPA s\u00f3lo define la API o interfaces que se deben cumplir si se quiere usa JPA, pero no implementa esas clases. Necesitamos una librer\u00eda externa que implemente esta API. Una de las m\u00e1s conocidas es Hibernate. Para este ejemplo, usaremos dos, Hibernate y EclipseLink. Por supuesto, para tener estos proveedores, necesitamos a\u00f1adir el jar correspondiente a nuestro proyecto. Si usamos maven, las dependencias ser\u00eda una de estas dos, seg\u00fan queramos eclipseLink o hibernate. \ud83c\udf00 <class> Lo utilizamos para poner las clases que van a ser persistentes. \ud83c\udf00 <properties> Contiene los par\u00e1metros de conexi\u00f3n a la base de datos. Para ello, podemos usar bien propiedades generales definidas por JPA, o bien propiedades espec\u00edficas del proveedor de persistencia que usemos, es decir, propiedades espec\u00edficas de hibernate, de eclipseLync, etc. Yo he indicado las propiedades generales de JPA. El fichero es parte del standard y existir\u00e1 en cualquier implementaci\u00f3n de JPA que se utilice. En resumen, para crear un EntityManager necesario tener un archivo llamado persistence.xml con el formato que se acaba de describir. Adem\u00e1s, hay que crear un EntityManagerFactory configur\u00e1ndolo a partir de una unidad de persistencia incluida en el fichero persistence.xml, el cual nos permitir\u00e1 obtener el EntityManager . Codigo.java EntityManagerFactory emf = Persistence . createEntityManagerFactory ( \u201c jpaAccesoDatosHibernate \u201d ); //Es el nombre que hemos puesto en <persistence-unit> en el fichero persistence.xml EntityManager em = emf . createEntityManager (); Ejemplo de c\u00f3digo para crear un EntityManager a partir del fichero anterior persistence.xml. \ud83d\udd05 Transacciones y excepciones En aplicaciones locales EntityManager dispone del m\u00e9todo getTransaction para obtener la transacci\u00f3n en curso, si la hay, o para crear una de lo contrario. Una vez creada, la transacci\u00f3n se activa invocando el m\u00e9todo begin y finaliza cuando se invoca commit. No es necesario invocar rollback en caso de error. JPA invoca autom\u00e1ticamente la revocaci\u00f3n de las acciones cuando se lanzan excepciones de tipo RuntimeException , a partir de la \u00faltima invocaci\u00f3n begin. Todas las excepciones generadas por JPA son de tipo RuntimeException . Este tipo de excepci\u00f3n presenta la particularidad de que no se declarar\u00e1 en la firma del m\u00e9todo y, por tanto, el uso de try-catch no es obligatorio . Este tipo de transacciones presentan la ventaja de poder escribir un c\u00f3digo m\u00e1s limpio (sin sentencias try-catch intermedias), pero por el contrario el desarrollador tiene que ir mucho m\u00e1s cuidado de no olvidarse de hacer el tratamiento de las excepciones. Ayuda Para facilitar este tratamiento, todas las excepciones JPA heredan de un antecesor com\u00fan llamado PersistenceException . Implementaciones de JPA La principal ventaja que JPA nos proporciona es que, si las bibliotecas de persistencia que utilices siguen la especificaci\u00f3n JPA, podr\u00e1s cambiar de una a otra, con m\u00e1s rendimiento o caracter\u00edsticas mejores, sin tener que tocar tu c\u00f3digo, simplemente cambiando las referencias. Existen diversas implementaciones disponibles, como DataNucleus , ObjectDB , o Apache OpenJPA , pero las dos m\u00e1s utilizadas son EclipseLink y sobre todo Hibernate . Hibernate, en la actualidad es casi el \"est\u00e1ndar\" de facto, puesto que es la m\u00e1s utilizada, sobre todo en las empresas. Es tan popular que existen hasta versiones para otras plataformas, como NHibernate para la plataforma .NET. Es un proyecto muy maduro (de hecho, la especificaci\u00f3n JPA original parti\u00f3 de \u00e9l), muy bien documentado y que tiene un gran rendimiento. Importante \ud83e\udd14 Hibernate y HQL se crearon antes de la especificaci\u00f3n JPA. Hasta la versi\u00f3n Hibernate 3, JPQL es un subconjunto de HQL.","title":"3.2.- Jakarta - JPA"},{"location":"ud3/32jpa/#jakarta-jpa-java-persistence-api","text":"JPA es una especificaci\u00f3n que ofrece Java para implementar un Framework Object Relational Mapping (ORM), \u00e9sta especificaci\u00f3n indica c\u00f3mo se debe realizar la persistencia de los objetos en programas Java. F\u00edjate que se ha destacado la palabra \"especificaci\u00f3n\" porque JPA no tiene una implementaci\u00f3n concreta , sino que, existen diversas tecnolog\u00edas que implementan JPA para darle concreci\u00f3n. Persistencia en este contexto cubre tres \u00e1reas: La API en s\u00ed misma, definida en el paquete jakarta.persistence El lenguaje de consulta Java Persistence Query Language ( JPQL ). Metadatos objeto/relacional. Importante The JPA was renamed as Jakarta Persistence in 2019 and version 3.0 was released in 2020. This included the renaming of packages and properties from javax.persistence to jakarta.persistence.","title":"Jakarta - JPA (Java Persistence API)"},{"location":"ud3/32jpa/#como-funciona-jpa","text":"Dado que es una especificaci\u00f3n, JPA no proporciona clase alguna para poder trabajar con la informaci\u00f3n. Lo que hace es proveernos de una serie de interfaces que podemos utilizar para implementar la capa de persistencia de nuestra aplicaci\u00f3n , apoy\u00e1ndonos en alguna implementaci\u00f3n concreta de JPA. Es decir, en la pr\u00e1ctica significa que lo que vamos a utilizar es una biblioteca de persistencia que implemente JPA, no JPA directamente.","title":"\u00bfC\u00f3mo funciona JPA?"},{"location":"ud3/32jpa/#arquitectura","text":"","title":"Arquitectura"},{"location":"ud3/32jpa/#entidades-entity","text":"El concepto de entidad est\u00e1 muy relacionado con los SGBD y los modelos relacionales, sobre todo en sus fases de dise\u00f1o inicial con el que se denomina modelo Entidad-Relaci\u00f3n. Para JPA, las entidades son aquellos objetos de los que se desea almacenar su estado y que acabar\u00e1n transform\u00e1ndose en tablas y relaciones . En JPA todas las entidades son persistentes , pero no todos los objetos lo son. Para hacer que un objeto sea persistente hay que calificarlo de entidad o bien debe formar parte del estado de una entidad (en forma de atributo, por ejemplo). Todas las entidades se deben poder identificar de forma \u00fanica a partir de su estado. Normalmente, ser\u00e1 suficiente con una peque\u00f1a parte de sus atributos para lograr la identificaci\u00f3n. La selecci\u00f3n de atributos que cumplan este objetivo se denominan identificadores, y en el SGBD actuar\u00e1n como clave primaria.","title":"\ud83d\udd05 Entidades - Entity"},{"location":"ud3/32jpa/#entitymanagerfactory-y-entitymanager","text":"JPA implementa una interfaz llamada EntityManager que actuar\u00e1 de gestor de las entidades de la aplicaci\u00f3n. Sobre esta clase recae toda la funcionalidad referida a los procesos de persistencia y sincronizaci\u00f3n de las entidades. Se trata, seguramente, de la clase m\u00e1s importante de la biblioteca JPA . Un EntityManager asume toda la funcionalidad que una aplicaci\u00f3n pueda necesitar, pero \u00fanicamente a nivel local. JPA no permite instanciar los EntityManager directamente , sino que obliga a instanciarlos desde un EntityManagerFactory , el cual a su vez s\u00f3lo podr\u00e1 ser instanciado por la clase Persistence . Por consiguiente , el EntityManager ser\u00e1 el encargado de realizar todas las operaciones de tipo CRUD ( insertar , borrar ,seleccionar y actualizar etc) sobre las entidades. La responsabilidad del EntityManagerFactory est\u00e1 restringida a la creaci\u00f3n de gestores de entidades capaces de compartir un contexto de persistencia de forma coordinada. En una aplicaci\u00f3n, tambi\u00e9n en las distribuidas, s\u00f3lo puede haber una \u00fanica instancia de EntityManagerFactory por cada SGBD que haya que controlar. Cualquier intento de duplicar la EntityManagerFactory podr\u00eda dar resultados inconsistentes y totalmente inesperados . Es por ello que JPA obliga a instanciar los EntityManagerFactory usando el m\u00e9todo est\u00e1tico de la clase Persistence llamado createEntityManagerFactory . Importante La primera vez que se instancie un EntityManager se conectar\u00e1 al SGBD y comprobar\u00e1 si existen todas las tablas necesarias para mantener la persistencia de las entidades que este EntityManager controle. En caso de que falte alguna, se generar\u00e1n las sentencias de creaci\u00f3n adecuadas de acuerdo con los metadatos le\u00eddas del mapeo.","title":"\ud83d\udd05 EntityManagerFactory y EntityManager"},{"location":"ud3/32jpa/#jpa-y-persiscentecontext","text":"\u00bfQu\u00e9 es un PersistenceContext? . En primer lugar hay que tener en cuenta que un EntityManager persistir\u00e1 un \u201cconjunto de objetos\u201d \u00bfPero qu\u00e9 objetos? Aquellos que hayan sufrido modificaciones a nivel de sus propiedades o atributos y no est\u00e9n sincronizados. Esto es a lo que comunmente se le denomina PersistenceContext . Para conseguir que alguno de nuestros objetos pase a ubicarse dentro del PersistenceContext bastar\u00e1 con invocar los m\u00e9todos persist, merge, sobre \u00e9l. public static void main ( String [] args ) { Persona yo = new Persona ( \"Patricia\" , 12 ); EntityManagerFactory emf = Persistence . createEntityManagerFactory ( \"UnidadPersonas\" ); EntityManager em = emf . createEntityManager (); try { em . getTransaction (). begin (); em . persist ( yo ); em . getTransaction (). commit (); } catch ( Exception e ) { e . printStackTrace (); } finally { em . close (); } }","title":"JPA y PersiscenteContext"},{"location":"ud3/32jpa/#fichero-de-persistencia","text":"La configuraci\u00f3n de cada EntityManagerFactory se consigue a trav\u00e9s de un archivo XML llamado persistence.xml (ver figura). Se encuentra situado en un directorio de la aplicaci\u00f3n llamado META-INF de un proyecto Java. Este fichero se encarga de conectarnos a la base de datos y define el conjunto de entidades que vamos a gestionar, Por tanto, dentro de este archivo escribiremos todas las configuraciones de conexi\u00f3n necesarias para cada SGBD. Cada configuraci\u00f3n constituir\u00e1 lo que llamamos una unidad de persistencia . Las unidades de persistencia se identifican por medio de un nombre, el cual pasaremos como par\u00e1metro al m\u00e9todo createEntityMangerFactory de la clase Persistence, de modo que el EntityManagerFactory creado estar\u00e1 configurado para conectarse a un SGBD espec\u00edfico . Nota Muchas aplicaciones Java conectan a varias bases de datos, por tanto tendr\u00e1n diferentes EntityManagerFactorys. Cada uno estar\u00e1 ligado un PersistenceUnit diferente. El formato XML del archivo sigue el esquema que puede verse en la figura. Del elemento ra\u00edz llamado Persistence se pueden describir tantos Persistence-Unit como sea necesario. Dentro de un Persistence-Unit encontramos el elemento Provider , que contendr\u00e1 la clase principal de la herramienta que implementar\u00e1 JPA. Tambi\u00e9n podemos incluir el conjunto de clases de nuestra aplicaci\u00f3n a considerar entidades y que ser\u00e1n los objetos de la persistencia. Finalmente, el esquema presenta una manera de parametrizar la configuraci\u00f3n en funci\u00f3n de los diferentes providers o herramientas de implementaci\u00f3n de JPA. Nos referimos al elemento Properties. Ejemplo: persistence.xml <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <persistence xmlns= \"https://jakarta.ee/xml/ns/persistence\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd\" version= \"3.0\" > <persistence-unit name= \"default\" > <class> es.severo.entity.Tramite </class> <properties> <property name= \"hibernate.connection.url\" value= \"jdbc:mysql://localhost:3306/testdb2\" /> <property name= \"hibernate.connection.driver_class\" value= \"com.mysql.cj.jdbc.Driver\" /> <property name= \"hibernate.connection.username\" value= \"root\" ></property> <property name= \"hibernate.connection.password\" value= \"root\" ></property> <property name= \"hibernate.show_sql\" value= \"true\" /> </properties> </persistence-unit> </persistence> Tag name Description \ud83c\udf00 <persistence-unit> Se define una con un nombre que debe ser \u00fanico por cada proveedor que usemos. A esta persistence-unit se le puede poner un atributo transaction-type, cuyos valores pueden ser RESOURCE_LOCAL o JTA. \ud83c\udf00 <provider> Proveedor de persistencia. JPA s\u00f3lo define la API o interfaces que se deben cumplir si se quiere usa JPA, pero no implementa esas clases. Necesitamos una librer\u00eda externa que implemente esta API. Una de las m\u00e1s conocidas es Hibernate. Para este ejemplo, usaremos dos, Hibernate y EclipseLink. Por supuesto, para tener estos proveedores, necesitamos a\u00f1adir el jar correspondiente a nuestro proyecto. Si usamos maven, las dependencias ser\u00eda una de estas dos, seg\u00fan queramos eclipseLink o hibernate. \ud83c\udf00 <class> Lo utilizamos para poner las clases que van a ser persistentes. \ud83c\udf00 <properties> Contiene los par\u00e1metros de conexi\u00f3n a la base de datos. Para ello, podemos usar bien propiedades generales definidas por JPA, o bien propiedades espec\u00edficas del proveedor de persistencia que usemos, es decir, propiedades espec\u00edficas de hibernate, de eclipseLync, etc. Yo he indicado las propiedades generales de JPA. El fichero es parte del standard y existir\u00e1 en cualquier implementaci\u00f3n de JPA que se utilice. En resumen, para crear un EntityManager necesario tener un archivo llamado persistence.xml con el formato que se acaba de describir. Adem\u00e1s, hay que crear un EntityManagerFactory configur\u00e1ndolo a partir de una unidad de persistencia incluida en el fichero persistence.xml, el cual nos permitir\u00e1 obtener el EntityManager . Codigo.java EntityManagerFactory emf = Persistence . createEntityManagerFactory ( \u201c jpaAccesoDatosHibernate \u201d ); //Es el nombre que hemos puesto en <persistence-unit> en el fichero persistence.xml EntityManager em = emf . createEntityManager (); Ejemplo de c\u00f3digo para crear un EntityManager a partir del fichero anterior persistence.xml.","title":"\ud83d\udd05 Fichero de persistencia"},{"location":"ud3/32jpa/#transacciones-y-excepciones","text":"En aplicaciones locales EntityManager dispone del m\u00e9todo getTransaction para obtener la transacci\u00f3n en curso, si la hay, o para crear una de lo contrario. Una vez creada, la transacci\u00f3n se activa invocando el m\u00e9todo begin y finaliza cuando se invoca commit. No es necesario invocar rollback en caso de error. JPA invoca autom\u00e1ticamente la revocaci\u00f3n de las acciones cuando se lanzan excepciones de tipo RuntimeException , a partir de la \u00faltima invocaci\u00f3n begin. Todas las excepciones generadas por JPA son de tipo RuntimeException . Este tipo de excepci\u00f3n presenta la particularidad de que no se declarar\u00e1 en la firma del m\u00e9todo y, por tanto, el uso de try-catch no es obligatorio . Este tipo de transacciones presentan la ventaja de poder escribir un c\u00f3digo m\u00e1s limpio (sin sentencias try-catch intermedias), pero por el contrario el desarrollador tiene que ir mucho m\u00e1s cuidado de no olvidarse de hacer el tratamiento de las excepciones. Ayuda Para facilitar este tratamiento, todas las excepciones JPA heredan de un antecesor com\u00fan llamado PersistenceException .","title":"\ud83d\udd05 Transacciones y excepciones"},{"location":"ud3/32jpa/#implementaciones-de-jpa","text":"La principal ventaja que JPA nos proporciona es que, si las bibliotecas de persistencia que utilices siguen la especificaci\u00f3n JPA, podr\u00e1s cambiar de una a otra, con m\u00e1s rendimiento o caracter\u00edsticas mejores, sin tener que tocar tu c\u00f3digo, simplemente cambiando las referencias. Existen diversas implementaciones disponibles, como DataNucleus , ObjectDB , o Apache OpenJPA , pero las dos m\u00e1s utilizadas son EclipseLink y sobre todo Hibernate . Hibernate, en la actualidad es casi el \"est\u00e1ndar\" de facto, puesto que es la m\u00e1s utilizada, sobre todo en las empresas. Es tan popular que existen hasta versiones para otras plataformas, como NHibernate para la plataforma .NET. Es un proyecto muy maduro (de hecho, la especificaci\u00f3n JPA original parti\u00f3 de \u00e9l), muy bien documentado y que tiene un gran rendimiento. Importante \ud83e\udd14 Hibernate y HQL se crearon antes de la especificaci\u00f3n JPA. Hasta la versi\u00f3n Hibernate 3, JPQL es un subconjunto de HQL.","title":"Implementaciones de JPA"},{"location":"ud3/33hibernate/","text":"\ud83d\udc3b\u200d\u2744\ufe0f Hibernate, como una soluci\u00f3n ORM, efectivamente \"se ubica entre\" la capa de acceso a datos de la aplicaci\u00f3n Java y la base de datos relacional, como se puede ver en el diagrama siguiente. \ud83c\udf10 Documentaci\u00f3n oficial Arquitectura La arquitectura \"completa\" abstrae la aplicaci\u00f3n de las APIs de JDBC/JTA y permite que Hibernate se encargue de los detalles. Hibernate usa JDBC para conectar con la BBDD y ejecutar querys. Como proveedor de persistencia de Jakarta, Hibernate implementa las especificaciones de la API de persistencia de Java (JPA) y la asociaci\u00f3n entre las interfaces de persistencia de Jakarta y las implementaciones espec\u00edficas de Hibernate, que se pueden ver en el siguiente diagrama: \ud83e\udd16 SessionFactory : inmutable, es una f\u00e1brica para instanciar objetos Session . EntityManagerFactory es el equivalente de Persistencia de Jakarta de SessionFactory . Una SessionFactory es muy costosa de crear, por lo que, para cualquier base de datos dada, la aplicaci\u00f3n debe tener solo una SessionFactory asociada. SessionFactory mantiene los servicios que Hibernate usa en todas las sesiones, como cach\u00e9s de segundo nivel, grupos de conexiones, integraciones de sistemas de transacciones, etc. \ud83e\udd16 Session : En la nomenclatura de persistencia de Jakarta, la sesi\u00f3n est\u00e1 representada por un EntityManager . Session envuelve un JDBC java.sql.Connection y act\u00faa como una f\u00e1brica para las instancias de org.hibernate.Transaction . \ud83e\udd16 Transaction : EntityTransaction es el equivalente de Jakarta Persistence y ambos act\u00faan como una API de abstracci\u00f3n para aislar la aplicaci\u00f3n del sistema de transacciones subyacente en uso (JDBC o JTA). Persistence Context Tanto la API org.hibernate.Session como la API jakarta.persistence.EntityManager representan un contexto para tratar con datos persistentes. Este concepto se denomina contexto de persistencia . Los datos persistentes tienen un estado en relaci\u00f3n con un contexto de persistencia y la base de datos subyacente. \ud83e\udde3 Transient (transitorio): la entidad acaba de ser instanciada y no est\u00e1 asociada con un contexto de persistencia. No tiene una representaci\u00f3n persistente en la base de datos y, por lo general, no se ha asignado ning\u00fan valor de identificador (a menos que se haya utilizado el generador asignado). No est\u00e1 asociado a ninguna sesi\u00f3n. \ud83e\udde3 Persistent : la entidad tiene un identificador asociado y est\u00e1 asociada con un contexto de persistencia. Puede o no existir f\u00edsicamente en la base de datos todav\u00eda. \ud83e\udde3 Detached (separado): la entidad tiene un identificador asociado pero ya no est\u00e1 asociada con un contexto de persistencia (generalmente porque el contexto de persistencia se cerr\u00f3 (sesi\u00f3n) o la instancia se desaloj\u00f3 del contexto). \ud83e\udde3 Removed : la entidad tiene un identificador asociado y est\u00e1 asociada con un contexto de persistencia; sin embargo, est\u00e1 programada para su eliminaci\u00f3n de la base de datos. Configuraci\u00f3n Hibernate Hibernate requiere saber de antemano d\u00f3nde encontrar la informaci\u00f3n de configuraci\u00f3n de la BBDD y de mapeo d que define c\u00f3mo se relacionan las clases de Java con las tablas de la base de datos. Toda esta informaci\u00f3n generalmente se proporciona como un archivo de propiedades de Java est\u00e1ndar llamado hibernate.properties , o como un archivo XML llamado hibernate.cfg.xml . La mayor\u00eda de las propiedades cogen los valores predeterminados y no es necesario especificarlos en el archivo de propiedades a menos que sea realmente necesario. Este archivo se guarda en el directorio ra\u00edz del classpath de su aplicaci\u00f3n. Para el ejemplo usaremos un fichero XML de configuraci\u00f3n: hibernate.cfg.xml <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <hibernate-configuration xmlns= \"http://www.hibernate.org/xsd/orm/cfg\" > <session-factory> <property name= \"connection.driver_class\" > com.mysql.cj.jdbc.Driver </property> <property name= \"connection.url\" > jdbc:mysql://localhost:3306/testdb2 </property> <property name= \"connection.username\" > root </property> <property name= \"connection.password\" > root </property> <property name= \"dialect\" > org.hibernate.dialect.MySQLDialect </property> <!--Mapeo mediante anotaciones --> <mapping class= \"es.severo.persistence.entity.Tramite\" ></mapping> </session-factory> </hibernate-configuration> Website Oficial con todas las propiedades del fichero de configuraci\u00f3n Entity properties Las clases que sean entidades deben cumplir las siguientes convenciones recomendadas : \ud83d\ude80 Incluir atributos de clase con visibilidad privada, private . \ud83d\ude80 A\u00f1adir el constructor por defecto , sin argumentos. Esto es un requisito de Jakarta e Hibernate para todas las clases persistentes. Hibernate necesita crear objetos para nosotros, utilizando Java Reflection. \ud83d\ude80 Incluir getters y setters . \ud83d\ude80 Declarar atributos de identificador ( @Id ) con nombres consistentes, y que se use un wrapper y no un tipo de dato primitivo. Ej Long o Integer. El atributo identificador no necesariamente necesita ser mapeado a la(s) columna(s) que definen f\u00edsicamente la clave primaria. Sin embargo, debe asignarse a la(s) columna(s) que pueden identificar de forma \u00fanica cada fila. \ud83d\ude80 Mapear la entidad con las anotaciones necesarias. @Entity para denotar que es una entidad. Y las anotaciones que se requieran en los atributos. --batches y flush and clear Hibernate Query Language - HQL Official Website JPQL (Java Persistence Query Language) se inspir\u00f3 en las primeras versiones de HQL y es un subconjunto del HQL moderno. Si se desea el cumplimiento estricto de la persistencia de Jakarta, tendr\u00edamos que utilizar en la configuraci\u00f3n la siguiente propiedad hibernate.jpa.compliance.query=true . Con esta configuraci\u00f3n, cualquier intento de utilizar funciones HQL m\u00e1s all\u00e1 del subconjunto JPQL dar\u00e1 como resultado una excepci\u00f3n. HQL (y JPQL) se basan libremente en SQL y son f\u00e1ciles de aprender para cualquiera que est\u00e9 familiarizado con SQL. Hibernate usa un poderoso lenguaje de consulta (HQL) que es similar en apariencia a SQL. Sin embargo, en comparaci\u00f3n con SQL, HQL est\u00e1 completamente orientado a objetos y comprende nociones como herencia, polimorfismo y asociaci\u00f3n. El lenguaje de consulta de Hibernate (HQL) y el lenguaje de consulta de persistencia de Java (JPQL) son lenguajes de consulta orientados a objetos basados \u200b\u200ben SQL y muy similares a SQL. HQL no es la \u00fanica forma de escribir consultas en Hibernate: \ud83e\udde8Criteria ofrece una API basada en Java con mayor seguridad de tipos en tiempo de compilaci\u00f3n, y \ud83e\udde8tambi\u00e9n son posibles las consultas SQL nativas. Sin embargo, HQL es la opci\u00f3n m\u00e1s conveniente para la mayor\u00eda de las personas la mayor parte del tiempo. \ud83d\udc88 Hibernate DML language Hibernate provee m\u00e9todos para ejecutar sentencias DML. Insert : para agregar objetos usamos el m\u00e9todo persist() . En versiones anteriores se usaba save() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. Update : cuando modificamos un objeto usaremos merge() para guardar su estado en la base de datos. En versiones anteriores se usaba saveOrUpdate() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. Delete : cuando queremos borrar un objeto en la base de datos usamos remove() . En versiones anteriores se usaba delete() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. public static void main ( String [] args ) { Session session = null ; try { session = HibenateUtil . getSessionFactory (). openSession (); session . beginTransaction (); LocalDateTime now = LocalDateTime . now (); Tramite tramite = new Tramite (); tramite . setFecha ( now ); tramite . setTipo ( \"Cr\u00e9dito\" ); /* INSERT */ //session.save(tramite);//deprecated session . persist ( tramite ); /* UPDATE */ tramite . setTipo ( \"Aval\" ): //session.saveOrUpdate(tramite);//deprecated session . merge ( tramite ); /* DELETE */ //session.delete(tramite);//deprecated session . remove ( tramite ); session . getTransaction (). commit (); } catch ( Exception e ) { if ( session . getTransaction () != null ) { session . getTransaction (). rollback (); throw e ; } } finally { if ( session != null ) session . close (); } } \ud83d\udc88 Obtener una entidad con sus datos inicializados Tambi\u00e9n es bastante com\u00fan querer obtener una entidad junto con sus datos, es decir, cargar un objeto. Obtenci\u00f3n de una referencia de entidad con sus datos inicializados con Jakarta Persistence Person person = entityManager . find ( Person . class , personId ); Obtenci\u00f3n de una referencia de entidad con sus datos inicializados con la API de Hibernate Person person = session . find ( Person . class , 1L ); Obtenci\u00f3n de una referencia de entidad con sus datos inicializados usando la API de Hibernate byId() Person person = session . byId ( Person . class ). load ( personId ); En ambos casos, se devuelve null si no se encuentra ninguna fila de base de datos coincidente. Obtenci\u00f3n de una referencia de entidad Opcional con sus datos inicializados usando la API de Hibernate byId() Tambi\u00e9n es posible devolver un Java 8 Opcional: Optional < Person > optionalPerson = session . byId ( Person . class ). loadOptional ( personId ); \ud83d\udc88 Hibernate Query La interfaz de sesi\u00f3n de Hibernate refina los tipos de devoluci\u00f3n de las operaciones de EntityManager que crean objetos de consulta. Session#createQuery() , Session#createNamedQuery() y otras operaciones similares devuelven una instancia de la extensi\u00f3n org.hibernate.query.Query . Algunas formas sobrecargadas de estas operaciones devuelven un tipo sin formato, pero en Hibernate 6 todas han quedado obsoletas y el uso del tipo Query sin formato ahora se desaconseja enf\u00e1ticamente . Important Los programas deben migrar al uso de sobrecargas con seguridad de tipos que aceptan un objeto Class<T> y devuelven una Query<T> con tipo. La interfaz de consulta de Hibernate ofrece operaciones adicionales que no est\u00e1n disponibles a trav\u00e9s de TypedQuery, como veremos a continuaci\u00f3n. Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ); \ud83c\udf90 BINDING arguments en los par\u00e1metros de la query Una consulta puede tener par\u00e1metros con nombre o par\u00e1metros ordinales: Named parameters : se especifican usando la sintaxis: :name Ordinal parameters : se especifican usando la sintaxis ?1, ?2, etc. named parameters Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ); Los par\u00e1metros ordinales de estilo JPQL se numeran desde 1. Al igual que con los par\u00e1metros con nombre, un par\u00e1metro ordinal puede aparecer varias veces en una consulta. ordinal parameters Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ); Warning No es una buena idea mezclar named parameters y ordinales en una sola consulta. \ud83c\udf90 EJECUTANDO la consulta La interfaz Query se utiliza para controlar la ejecuci\u00f3n de la consulta. Ofrece tres tipos de resultados: getResultList() : es \u00fatil cuando la consulta puede devolver cero o m\u00e1s de un resultado . getSingleResult() : es solo para casos en los que la consulta siempre devuelve exactamente un resultado . Lanza una excepci\u00f3n cuando la base de datos devuelve cero o muchos resultados. getResultStream() : permite que los resultados se recuperen de forma incremental , utilizando un cursor de base de datos. List < Person > persons = entityManager . createQuery ( \"select p \" + \"from Person p \" + \"where p.name like 'John%' \" , Person . class ). getResultList (); Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ); List < Tramite > tramites = query . getResultList (); tramites . forEach ( System . out :: println ); Query < Tramite > query2 = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . setMaxResults ( 1 ); //limitaci\u00f3n de un resultado Tramite tramites2 = query2 . getSingleResult (); System . out . println ( tramites2 ); try ( Stream < Tramite > tramiteStream = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . getResultStream ()) { List < Tramite > t = tramiteStream . skip ( 2 ) //salta los dos primeros, los quita . limit ( 5 ) //saca como m\u00e1ximo 5 \u00edtems . collect ( Collectors . toList ()); t . forEach ( System . out :: println ); } Warning El m\u00e9todo getResultStream() no suele ser \u00fatil . Casi siempre es una mala idea mantener abierto el cursor de una base de datos. \ud83c\udf90 SCROLLING y STREAMING resultados La interfaz org.hibernate.query ofrece dos operaciones especializadas para leer los resultados de la consulta de manera incremental, mientras mantiene un ResultSet JDBC abierto asignado a un cursor del lado del servidor . Si la aplicaci\u00f3n no cierra un ScrollableResults , Hibernate cerrar\u00e1 autom\u00e1ticamente los recursos subyacentes cuando finalice la transacci\u00f3n. Sin embargo, es mucho mejor cerrar el ResultSet lo antes posible. try ( ScrollableResults < Tramite > scrollableResults = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . scroll ()) { while ( scrollableResults . next ()) { Tramite ta = scrollableResults . get (); System . out . println ( ta ); } } De manera similar, getResultStream() es una operaci\u00f3n especializada para leer resultados de consultas de manera incremental, mientras mantiene un ResultSet JDBC abierto asignado a un cursor del lado del servidor. Warning El m\u00e9todo getResultStream() no es una forma conveniente de obtener un flujo de Java. Por ello, usaremos getResultList().stream() cuando queramos utilizar streams. Ya hemos visto anteriormente un ejemplo de getResultStream, veamos ahora usando un stream a partir de getResultList().stream() try ( Stream < Tramite > tramiteStream = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ) . getResultList () . stream ()) { List < Tramite > t = tramiteStream . collect ( Collectors . toList ()); t . forEach ( System . out :: println ); } Hibernate cerrar\u00e1 autom\u00e1ticamente los recursos cuando finalice la transacci\u00f3n. Sin embargo, es mucho mejor cerrar el ResultSet lo antes posible. El programa siempre debe cerrar un Stream ya sea expl\u00edcitamente, llamando a close() o usando un bloque try-with-resources. Criteria - Sitio Web Oficial Las consultas Criteria ofrecen una alternativa de tipo seguro a las consultas HQL, JPQL y SQL nativas. Son una forma program\u00e1tica y segura de escribir para expresar una consultas. Las consultas Criteria son esencialmente un grafo de objetos, donde cada parte del grafo representa una parte cada vez m\u00e1s at\u00f3mica (a medida que navegamos por este grafo) de la consulta. \ud83e\uddee Grafo Criteria 1\ufe0f\u20e3 El primer paso para realizar una consulta Criteria es construir el grafo La interfaz jakarta.persistence.criteria.CriteriaBuilder es una f\u00e1brica para todas las piezas individuales de criteria. Se obtiene una instancia de jakarta.persistence.criteria.CriteriaBuilder llamando al m\u00e9todo getCriteriaBuilder() de jakarta.persistence.EntityManagerFactory o jakarta.persistence.EntityManager . 2\ufe0f\u20e3 El siguiente paso es obtener un jakarta.persistence.criteria.CriteriaQuery Esto se logra usando uno de los tres m\u00e9todos en CriteriaBuilder : \u231b CriteriaQuery createQuery( Class resultClass ) --> Querys tipadas \u231b CriteriaQuery createTupleQuery() \u231b CriteriaQuery createQuery() Cada uno tiene un prop\u00f3sito diferente seg\u00fan el tipo esperado en los resultados de la consulta. El querys tipadas de Criteria (tambi\u00e9n conocida como CriteriaQuery ) indica los tipos esperados en el resultado de la consulta. Puede ser una entidad, un Integer o cualquier otro objeto. 3\ufe0f\u20e3 Seleccionar una entidad. La forma m\u00e1s com\u00fan de consulta es utilizando Roots - Los objetos Root definen la base a partir de la cual todas las join, paths y atributos est\u00e1n disponibles en la consulta. Root es siempre un tipo de entidad . CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Address > criteria = builder . createQuery ( Address . class ); Root < Address > root = criteria . from ( Address . class ); criteria . select ( root ); //esto no ser\u00eda necesario ponerlo criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Address > session . createQuery ( criteria ). getResultList (); La llamada al m\u00e9todo CriteriaQuery#select en este ejemplo no es necesaria porque la ra\u00edz (root) ser\u00e1 la selecci\u00f3n impl\u00edcita ya que solo tenemos una \u00fanica ra\u00edz de consulta. Se ha a\u00f1adido solo para completar el ejemplo. 4\ufe0f\u20e3 Selecci\u00f3n de una expresi\u00f3n La forma m\u00e1s simple de seleccionar una expresi\u00f3n es seleccionar un atributo particular de una entidad. Pero esta expresi\u00f3n tambi\u00e9n podr\u00eda representar una agregaci\u00f3n, una operaci\u00f3n matem\u00e1tica, etc. CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < String > criteria = builder . createQuery ( String . class ); Root < Address > root = criteria . from ( Address . class ); criteria . select ( root . get ( Address_ . street )); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < String > addresses = session . createQuery ( criteria ). getResultList (); En el ejemplo, la consulta se escribe como java.lang.String porque ese es el tipo de los resultados (el tipo del atributo Address#street es java.lang.String). Debido a que una consulta puede contener varias referencias a la entidad Address, las referencias de atributos siempre deben calificarse. Esto se logra mediante la llamada al m\u00e9todo Root#get. 5\ufe0f\u20e3 Selecci\u00f3n de m\u00faltiples atributos Hay formas diferentes de realizar una select de varios atributos usando Criteria. Los valores devueltos se pueden recoger como un Objet[], Tuple, o usando un wrapper. EJEMPLO CON OBJECT[] EjemploArrayObject CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Object []> criteria = builder . createQuery ( Object [] . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Object []> objects = session . createQuery ( criteria ). getResultList (); Un mejor enfoque para seleccionar m\u00faltiples valores en la select es usar un wrapper o usar el jakarta.persistence.Tuple . EJEMPLO CON Tuple EjemploTuple CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Tuple > criteria = builder . createQuery ( Tuple . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Tuple > tuples = session . createQuery ( criteria ). getResultList (); EJEMPLO CON Wrapper Otra alternativa a la selecci\u00f3n de valores m\u00faltiples es seleccionar un objeto que \"envuelva\" los valores m\u00faltiples. Volviendo a la consulta de ejemplo, en lugar de devolver un array de [id, street], declaramos una clase que contenga estos valores y la usamos como un contenedor o objeto de retorno. EjemploWrapper CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < AddressWrapper > criteria = builder . createQuery ( AddressWrapper . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < AddressWrapper > wrappers = session . createQuery ( criteria ). getResultList (); Para cada fila del resultado, decimos que nos gustar\u00eda que el constructor correspondiente creara una instancia de AddressWrapper con los argumentos necesarios. Esta expresi\u00f3n contenedora se pasa en el select. POM proyecto pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.severo </groupId> <artifactId> adahibernate </artifactId> <version> 1.0-SNAPSHOT </version> <dependencies> <dependency> <groupId> org.hibernate.orm </groupId> <artifactId> hibernate-core </artifactId> <version> 6.1.5.Final </version> </dependency> <dependency> <groupId> mysql </groupId> <artifactId> mysql-connector-java </artifactId> <version> 8.0.31 </version> </dependency> <dependency> <groupId> org.hibernate.orm </groupId> <artifactId> hibernate-jpamodelgen </artifactId> <version> 6.1.5.Final </version> </dependency> <dependency> <groupId> jakarta.xml.bind </groupId> <artifactId> jakarta.xml.bind-api </artifactId> <version> 4.0.0 </version> </dependency> </dependencies> <properties> <maven.compiler.source> 11 </maven.compiler.source> <maven.compiler.target> 11 </maven.compiler.target> </properties> <build> <plugins> <plugin> <groupId> org.codehaus.mojo </groupId> <artifactId> build-helper-maven-plugin </artifactId> <version> 3.0.0 </version> <executions> <execution> <id> add-source </id> <phase> generate-sources </phase> <goals> <goal> add-source </goal> </goals> <configuration> <sources> <source> target/generated-sources/annotations </source> </sources> </configuration> </execution> </executions> </plugin> </plugins> </build> </project>","title":"3.3.- Hibernate"},{"location":"ud3/33hibernate/#_1","text":"\ud83d\udc3b\u200d\u2744\ufe0f Hibernate, como una soluci\u00f3n ORM, efectivamente \"se ubica entre\" la capa de acceso a datos de la aplicaci\u00f3n Java y la base de datos relacional, como se puede ver en el diagrama siguiente. \ud83c\udf10 Documentaci\u00f3n oficial","title":""},{"location":"ud3/33hibernate/#arquitectura","text":"La arquitectura \"completa\" abstrae la aplicaci\u00f3n de las APIs de JDBC/JTA y permite que Hibernate se encargue de los detalles. Hibernate usa JDBC para conectar con la BBDD y ejecutar querys. Como proveedor de persistencia de Jakarta, Hibernate implementa las especificaciones de la API de persistencia de Java (JPA) y la asociaci\u00f3n entre las interfaces de persistencia de Jakarta y las implementaciones espec\u00edficas de Hibernate, que se pueden ver en el siguiente diagrama: \ud83e\udd16 SessionFactory : inmutable, es una f\u00e1brica para instanciar objetos Session . EntityManagerFactory es el equivalente de Persistencia de Jakarta de SessionFactory . Una SessionFactory es muy costosa de crear, por lo que, para cualquier base de datos dada, la aplicaci\u00f3n debe tener solo una SessionFactory asociada. SessionFactory mantiene los servicios que Hibernate usa en todas las sesiones, como cach\u00e9s de segundo nivel, grupos de conexiones, integraciones de sistemas de transacciones, etc. \ud83e\udd16 Session : En la nomenclatura de persistencia de Jakarta, la sesi\u00f3n est\u00e1 representada por un EntityManager . Session envuelve un JDBC java.sql.Connection y act\u00faa como una f\u00e1brica para las instancias de org.hibernate.Transaction . \ud83e\udd16 Transaction : EntityTransaction es el equivalente de Jakarta Persistence y ambos act\u00faan como una API de abstracci\u00f3n para aislar la aplicaci\u00f3n del sistema de transacciones subyacente en uso (JDBC o JTA).","title":"Arquitectura"},{"location":"ud3/33hibernate/#persistence-context","text":"Tanto la API org.hibernate.Session como la API jakarta.persistence.EntityManager representan un contexto para tratar con datos persistentes. Este concepto se denomina contexto de persistencia . Los datos persistentes tienen un estado en relaci\u00f3n con un contexto de persistencia y la base de datos subyacente. \ud83e\udde3 Transient (transitorio): la entidad acaba de ser instanciada y no est\u00e1 asociada con un contexto de persistencia. No tiene una representaci\u00f3n persistente en la base de datos y, por lo general, no se ha asignado ning\u00fan valor de identificador (a menos que se haya utilizado el generador asignado). No est\u00e1 asociado a ninguna sesi\u00f3n. \ud83e\udde3 Persistent : la entidad tiene un identificador asociado y est\u00e1 asociada con un contexto de persistencia. Puede o no existir f\u00edsicamente en la base de datos todav\u00eda. \ud83e\udde3 Detached (separado): la entidad tiene un identificador asociado pero ya no est\u00e1 asociada con un contexto de persistencia (generalmente porque el contexto de persistencia se cerr\u00f3 (sesi\u00f3n) o la instancia se desaloj\u00f3 del contexto). \ud83e\udde3 Removed : la entidad tiene un identificador asociado y est\u00e1 asociada con un contexto de persistencia; sin embargo, est\u00e1 programada para su eliminaci\u00f3n de la base de datos.","title":"Persistence Context"},{"location":"ud3/33hibernate/#configuracion-hibernate","text":"Hibernate requiere saber de antemano d\u00f3nde encontrar la informaci\u00f3n de configuraci\u00f3n de la BBDD y de mapeo d que define c\u00f3mo se relacionan las clases de Java con las tablas de la base de datos. Toda esta informaci\u00f3n generalmente se proporciona como un archivo de propiedades de Java est\u00e1ndar llamado hibernate.properties , o como un archivo XML llamado hibernate.cfg.xml . La mayor\u00eda de las propiedades cogen los valores predeterminados y no es necesario especificarlos en el archivo de propiedades a menos que sea realmente necesario. Este archivo se guarda en el directorio ra\u00edz del classpath de su aplicaci\u00f3n. Para el ejemplo usaremos un fichero XML de configuraci\u00f3n: hibernate.cfg.xml <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <hibernate-configuration xmlns= \"http://www.hibernate.org/xsd/orm/cfg\" > <session-factory> <property name= \"connection.driver_class\" > com.mysql.cj.jdbc.Driver </property> <property name= \"connection.url\" > jdbc:mysql://localhost:3306/testdb2 </property> <property name= \"connection.username\" > root </property> <property name= \"connection.password\" > root </property> <property name= \"dialect\" > org.hibernate.dialect.MySQLDialect </property> <!--Mapeo mediante anotaciones --> <mapping class= \"es.severo.persistence.entity.Tramite\" ></mapping> </session-factory> </hibernate-configuration> Website Oficial con todas las propiedades del fichero de configuraci\u00f3n","title":"Configuraci\u00f3n Hibernate"},{"location":"ud3/33hibernate/#entity-properties","text":"Las clases que sean entidades deben cumplir las siguientes convenciones recomendadas : \ud83d\ude80 Incluir atributos de clase con visibilidad privada, private . \ud83d\ude80 A\u00f1adir el constructor por defecto , sin argumentos. Esto es un requisito de Jakarta e Hibernate para todas las clases persistentes. Hibernate necesita crear objetos para nosotros, utilizando Java Reflection. \ud83d\ude80 Incluir getters y setters . \ud83d\ude80 Declarar atributos de identificador ( @Id ) con nombres consistentes, y que se use un wrapper y no un tipo de dato primitivo. Ej Long o Integer. El atributo identificador no necesariamente necesita ser mapeado a la(s) columna(s) que definen f\u00edsicamente la clave primaria. Sin embargo, debe asignarse a la(s) columna(s) que pueden identificar de forma \u00fanica cada fila. \ud83d\ude80 Mapear la entidad con las anotaciones necesarias. @Entity para denotar que es una entidad. Y las anotaciones que se requieran en los atributos. --batches y flush and clear","title":"Entity properties"},{"location":"ud3/33hibernate/#hibernate-query-language-hql-official-website","text":"JPQL (Java Persistence Query Language) se inspir\u00f3 en las primeras versiones de HQL y es un subconjunto del HQL moderno. Si se desea el cumplimiento estricto de la persistencia de Jakarta, tendr\u00edamos que utilizar en la configuraci\u00f3n la siguiente propiedad hibernate.jpa.compliance.query=true . Con esta configuraci\u00f3n, cualquier intento de utilizar funciones HQL m\u00e1s all\u00e1 del subconjunto JPQL dar\u00e1 como resultado una excepci\u00f3n. HQL (y JPQL) se basan libremente en SQL y son f\u00e1ciles de aprender para cualquiera que est\u00e9 familiarizado con SQL. Hibernate usa un poderoso lenguaje de consulta (HQL) que es similar en apariencia a SQL. Sin embargo, en comparaci\u00f3n con SQL, HQL est\u00e1 completamente orientado a objetos y comprende nociones como herencia, polimorfismo y asociaci\u00f3n. El lenguaje de consulta de Hibernate (HQL) y el lenguaje de consulta de persistencia de Java (JPQL) son lenguajes de consulta orientados a objetos basados \u200b\u200ben SQL y muy similares a SQL. HQL no es la \u00fanica forma de escribir consultas en Hibernate: \ud83e\udde8Criteria ofrece una API basada en Java con mayor seguridad de tipos en tiempo de compilaci\u00f3n, y \ud83e\udde8tambi\u00e9n son posibles las consultas SQL nativas. Sin embargo, HQL es la opci\u00f3n m\u00e1s conveniente para la mayor\u00eda de las personas la mayor parte del tiempo.","title":"Hibernate Query Language - HQL Official Website"},{"location":"ud3/33hibernate/#hibernate-dml-language","text":"Hibernate provee m\u00e9todos para ejecutar sentencias DML. Insert : para agregar objetos usamos el m\u00e9todo persist() . En versiones anteriores se usaba save() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. Update : cuando modificamos un objeto usaremos merge() para guardar su estado en la base de datos. En versiones anteriores se usaba saveOrUpdate() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. Delete : cuando queremos borrar un objeto en la base de datos usamos remove() . En versiones anteriores se usaba delete() , pero este m\u00e9todo est\u00e1 deprecado y no se recomienda su uso. public static void main ( String [] args ) { Session session = null ; try { session = HibenateUtil . getSessionFactory (). openSession (); session . beginTransaction (); LocalDateTime now = LocalDateTime . now (); Tramite tramite = new Tramite (); tramite . setFecha ( now ); tramite . setTipo ( \"Cr\u00e9dito\" ); /* INSERT */ //session.save(tramite);//deprecated session . persist ( tramite ); /* UPDATE */ tramite . setTipo ( \"Aval\" ): //session.saveOrUpdate(tramite);//deprecated session . merge ( tramite ); /* DELETE */ //session.delete(tramite);//deprecated session . remove ( tramite ); session . getTransaction (). commit (); } catch ( Exception e ) { if ( session . getTransaction () != null ) { session . getTransaction (). rollback (); throw e ; } } finally { if ( session != null ) session . close (); } }","title":"\ud83d\udc88 Hibernate DML language"},{"location":"ud3/33hibernate/#obtener-una-entidad-con-sus-datos-inicializados","text":"Tambi\u00e9n es bastante com\u00fan querer obtener una entidad junto con sus datos, es decir, cargar un objeto. Obtenci\u00f3n de una referencia de entidad con sus datos inicializados con Jakarta Persistence Person person = entityManager . find ( Person . class , personId ); Obtenci\u00f3n de una referencia de entidad con sus datos inicializados con la API de Hibernate Person person = session . find ( Person . class , 1L ); Obtenci\u00f3n de una referencia de entidad con sus datos inicializados usando la API de Hibernate byId() Person person = session . byId ( Person . class ). load ( personId ); En ambos casos, se devuelve null si no se encuentra ninguna fila de base de datos coincidente. Obtenci\u00f3n de una referencia de entidad Opcional con sus datos inicializados usando la API de Hibernate byId() Tambi\u00e9n es posible devolver un Java 8 Opcional: Optional < Person > optionalPerson = session . byId ( Person . class ). loadOptional ( personId );","title":"\ud83d\udc88 Obtener una entidad con sus datos inicializados"},{"location":"ud3/33hibernate/#hibernate-query","text":"La interfaz de sesi\u00f3n de Hibernate refina los tipos de devoluci\u00f3n de las operaciones de EntityManager que crean objetos de consulta. Session#createQuery() , Session#createNamedQuery() y otras operaciones similares devuelven una instancia de la extensi\u00f3n org.hibernate.query.Query . Algunas formas sobrecargadas de estas operaciones devuelven un tipo sin formato, pero en Hibernate 6 todas han quedado obsoletas y el uso del tipo Query sin formato ahora se desaconseja enf\u00e1ticamente . Important Los programas deben migrar al uso de sobrecargas con seguridad de tipos que aceptan un objeto Class<T> y devuelven una Query<T> con tipo. La interfaz de consulta de Hibernate ofrece operaciones adicionales que no est\u00e1n disponibles a trav\u00e9s de TypedQuery, como veremos a continuaci\u00f3n. Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class );","title":"\ud83d\udc88 Hibernate Query"},{"location":"ud3/33hibernate/#binding-arguments-en-los-parametros-de-la-query","text":"Una consulta puede tener par\u00e1metros con nombre o par\u00e1metros ordinales: Named parameters : se especifican usando la sintaxis: :name Ordinal parameters : se especifican usando la sintaxis ?1, ?2, etc. named parameters Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ); Los par\u00e1metros ordinales de estilo JPQL se numeran desde 1. Al igual que con los par\u00e1metros con nombre, un par\u00e1metro ordinal puede aparecer varias veces en una consulta. ordinal parameters Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ); Warning No es una buena idea mezclar named parameters y ordinales en una sola consulta.","title":"\ud83c\udf90 BINDING arguments en los par\u00e1metros de la query"},{"location":"ud3/33hibernate/#ejecutando-la-consulta","text":"La interfaz Query se utiliza para controlar la ejecuci\u00f3n de la consulta. Ofrece tres tipos de resultados: getResultList() : es \u00fatil cuando la consulta puede devolver cero o m\u00e1s de un resultado . getSingleResult() : es solo para casos en los que la consulta siempre devuelve exactamente un resultado . Lanza una excepci\u00f3n cuando la base de datos devuelve cero o muchos resultados. getResultStream() : permite que los resultados se recuperen de forma incremental , utilizando un cursor de base de datos. List < Person > persons = entityManager . createQuery ( \"select p \" + \"from Person p \" + \"where p.name like 'John%' \" , Person . class ). getResultList (); Query < Tramite > query = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ); List < Tramite > tramites = query . getResultList (); tramites . forEach ( System . out :: println ); Query < Tramite > query2 = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . setMaxResults ( 1 ); //limitaci\u00f3n de un resultado Tramite tramites2 = query2 . getSingleResult (); System . out . println ( tramites2 ); try ( Stream < Tramite > tramiteStream = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . getResultStream ()) { List < Tramite > t = tramiteStream . skip ( 2 ) //salta los dos primeros, los quita . limit ( 5 ) //saca como m\u00e1ximo 5 \u00edtems . collect ( Collectors . toList ()); t . forEach ( System . out :: println ); } Warning El m\u00e9todo getResultStream() no suele ser \u00fatil . Casi siempre es una mala idea mantener abierto el cursor de una base de datos.","title":"\ud83c\udf90 EJECUTANDO la consulta"},{"location":"ud3/33hibernate/#scrolling-y-streaming-resultados","text":"La interfaz org.hibernate.query ofrece dos operaciones especializadas para leer los resultados de la consulta de manera incremental, mientras mantiene un ResultSet JDBC abierto asignado a un cursor del lado del servidor . Si la aplicaci\u00f3n no cierra un ScrollableResults , Hibernate cerrar\u00e1 autom\u00e1ticamente los recursos subyacentes cuando finalice la transacci\u00f3n. Sin embargo, es mucho mejor cerrar el ResultSet lo antes posible. try ( ScrollableResults < Tramite > scrollableResults = session . createQuery ( \"from Tramite where tipo = ?1\" , Tramite . class ) . setParameter ( 1 , \"Cr\u00e9dito\" ) . scroll ()) { while ( scrollableResults . next ()) { Tramite ta = scrollableResults . get (); System . out . println ( ta ); } } De manera similar, getResultStream() es una operaci\u00f3n especializada para leer resultados de consultas de manera incremental, mientras mantiene un ResultSet JDBC abierto asignado a un cursor del lado del servidor. Warning El m\u00e9todo getResultStream() no es una forma conveniente de obtener un flujo de Java. Por ello, usaremos getResultList().stream() cuando queramos utilizar streams. Ya hemos visto anteriormente un ejemplo de getResultStream, veamos ahora usando un stream a partir de getResultList().stream() try ( Stream < Tramite > tramiteStream = session . createQuery ( \"from Tramite where tipo = :tipoTram\" , Tramite . class ) . setParameter ( \"tipoTram\" , \"Cr\u00e9dito\" ) . getResultList () . stream ()) { List < Tramite > t = tramiteStream . collect ( Collectors . toList ()); t . forEach ( System . out :: println ); } Hibernate cerrar\u00e1 autom\u00e1ticamente los recursos cuando finalice la transacci\u00f3n. Sin embargo, es mucho mejor cerrar el ResultSet lo antes posible. El programa siempre debe cerrar un Stream ya sea expl\u00edcitamente, llamando a close() o usando un bloque try-with-resources.","title":"\ud83c\udf90 SCROLLING y STREAMING resultados"},{"location":"ud3/33hibernate/#criteria-sitio-web-oficial","text":"Las consultas Criteria ofrecen una alternativa de tipo seguro a las consultas HQL, JPQL y SQL nativas. Son una forma program\u00e1tica y segura de escribir para expresar una consultas. Las consultas Criteria son esencialmente un grafo de objetos, donde cada parte del grafo representa una parte cada vez m\u00e1s at\u00f3mica (a medida que navegamos por este grafo) de la consulta.","title":"Criteria - Sitio Web Oficial"},{"location":"ud3/33hibernate/#grafo-criteria","text":"","title":"\ud83e\uddee Grafo Criteria"},{"location":"ud3/33hibernate/#1-el-primer-paso-para-realizar-una-consulta-criteria-es-construir-el-grafo","text":"La interfaz jakarta.persistence.criteria.CriteriaBuilder es una f\u00e1brica para todas las piezas individuales de criteria. Se obtiene una instancia de jakarta.persistence.criteria.CriteriaBuilder llamando al m\u00e9todo getCriteriaBuilder() de jakarta.persistence.EntityManagerFactory o jakarta.persistence.EntityManager .","title":"1\ufe0f\u20e3 El primer paso para realizar una consulta Criteria es construir el grafo"},{"location":"ud3/33hibernate/#2-el-siguiente-paso-es-obtener-un-jakartapersistencecriteriacriteriaquery","text":"Esto se logra usando uno de los tres m\u00e9todos en CriteriaBuilder : \u231b CriteriaQuery createQuery( Class resultClass ) --> Querys tipadas \u231b CriteriaQuery createTupleQuery() \u231b CriteriaQuery createQuery() Cada uno tiene un prop\u00f3sito diferente seg\u00fan el tipo esperado en los resultados de la consulta. El querys tipadas de Criteria (tambi\u00e9n conocida como CriteriaQuery ) indica los tipos esperados en el resultado de la consulta. Puede ser una entidad, un Integer o cualquier otro objeto.","title":"2\ufe0f\u20e3 El siguiente paso es obtener un jakarta.persistence.criteria.CriteriaQuery"},{"location":"ud3/33hibernate/#3-seleccionar-una-entidad","text":"La forma m\u00e1s com\u00fan de consulta es utilizando Roots - Los objetos Root definen la base a partir de la cual todas las join, paths y atributos est\u00e1n disponibles en la consulta. Root es siempre un tipo de entidad . CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Address > criteria = builder . createQuery ( Address . class ); Root < Address > root = criteria . from ( Address . class ); criteria . select ( root ); //esto no ser\u00eda necesario ponerlo criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Address > session . createQuery ( criteria ). getResultList (); La llamada al m\u00e9todo CriteriaQuery#select en este ejemplo no es necesaria porque la ra\u00edz (root) ser\u00e1 la selecci\u00f3n impl\u00edcita ya que solo tenemos una \u00fanica ra\u00edz de consulta. Se ha a\u00f1adido solo para completar el ejemplo.","title":"3\ufe0f\u20e3 Seleccionar una entidad."},{"location":"ud3/33hibernate/#4-seleccion-de-una-expresion","text":"La forma m\u00e1s simple de seleccionar una expresi\u00f3n es seleccionar un atributo particular de una entidad. Pero esta expresi\u00f3n tambi\u00e9n podr\u00eda representar una agregaci\u00f3n, una operaci\u00f3n matem\u00e1tica, etc. CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < String > criteria = builder . createQuery ( String . class ); Root < Address > root = criteria . from ( Address . class ); criteria . select ( root . get ( Address_ . street )); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < String > addresses = session . createQuery ( criteria ). getResultList (); En el ejemplo, la consulta se escribe como java.lang.String porque ese es el tipo de los resultados (el tipo del atributo Address#street es java.lang.String). Debido a que una consulta puede contener varias referencias a la entidad Address, las referencias de atributos siempre deben calificarse. Esto se logra mediante la llamada al m\u00e9todo Root#get.","title":"4\ufe0f\u20e3 Selecci\u00f3n de una expresi\u00f3n"},{"location":"ud3/33hibernate/#5-seleccion-de-multiples-atributos","text":"Hay formas diferentes de realizar una select de varios atributos usando Criteria. Los valores devueltos se pueden recoger como un Objet[], Tuple, o usando un wrapper. EJEMPLO CON OBJECT[] EjemploArrayObject CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Object []> criteria = builder . createQuery ( Object [] . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Object []> objects = session . createQuery ( criteria ). getResultList (); Un mejor enfoque para seleccionar m\u00faltiples valores en la select es usar un wrapper o usar el jakarta.persistence.Tuple . EJEMPLO CON Tuple EjemploTuple CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < Tuple > criteria = builder . createQuery ( Tuple . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < Tuple > tuples = session . createQuery ( criteria ). getResultList (); EJEMPLO CON Wrapper Otra alternativa a la selecci\u00f3n de valores m\u00faltiples es seleccionar un objeto que \"envuelva\" los valores m\u00faltiples. Volviendo a la consulta de ejemplo, en lugar de devolver un array de [id, street], declaramos una clase que contenga estos valores y la usamos como un contenedor o objeto de retorno. EjemploWrapper CriteriaBuilder builder = session . getCriteriaBuilder (); CriteriaQuery < AddressWrapper > criteria = builder . createQuery ( AddressWrapper . class ); Root < Address > root = criteria . from ( Address . class ); Path < Long > idPath = root . get ( Address_ . id ); Path < String > nickNamePath = root . get ( Address_ . street ); criteria . multiselect ( idPath , nickNamePath ); criteria . where ( builder . equal ( root . get ( Address_ . number ), number )); List < AddressWrapper > wrappers = session . createQuery ( criteria ). getResultList (); Para cada fila del resultado, decimos que nos gustar\u00eda que el constructor correspondiente creara una instancia de AddressWrapper con los argumentos necesarios. Esta expresi\u00f3n contenedora se pasa en el select.","title":"5\ufe0f\u20e3 Selecci\u00f3n de m\u00faltiples atributos"},{"location":"ud3/33hibernate/#pom-proyecto","text":"pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.severo </groupId> <artifactId> adahibernate </artifactId> <version> 1.0-SNAPSHOT </version> <dependencies> <dependency> <groupId> org.hibernate.orm </groupId> <artifactId> hibernate-core </artifactId> <version> 6.1.5.Final </version> </dependency> <dependency> <groupId> mysql </groupId> <artifactId> mysql-connector-java </artifactId> <version> 8.0.31 </version> </dependency> <dependency> <groupId> org.hibernate.orm </groupId> <artifactId> hibernate-jpamodelgen </artifactId> <version> 6.1.5.Final </version> </dependency> <dependency> <groupId> jakarta.xml.bind </groupId> <artifactId> jakarta.xml.bind-api </artifactId> <version> 4.0.0 </version> </dependency> </dependencies> <properties> <maven.compiler.source> 11 </maven.compiler.source> <maven.compiler.target> 11 </maven.compiler.target> </properties> <build> <plugins> <plugin> <groupId> org.codehaus.mojo </groupId> <artifactId> build-helper-maven-plugin </artifactId> <version> 3.0.0 </version> <executions> <execution> <id> add-source </id> <phase> generate-sources </phase> <goals> <goal> add-source </goal> </goals> <configuration> <sources> <source> target/generated-sources/annotations </source> </sources> </configuration> </execution> </executions> </plugin> </plugins> </build> </project>","title":"POM proyecto"},{"location":"ud3/34dao/","text":"Patr\u00f3n DAO - Data access object Si bien es posible inyectar el acceso a la fuente de datos donde los necesitemos, no es una buena idea -de hecho resulta horrible- ir repartiendo su uso por el c\u00f3digo de nuestro proyecto sin seguir criterio alguno. Crearemos un caos que violar\u00e1 los principios de encapsulaci\u00f3n y desacoplamiento de la programaci\u00f3n orientado a objetos. Incluso habr\u00e1 ocasiones en las que necesitaremos tener m\u00e1s de una fuente de datos o la fuente de datos que tenemos variar\u00e1, lo que nos obligar\u00eda a refactorizar gran parte del c\u00f3digo. La soluci\u00f3n est\u00e1ndar consiste en recurrir al patr\u00f3n de dise\u00f1o Data Access Object (objeto de acceso a datos), m\u00e1s conocido por las siglas DAO . Las clases DAO son las responsables de implementar todas las operaciones con una fuente y\\o almacenamiento de datos. Fuera de ellas, el c\u00f3digo no tiene conocimiento sobre c\u00f3mo se realiza la persistencia; puede ser una base de datos relacional o \u00abno SQL\u00bb, ficheros de texto, etc\u00e9tera. Exponemos una API y todo lo dem\u00e1s queda encapsulado y abstra\u00eddo en los DAOs , los cuales, generalmente, obtendremos con una factor\u00eda. Por lo com\u00fan, cuando la fuente de datos es una base de datos relacional, una clase DAO contiene todas las operaciones centradas en una tabla, es decir, crearemos un DAO para cada cada entidad que lo requiera. \ud83e\ude80 1. Creaci\u00f3n de las interfaces DAO Lo primero que haremos ser\u00e1 crear las interfaces de las entidades que requieran acceso a la base de datos . Creamos interfaces para exponerlas en forma de API sus operaciones. Ya que la implementaci\u00f3n de \u00e9stas estar\u00e1 en otras clases para encapsular las operaciones. Usaremos los ejemplos de clase Person y Address que ten\u00edan una relaci\u00f3n muchos a muchos. PersonDAO.java public interface PersonDAO { Optional < Person > findById ( Long id ); void create ( Person person ); void save ( Person person ); void deleteById ( Long id ); void delete ( Person person ); } Nota En el DAO suelen ir las operaciones comunes usadas para la entidad. La nomenclatura suele ser nombre de la entidad seguido de la palabra DAO . \ud83e\ude80 2. Implementaci\u00f3n de las interfaces DAO Cada interfaz DAO tendr\u00e1 su implementaci\u00f3n. Las clases que implementan las interfaces ser\u00e1n nombradas como entidad + DAO + Impl: PersonDAOImpl . PersonDAOImpl.java public class PersonDAOImpl implements PersonDAO { @Override public Optional < Person > findById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { return Optional . ofNullable ( session . find ( Person . class , id )); } } @Override public void create ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { Transaction tx = null ; try { tx = session . beginTransaction (); session . persist ( person ); tx . commit (); } catch ( RuntimeException e ) { if ( tx != null ) tx . rollback (); e . printStackTrace (); } } } @Override public void save ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . merge ( person ); session . getTransaction (). commit (); } } @Override public void deleteById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( session . find ( Person . class , id )); session . getTransaction (). commit (); } } @Override public void delete ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( person ); session . getTransaction (). commit (); } } } Si hici\u00e9ramos lo mismo para la entidad Address , es decir, cre\u00e1ramos la interfaz AddressDAO y su implementaci\u00f3n AddressDAOImpl nos dar\u00edamos cuenta de que las clases ser\u00edan muy parecidas a PersonDAO y PersonDAOImpl , ya que contendr\u00eda los mismos m\u00e9todos con la \u00fanica diferencia de que cambia la entidad. Entonces estar\u00edamos creando mucha cantidad de c\u00f3digo redundante. \ud83e\ude80 3. Creaci\u00f3n de un DAO gen\u00e9rico Para mejorar la reusabilidad y legilibidad del c\u00f3digo deber\u00edamos hacer uso de los gen\u00e9ricos que nos ofrece Java. Por tanto, se ha de crear un DAO general que incluya las funcionalidades m\u00e1s gen\u00e9ricas de los DAO, GenericDAO . GenericDAO.java public interface GenericDAO < T > { Optional < T > findById ( Long id ); void create ( T entity ); void save ( T entity ); void deleteById ( Long id ); void delete ( T entity ); } Todos los DAOs heredar\u00e1n de GenericDAO , lo que quiere decir que todos los DAO contendr\u00e1n esos m\u00e9todos, cumplir\u00e1n con esas funciones. \ud83e\ude80 4. Implementaci\u00f3n del DAO gen\u00e9rico GenericDAOImpl.java public class GenericDAOImpl < T > implements GenericDAO < T > { private final Class < T > entityClass ; public GenericDAOImpl ( Class < T > entityClass ) { this . entityClass = entityClass ; } @Override public Optional < T > findById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { return Optional . ofNullable ( session . find ( entityClass , id )); } } @Override public void create ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { Transaction tx = null ; try { tx = session . beginTransaction (); session . persist ( entity ); tx . commit (); } catch ( RuntimeException e ) { if ( tx != null ) tx . rollback (); e . printStackTrace (); } } } @Override public void save ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . merge ( entity ); session . getTransaction (). commit (); } } @Override public void deleteById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( session . find ( entityClass , id )); session . getTransaction (). commit (); } } @Override public void delete ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( entity ); session . getTransaction (). commit (); } } } La creaci\u00f3n de esta clase gen\u00e9rica conlleva los siguientes cambios en las clases DAO: AddressDAO.java public interface AddressDAO extends GenericDAO < Address > { } AddressDAOImpl.java public class AddressDAOImpl extends GenericDAOImpl < Address > implements AddressDAO { public AddressDAOImpl () { super ( Address . class ); } } Ahora mismo la clase AddressDAO no definir\u00eda ning\u00fan m\u00e9todo nuevo, solo los que ya hereda de GenericDAO. Por tanto, \u00bfpara qu\u00e9 nos sirve tener esta clase? Ahora mismo, podr\u00edamos eliminarla, ya que no tiene ninguna funcionalidad extra, pero en un futuro si queremos realizar una operaci\u00f3n muy espec\u00edfica, o una query relacionada con esa tabla, deberemos definir ese m\u00e9todo dentro de AddressDAOImpl .","title":"3.4.- Patr\u00f3n DAO"},{"location":"ud3/34dao/#patron-dao-data-access-object","text":"Si bien es posible inyectar el acceso a la fuente de datos donde los necesitemos, no es una buena idea -de hecho resulta horrible- ir repartiendo su uso por el c\u00f3digo de nuestro proyecto sin seguir criterio alguno. Crearemos un caos que violar\u00e1 los principios de encapsulaci\u00f3n y desacoplamiento de la programaci\u00f3n orientado a objetos. Incluso habr\u00e1 ocasiones en las que necesitaremos tener m\u00e1s de una fuente de datos o la fuente de datos que tenemos variar\u00e1, lo que nos obligar\u00eda a refactorizar gran parte del c\u00f3digo. La soluci\u00f3n est\u00e1ndar consiste en recurrir al patr\u00f3n de dise\u00f1o Data Access Object (objeto de acceso a datos), m\u00e1s conocido por las siglas DAO . Las clases DAO son las responsables de implementar todas las operaciones con una fuente y\\o almacenamiento de datos. Fuera de ellas, el c\u00f3digo no tiene conocimiento sobre c\u00f3mo se realiza la persistencia; puede ser una base de datos relacional o \u00abno SQL\u00bb, ficheros de texto, etc\u00e9tera. Exponemos una API y todo lo dem\u00e1s queda encapsulado y abstra\u00eddo en los DAOs , los cuales, generalmente, obtendremos con una factor\u00eda. Por lo com\u00fan, cuando la fuente de datos es una base de datos relacional, una clase DAO contiene todas las operaciones centradas en una tabla, es decir, crearemos un DAO para cada cada entidad que lo requiera.","title":"Patr\u00f3n DAO - Data access object"},{"location":"ud3/34dao/#1-creacion-de-las-interfaces-dao","text":"Lo primero que haremos ser\u00e1 crear las interfaces de las entidades que requieran acceso a la base de datos . Creamos interfaces para exponerlas en forma de API sus operaciones. Ya que la implementaci\u00f3n de \u00e9stas estar\u00e1 en otras clases para encapsular las operaciones. Usaremos los ejemplos de clase Person y Address que ten\u00edan una relaci\u00f3n muchos a muchos. PersonDAO.java public interface PersonDAO { Optional < Person > findById ( Long id ); void create ( Person person ); void save ( Person person ); void deleteById ( Long id ); void delete ( Person person ); } Nota En el DAO suelen ir las operaciones comunes usadas para la entidad. La nomenclatura suele ser nombre de la entidad seguido de la palabra DAO .","title":"\ud83e\ude80 1. Creaci\u00f3n de las interfaces DAO"},{"location":"ud3/34dao/#2-implementacion-de-las-interfaces-dao","text":"Cada interfaz DAO tendr\u00e1 su implementaci\u00f3n. Las clases que implementan las interfaces ser\u00e1n nombradas como entidad + DAO + Impl: PersonDAOImpl . PersonDAOImpl.java public class PersonDAOImpl implements PersonDAO { @Override public Optional < Person > findById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { return Optional . ofNullable ( session . find ( Person . class , id )); } } @Override public void create ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { Transaction tx = null ; try { tx = session . beginTransaction (); session . persist ( person ); tx . commit (); } catch ( RuntimeException e ) { if ( tx != null ) tx . rollback (); e . printStackTrace (); } } } @Override public void save ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . merge ( person ); session . getTransaction (). commit (); } } @Override public void deleteById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( session . find ( Person . class , id )); session . getTransaction (). commit (); } } @Override public void delete ( Person person ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( person ); session . getTransaction (). commit (); } } } Si hici\u00e9ramos lo mismo para la entidad Address , es decir, cre\u00e1ramos la interfaz AddressDAO y su implementaci\u00f3n AddressDAOImpl nos dar\u00edamos cuenta de que las clases ser\u00edan muy parecidas a PersonDAO y PersonDAOImpl , ya que contendr\u00eda los mismos m\u00e9todos con la \u00fanica diferencia de que cambia la entidad. Entonces estar\u00edamos creando mucha cantidad de c\u00f3digo redundante.","title":"\ud83e\ude80 2. Implementaci\u00f3n de las interfaces DAO"},{"location":"ud3/34dao/#3-creacion-de-un-dao-generico","text":"Para mejorar la reusabilidad y legilibidad del c\u00f3digo deber\u00edamos hacer uso de los gen\u00e9ricos que nos ofrece Java. Por tanto, se ha de crear un DAO general que incluya las funcionalidades m\u00e1s gen\u00e9ricas de los DAO, GenericDAO . GenericDAO.java public interface GenericDAO < T > { Optional < T > findById ( Long id ); void create ( T entity ); void save ( T entity ); void deleteById ( Long id ); void delete ( T entity ); } Todos los DAOs heredar\u00e1n de GenericDAO , lo que quiere decir que todos los DAO contendr\u00e1n esos m\u00e9todos, cumplir\u00e1n con esas funciones.","title":"\ud83e\ude80 3. Creaci\u00f3n de un DAO gen\u00e9rico"},{"location":"ud3/34dao/#4-implementacion-del-dao-generico","text":"GenericDAOImpl.java public class GenericDAOImpl < T > implements GenericDAO < T > { private final Class < T > entityClass ; public GenericDAOImpl ( Class < T > entityClass ) { this . entityClass = entityClass ; } @Override public Optional < T > findById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { return Optional . ofNullable ( session . find ( entityClass , id )); } } @Override public void create ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { Transaction tx = null ; try { tx = session . beginTransaction (); session . persist ( entity ); tx . commit (); } catch ( RuntimeException e ) { if ( tx != null ) tx . rollback (); e . printStackTrace (); } } } @Override public void save ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . merge ( entity ); session . getTransaction (). commit (); } } @Override public void deleteById ( Long id ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( session . find ( entityClass , id )); session . getTransaction (). commit (); } } @Override public void delete ( T entity ) { try ( Session session = HibenateUtil . getSessionFactory (). openSession ();) { session . beginTransaction (); session . remove ( entity ); session . getTransaction (). commit (); } } } La creaci\u00f3n de esta clase gen\u00e9rica conlleva los siguientes cambios en las clases DAO: AddressDAO.java public interface AddressDAO extends GenericDAO < Address > { } AddressDAOImpl.java public class AddressDAOImpl extends GenericDAOImpl < Address > implements AddressDAO { public AddressDAOImpl () { super ( Address . class ); } } Ahora mismo la clase AddressDAO no definir\u00eda ning\u00fan m\u00e9todo nuevo, solo los que ya hereda de GenericDAO. Por tanto, \u00bfpara qu\u00e9 nos sirve tener esta clase? Ahora mismo, podr\u00edamos eliminarla, ya que no tiene ninguna funcionalidad extra, pero en un futuro si queremos realizar una operaci\u00f3n muy espec\u00edfica, o una query relacionada con esa tabla, deberemos definir ese m\u00e9todo dentro de AddressDAOImpl .","title":"\ud83e\ude80 4. Implementaci\u00f3n del DAO gen\u00e9rico"},{"location":"ud3/35service/","text":"\ud83d\udd2e Capa de servicios Es conveniente separar la l\u00f3gica del c\u00f3digo de la aplicaci\u00f3n con las operaciones que acceden a la base de datos. Para ello, se puede crear una capa intermedia llamada service . En nuestro proyecto deberemos crear un paquete llamado service que contendr\u00e1 las clases necesarias para interactuar con los objetos DAO. Dentro del paquete service, creamos la clase PersonalDataService con atributos de tipo DAO y m\u00e9todos para realizar diferentes operaciones necesarias en la apliaci\u00f3n que adem\u00e1s a\u00f1adir\u00e1n l\u00f3gica de negocio. PersonalDataService.java public class PersonalDataService { private final PersonDAO personDAO ; private final GenericDAO < Person > personGenericDAO ; public PersonalDataService () { this . personDAO = new PersonDAOImpl (); this . personGenericDAO = new PersonDAOImpl (); } public Optional < Person > getPersonById ( Long id ) { return personGenericDAO . findById ( id ); } public void createPerson ( Person person , List < Address > addresses ) { if ( addresses != null ) { for ( Address address : addresses ) { person . getAddresses (). add ( address ); } } personDAO . create ( person ); //se podr\u00eda usar el atributo personGenericDAO } } \ud83d\udd2e Testeo de la aplicaci\u00f3n Para probar el c\u00f3digo simplemente tendremos que crear un objeto de la clase service y ejecutar los m\u00e9todos convenientes: Test.java public static void main ( String [] args ) { PersonalDataService p = new PersonalDataService (); p . createPerson ( new Person ( \"Patricia\" ), new ArrayList < Address > ( Arrays . asList ( new Address ( \"Elche\" , \"19AB\" )))); System . out . println ( p . getPersonById ( 9L )); }","title":"3.5.- Service Layer"},{"location":"ud3/35service/#capa-de-servicios","text":"Es conveniente separar la l\u00f3gica del c\u00f3digo de la aplicaci\u00f3n con las operaciones que acceden a la base de datos. Para ello, se puede crear una capa intermedia llamada service . En nuestro proyecto deberemos crear un paquete llamado service que contendr\u00e1 las clases necesarias para interactuar con los objetos DAO. Dentro del paquete service, creamos la clase PersonalDataService con atributos de tipo DAO y m\u00e9todos para realizar diferentes operaciones necesarias en la apliaci\u00f3n que adem\u00e1s a\u00f1adir\u00e1n l\u00f3gica de negocio. PersonalDataService.java public class PersonalDataService { private final PersonDAO personDAO ; private final GenericDAO < Person > personGenericDAO ; public PersonalDataService () { this . personDAO = new PersonDAOImpl (); this . personGenericDAO = new PersonDAOImpl (); } public Optional < Person > getPersonById ( Long id ) { return personGenericDAO . findById ( id ); } public void createPerson ( Person person , List < Address > addresses ) { if ( addresses != null ) { for ( Address address : addresses ) { person . getAddresses (). add ( address ); } } personDAO . create ( person ); //se podr\u00eda usar el atributo personGenericDAO } }","title":"\ud83d\udd2e Capa de servicios"},{"location":"ud3/35service/#testeo-de-la-aplicacion","text":"Para probar el c\u00f3digo simplemente tendremos que crear un objeto de la clase service y ejecutar los m\u00e9todos convenientes: Test.java public static void main ( String [] args ) { PersonalDataService p = new PersonalDataService (); p . createPerson ( new Person ( \"Patricia\" ), new ArrayList < Address > ( Arrays . asList ( new Address ( \"Elche\" , \"19AB\" )))); System . out . println ( p . getPersonById ( 9L )); }","title":"\ud83d\udd2e Testeo de la aplicaci\u00f3n"},{"location":"ud4/41introduccionspring/","text":"\ud83d\uddb2\ufe0f Introducci\u00f3n a Spring Framework - Web oficial Debido al aumento de la complejidad que presentan la mayor\u00eda de los sistemas web , tanto en temas de seguridad, funcionalidad y gr\u00e1ficas, la comunidad de desarrolladores se vio en la necesidad de dise\u00f1ar ciertas ayudas, a fin de no tener que repetir c\u00f3digo, reduciendo de este modo el tiempo y el espacio para el desarrollo de aplicaciones. Lanzado por primera vez, como una plataforma de c\u00f3digo abierto Java, en el mes de Junio del a\u00f1o 2003 bajo la licencia Apache 2.0, se convirti\u00f3 desde entonces en el framework m\u00e1s popular para Java empresarial , para crear c\u00f3digo de alto rendimiento, liviano y reutilizable. Su finalidad es estandarizar, agilizar, manejar y resolver los problemas que puedan ir surgiendo en el trayecto de la programaci\u00f3n. Spring se puede considerar como el padre del los frameworks Java, ya que da soporte a varios frameworks como: Hibernate, Struts, Tapestry, EJB, JSF entre otros. La versi\u00f3n actual de Spring Framework es la 6.x.x y puedes obtener la documentaci\u00f3n desde su web oficial . \ud83e\ude94 Requisitos para crear un proyecto con Spring Para crear un proyecto con Spring debemos realizar una serie de pasos: Elegir el tipo de proyecto, es decir, elegir la herramienta de construcci\u00f3n del proyecto : Maven o Gradle y la versi\u00f3n de Java. Seleccionar las dependencias que necesitamos y su versi\u00f3n. Construir la estructura de directorios de nuestro proyecto, donde estar\u00e1 el c\u00f3digo fuente, los ficheros properties, plantillas, etc. Uso y configuraci\u00f3n de beans . \ud83e\ude94 Beans Para entender el concepto de bean en Spring necesitamos entender antes una serie algunos conceptos y c\u00f3mo administra Spring los objetos beans. \ud83e\ude83 Dependency Injection (DI) La inyecci\u00f3n de dependencias es un patr\u00f3n de dise\u00f1o que tiene como objetivo tomar la responsabilidad de crear las instancias de las clases que otro objeto necesita y suministr\u00e1rselo para que esta clase los pueda utilizar. Habitualmente nuestras clases dependen de otras para funcionar. Ejemplo de DI Por ejemplo, una clase que necesita buscar un registro en la base de datos necesitar\u00e1 de otra que se encargue de buscarlo . Pensemos en estas dos clases. Llamemos a la primera PersonalDataService que es la encargada de tomar decisiones sobre el negocio y a la segunda PersonaDAO , la cual se encargar\u00e1 de acceder a la base de datos. La clase PersonalDataService depende de la clase PersonaDAO para lograr el acceso a los datos en la base de datos, es decir, en la clase PersonalDataService ser\u00eda la responsable de crear una instancia de la clase PersonaDAO . En la inyecci\u00f3n de dependencias \u2018alguien\u2019 externo se encarga de las dependencias que las clases necesitan. \ud83e\ude83 Inversion of Control (IoC) Spring tambi\u00e9n maneja el concepto de inversi\u00f3n de control ocup\u00e1ndose de mantener en su \u2018contexto\u2019 (application context) todas las instancias de nuestra aplicaci\u00f3n y de inyectarle esa instancia a quien la necesite. Spring llama a estas instancias beans. Los beans son las instancias de las clases que est\u00e1n disponibles para ser reutilizados y son gestionados dentro del contenedor de Spring ( Spring container ). Spring sabe qu\u00e9 dependencias existen entre las instancias y se encarga de satisfacerlas. Note IoC es el trabajo que realiza Spring buscando estas dependencias entre los objetos y realizando el \u2018set\u2019 de estos beans en quien los requiera. Busca en su contenedor de beans la instancia adecuada y se la agrega al objeto cumpliendo as\u00ed con la inyecci\u00f3n de dependencias . \ud83e\ude83 Definir un Bean Para definir un nuevo bean en Spring tenemos dos opciones: Podemos definir expl\u00edcitamente un nuevo bean mediante la anotaci\u00f3n @Bean . Podemos marcar una clase Java como un bean, y permitir a Spring que lo descubra, esto se hace mediante el escaneo de componentes . Estas son dos t\u00e9cnicas diferentes para a\u00f1adir beans a nuestro contexto. \ud83e\ude94 Qu\u00e9 es un componente @Component en Spring Spring define un conjunto de anotaciones core que categorizan cada uno de los componentes asociandoles una responsabilidad concreta, es lo que llamamos Spring stereotypes. Una clase con la anotaci\u00f3n @Component es un candidato a ser escaneado mediante el proceso de negociaci\u00f3n, e instanciado como un bean y a\u00f1adido al contexto. Cuando indicamos que una clase es un @Component, lo que hacemos es decirle a Spring que queremos que cree una instancia y la gestione. @Component public class MyClass { public void doSomething () { //.. } } Al momento de inicializar la aplicaci\u00f3n, Spring har\u00e1 lo siguiente: Buscar\u00e1 dentro de la aplicaci\u00f3n las clases anotadas con @Component Crear\u00e1 una instancia de los componentes Dejar\u00e1 el componente en su contexto Buscar\u00e1 qui\u00e9n necesita esos componentes y los inyectar\u00e1 en qui\u00e9n los necesite. \ud83e\ude83 Spring Stereotypes Los estereotipos (Stereotypes) son componentes que extienden de @Component . En estos momentos existen \u00fanicamente 4: @Component : estereotipo general. @Repository : ser\u00e1 parte de la \u2018capa\u2019 de persistencia cuya funci\u00f3n ser\u00e1 el acceso a los datos. @Service : ser\u00e1 parte de la \u2018capa\u2019 de servicios encargado de gestionar las operaciones de negocio m\u00e1s importantes a nivel de la aplicaci\u00f3n y aglutina llamadas a varios repositorios de forma simult\u00e1nea. @Controller : realiza las tareas de controlador y gesti\u00f3n de la comunicaci\u00f3n entre el usuario y el aplicativo. Existe @RestController que es una especializaci\u00f3n de controller. \ud83e\ude94 C\u00f3mo crear un proyecto con Spring en IntelliJ Podemos ayudarnos de la herramienta spring initializr para crear el proyecto. Seleccionamos la siguiente configuraci\u00f3n: La exportamos y extraemos para abrir como un proyecto nuevo en IntelliJ. Instalamos el plugin en IntelliJ llamado JPA Buddy que ser\u00e1 una ayuda para desarrollar algunas funcionalidades. \ud83e\ude94 Autoconfiguraci\u00f3n del proyecto La anotaci\u00f3n @SpringBootApplication habilita el mecanismo de configuraci\u00f3n autom\u00e1tica de la aplicaci\u00f3n en funci\u00f3n de las dependencias jar que encuentre en el classpath y se encarga del escaneo de componentes. \ud83e\ude94 A\u00f1adir entidades Creamos un nuevo paquete llamado entities . Gracias al plugin que hemos instalado basta con hacer bot\u00f3n derecho sobre el paquete, New --> JPA Entity , y nos crear\u00e1 una entidad. \ud83e\ude94 Trabajando con repositorios de Spring Data Gracias a Spring Data JPA , que facilita el uso de tecnolog\u00edas de acceso a datos, bases de datos relacionales y no relacionales, servicios de datos basados en la nube, etc., podemos trabajar con Spring Data JPA repositories . El objetivo del repositorio de Spring Data es reducir significativamente la cantidad de c\u00f3digo repetitivo necesario para implementar capas de acceso a datos de persistencia. La interfaz central en la abstracci\u00f3n del repositorio de Spring Data es Repository . Esta interfaz act\u00faa principalmente como una interfaz de marcador para capturar los tipos con los que trabajar y para ayudarlo a descubrir interfaces que ampl\u00edan esta. Las interfaces CrudRepository y ListCrudRepository brindan una funcionalidad CRUD sofisticada para la clase de entidad que se administra. Adem\u00e1s de CrudRepository , hay una abstracci\u00f3n PagingAndSortingRepository que agrega m\u00e9todos adicionales para facilitar el acceso paginado a las entidades: \ud83e\ude94 Definir interfaces de repositorio Para definir una interfaz de repositorio, primero se debe crear una clase de dominio o entidad . La interfaz debe extender el Repository y el tipo debe ser la clase de dominio y el tipo de ID. Si desea exponer m\u00e9todos CRUD para ese tipo de dominio, se puede extender de CrudRepository o una de sus variantes en lugar de Repository . TodoRepository.java public interface TodoRepository extends JpaRepository < Todo , Long > { } \ud83e\ude94 M\u00e9todos de consulta Los repositorios con funcionalidad CRUD est\u00e1ndar suelen tener consultas en el almac\u00e9n de datos subyacente. Con Spring Data, declarar esas consultas se convierte en un proceso de cuatro pasos: Se declara una interfaz que extienda de Repository o una de sus subinterfaces. Haz que sea de tipo entidad y su ID. Se declaran m\u00e9todos de consulta en la interfaz. interface PersonRepository extends Repository < Person , Long > { List < Person > findByLastname ( String lastname ); } Para usarlo, bastar\u00e1 con inyectar la instancia del repositorio en el controlador.","title":"4.1.- Introducci\u00f3n a Spring Framework"},{"location":"ud4/41introduccionspring/#introduccion-a-spring-framework-web-oficial","text":"Debido al aumento de la complejidad que presentan la mayor\u00eda de los sistemas web , tanto en temas de seguridad, funcionalidad y gr\u00e1ficas, la comunidad de desarrolladores se vio en la necesidad de dise\u00f1ar ciertas ayudas, a fin de no tener que repetir c\u00f3digo, reduciendo de este modo el tiempo y el espacio para el desarrollo de aplicaciones. Lanzado por primera vez, como una plataforma de c\u00f3digo abierto Java, en el mes de Junio del a\u00f1o 2003 bajo la licencia Apache 2.0, se convirti\u00f3 desde entonces en el framework m\u00e1s popular para Java empresarial , para crear c\u00f3digo de alto rendimiento, liviano y reutilizable. Su finalidad es estandarizar, agilizar, manejar y resolver los problemas que puedan ir surgiendo en el trayecto de la programaci\u00f3n. Spring se puede considerar como el padre del los frameworks Java, ya que da soporte a varios frameworks como: Hibernate, Struts, Tapestry, EJB, JSF entre otros. La versi\u00f3n actual de Spring Framework es la 6.x.x y puedes obtener la documentaci\u00f3n desde su web oficial .","title":"\ud83d\uddb2\ufe0f Introducci\u00f3n a Spring Framework - Web oficial"},{"location":"ud4/41introduccionspring/#requisitos-para-crear-un-proyecto-con-spring","text":"Para crear un proyecto con Spring debemos realizar una serie de pasos: Elegir el tipo de proyecto, es decir, elegir la herramienta de construcci\u00f3n del proyecto : Maven o Gradle y la versi\u00f3n de Java. Seleccionar las dependencias que necesitamos y su versi\u00f3n. Construir la estructura de directorios de nuestro proyecto, donde estar\u00e1 el c\u00f3digo fuente, los ficheros properties, plantillas, etc. Uso y configuraci\u00f3n de beans .","title":"\ud83e\ude94 Requisitos para crear un proyecto con Spring"},{"location":"ud4/41introduccionspring/#beans","text":"Para entender el concepto de bean en Spring necesitamos entender antes una serie algunos conceptos y c\u00f3mo administra Spring los objetos beans.","title":"\ud83e\ude94 Beans"},{"location":"ud4/41introduccionspring/#dependency-injection-di","text":"La inyecci\u00f3n de dependencias es un patr\u00f3n de dise\u00f1o que tiene como objetivo tomar la responsabilidad de crear las instancias de las clases que otro objeto necesita y suministr\u00e1rselo para que esta clase los pueda utilizar. Habitualmente nuestras clases dependen de otras para funcionar.","title":"\ud83e\ude83 Dependency Injection (DI)"},{"location":"ud4/41introduccionspring/#ejemplo-de-di","text":"Por ejemplo, una clase que necesita buscar un registro en la base de datos necesitar\u00e1 de otra que se encargue de buscarlo . Pensemos en estas dos clases. Llamemos a la primera PersonalDataService que es la encargada de tomar decisiones sobre el negocio y a la segunda PersonaDAO , la cual se encargar\u00e1 de acceder a la base de datos. La clase PersonalDataService depende de la clase PersonaDAO para lograr el acceso a los datos en la base de datos, es decir, en la clase PersonalDataService ser\u00eda la responsable de crear una instancia de la clase PersonaDAO . En la inyecci\u00f3n de dependencias \u2018alguien\u2019 externo se encarga de las dependencias que las clases necesitan.","title":"Ejemplo de DI"},{"location":"ud4/41introduccionspring/#inversion-of-control-ioc","text":"Spring tambi\u00e9n maneja el concepto de inversi\u00f3n de control ocup\u00e1ndose de mantener en su \u2018contexto\u2019 (application context) todas las instancias de nuestra aplicaci\u00f3n y de inyectarle esa instancia a quien la necesite. Spring llama a estas instancias beans. Los beans son las instancias de las clases que est\u00e1n disponibles para ser reutilizados y son gestionados dentro del contenedor de Spring ( Spring container ). Spring sabe qu\u00e9 dependencias existen entre las instancias y se encarga de satisfacerlas. Note IoC es el trabajo que realiza Spring buscando estas dependencias entre los objetos y realizando el \u2018set\u2019 de estos beans en quien los requiera. Busca en su contenedor de beans la instancia adecuada y se la agrega al objeto cumpliendo as\u00ed con la inyecci\u00f3n de dependencias .","title":"\ud83e\ude83 Inversion of Control (IoC)"},{"location":"ud4/41introduccionspring/#definir-un-bean","text":"Para definir un nuevo bean en Spring tenemos dos opciones: Podemos definir expl\u00edcitamente un nuevo bean mediante la anotaci\u00f3n @Bean . Podemos marcar una clase Java como un bean, y permitir a Spring que lo descubra, esto se hace mediante el escaneo de componentes . Estas son dos t\u00e9cnicas diferentes para a\u00f1adir beans a nuestro contexto.","title":"\ud83e\ude83 Definir un Bean"},{"location":"ud4/41introduccionspring/#que-es-un-componente-component-en-spring","text":"Spring define un conjunto de anotaciones core que categorizan cada uno de los componentes asociandoles una responsabilidad concreta, es lo que llamamos Spring stereotypes. Una clase con la anotaci\u00f3n @Component es un candidato a ser escaneado mediante el proceso de negociaci\u00f3n, e instanciado como un bean y a\u00f1adido al contexto. Cuando indicamos que una clase es un @Component, lo que hacemos es decirle a Spring que queremos que cree una instancia y la gestione. @Component public class MyClass { public void doSomething () { //.. } } Al momento de inicializar la aplicaci\u00f3n, Spring har\u00e1 lo siguiente: Buscar\u00e1 dentro de la aplicaci\u00f3n las clases anotadas con @Component Crear\u00e1 una instancia de los componentes Dejar\u00e1 el componente en su contexto Buscar\u00e1 qui\u00e9n necesita esos componentes y los inyectar\u00e1 en qui\u00e9n los necesite.","title":"\ud83e\ude94 Qu\u00e9 es un componente @Component en Spring"},{"location":"ud4/41introduccionspring/#spring-stereotypes","text":"Los estereotipos (Stereotypes) son componentes que extienden de @Component . En estos momentos existen \u00fanicamente 4: @Component : estereotipo general. @Repository : ser\u00e1 parte de la \u2018capa\u2019 de persistencia cuya funci\u00f3n ser\u00e1 el acceso a los datos. @Service : ser\u00e1 parte de la \u2018capa\u2019 de servicios encargado de gestionar las operaciones de negocio m\u00e1s importantes a nivel de la aplicaci\u00f3n y aglutina llamadas a varios repositorios de forma simult\u00e1nea. @Controller : realiza las tareas de controlador y gesti\u00f3n de la comunicaci\u00f3n entre el usuario y el aplicativo. Existe @RestController que es una especializaci\u00f3n de controller.","title":"\ud83e\ude83 Spring Stereotypes"},{"location":"ud4/41introduccionspring/#como-crear-un-proyecto-con-spring-en-intellij","text":"Podemos ayudarnos de la herramienta spring initializr para crear el proyecto. Seleccionamos la siguiente configuraci\u00f3n: La exportamos y extraemos para abrir como un proyecto nuevo en IntelliJ. Instalamos el plugin en IntelliJ llamado JPA Buddy que ser\u00e1 una ayuda para desarrollar algunas funcionalidades.","title":"\ud83e\ude94 C\u00f3mo crear un proyecto con Spring en IntelliJ"},{"location":"ud4/41introduccionspring/#autoconfiguracion-del-proyecto","text":"La anotaci\u00f3n @SpringBootApplication habilita el mecanismo de configuraci\u00f3n autom\u00e1tica de la aplicaci\u00f3n en funci\u00f3n de las dependencias jar que encuentre en el classpath y se encarga del escaneo de componentes.","title":"\ud83e\ude94 Autoconfiguraci\u00f3n del proyecto"},{"location":"ud4/41introduccionspring/#anadir-entidades","text":"Creamos un nuevo paquete llamado entities . Gracias al plugin que hemos instalado basta con hacer bot\u00f3n derecho sobre el paquete, New --> JPA Entity , y nos crear\u00e1 una entidad.","title":"\ud83e\ude94 A\u00f1adir entidades"},{"location":"ud4/41introduccionspring/#trabajando-con-repositorios-de-spring-data","text":"Gracias a Spring Data JPA , que facilita el uso de tecnolog\u00edas de acceso a datos, bases de datos relacionales y no relacionales, servicios de datos basados en la nube, etc., podemos trabajar con Spring Data JPA repositories . El objetivo del repositorio de Spring Data es reducir significativamente la cantidad de c\u00f3digo repetitivo necesario para implementar capas de acceso a datos de persistencia. La interfaz central en la abstracci\u00f3n del repositorio de Spring Data es Repository . Esta interfaz act\u00faa principalmente como una interfaz de marcador para capturar los tipos con los que trabajar y para ayudarlo a descubrir interfaces que ampl\u00edan esta. Las interfaces CrudRepository y ListCrudRepository brindan una funcionalidad CRUD sofisticada para la clase de entidad que se administra. Adem\u00e1s de CrudRepository , hay una abstracci\u00f3n PagingAndSortingRepository que agrega m\u00e9todos adicionales para facilitar el acceso paginado a las entidades:","title":"\ud83e\ude94 Trabajando con repositorios de Spring Data"},{"location":"ud4/41introduccionspring/#definir-interfaces-de-repositorio","text":"Para definir una interfaz de repositorio, primero se debe crear una clase de dominio o entidad . La interfaz debe extender el Repository y el tipo debe ser la clase de dominio y el tipo de ID. Si desea exponer m\u00e9todos CRUD para ese tipo de dominio, se puede extender de CrudRepository o una de sus variantes en lugar de Repository . TodoRepository.java public interface TodoRepository extends JpaRepository < Todo , Long > { }","title":"\ud83e\ude94 Definir interfaces de repositorio"},{"location":"ud4/41introduccionspring/#metodos-de-consulta","text":"Los repositorios con funcionalidad CRUD est\u00e1ndar suelen tener consultas en el almac\u00e9n de datos subyacente. Con Spring Data, declarar esas consultas se convierte en un proceso de cuatro pasos: Se declara una interfaz que extienda de Repository o una de sus subinterfaces. Haz que sea de tipo entidad y su ID. Se declaran m\u00e9todos de consulta en la interfaz. interface PersonRepository extends Repository < Person , Long > { List < Person > findByLastname ( String lastname ); } Para usarlo, bastar\u00e1 con inyectar la instancia del repositorio en el controlador.","title":"\ud83e\ude94 M\u00e9todos de consulta"}]}