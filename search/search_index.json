{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Bienvenido/a al m\u00f3dulo de Acceso a Datos","text":""},{"location":"#descubre-el-poder-de-los-datos","title":"\ud83d\udcc2 \u00a1Descubre el poder de los datos!","text":"<p>En un mundo donde la informaci\u00f3n es el nuevo oro, saber c\u00f3mo manejar datos de forma profesional es m\u00e1s que una ventaja: es una necesidad.  </p> <p>En este m\u00f3dulo aprender\u00e1s a trabajar con ficheros, bases de datos relacionales y no relacionales, y a integrar tu c\u00f3digo con tecnolog\u00edas como JDBC, Hibernate, MongoDB o Spring Boot.</p> <p>\u00bfTe gustar\u00eda crear aplicaciones que se conecten a bases de datos reales como lo hacen Netflix, Amazon o Spotify?</p> <p>\u00bfQuieres entender c\u00f3mo se estructura, almacena y accede a la informaci\u00f3n en proyectos profesionales?</p> <p>Entonces este es tu m\u00f3dulo.</p>"},{"location":"#que-aprenderas","title":"\ud83d\udcd8 \u00bfQu\u00e9 aprender\u00e1s?","text":"<ul> <li>Acceder y manipular datos en distintos formatos</li> <li>Trabajar con ORMs modernos para que tus clases Java se entiendan directamente con la base de datos</li> <li>Utilizar Spring Boot para construir servicios de acceso a datos como los profesionales</li> <li>Conectarte a bases de datos relacionales (MySQL) y no relacionales (MongoDB)</li> <li>Y sobre todo, a programar con cabeza y con prop\u00f3sito</li> </ul>"},{"location":"#nuestro-objetivo","title":"\ud83c\udfaf Nuestro objetivo","text":"<p>Convertirte en alguien capaz de crear, consultar y transformar datos con soltura. No solo para superar el m\u00f3dulo, sino para estar preparado para el mundo real del desarrollo.</p> <p>Aqu\u00ed no solo ver\u00e1s teor\u00eda: te espera una metodolog\u00eda pr\u00e1ctica, enfocada y con retos reales. Te formar\u00e1s para el presente\u2026 y para el futuro.</p>"},{"location":"#y-si-eres-un-ojeador-o-docente","title":"\ud83d\udcbc \u00bfY si eres un ojeador o docente?","text":"<p>Este sitio muestra c\u00f3mo trabajamos este m\u00f3dulo dentro del curr\u00edculo de 2\u00ba DAM. Si eres profesor/a, puedes tomarlo como inspiraci\u00f3n para adaptar o enriquecer tu propia programaci\u00f3n. Y si eres una empresa, ver\u00e1s qu\u00e9 conocimientos y tecnolog\u00edas domina el alumnado en esta etapa.</p> <p>\u00bfListo para entrar al mundo del desarrollo profesional de datos? \ud83d\udca1 \u00a1Empieza explorando las unidades del curso!</p>"},{"location":"about/","title":"About me \u2764\ufe0f\u200d\ud83d\udd25","text":"<p>Mi nombre es Patricia Mart\u00ed, soy Ingeniera en Inform\u00e1tica. Durante casi una d\u00e9cada me dediqu\u00e9 al desarrollo software de manera profesional en diferentes empresas nacionales e internacionales. </p> <p>Actualmente, soy docente en el campo de la programaci\u00f3n, donde puedo compartir con entusiasmo y pasi\u00f3n los conocimientos y habilidades aprendidas durante mi trayectoria. </p> <p>Mi objetivo es inspirar a la pr\u00f3xima generaci\u00f3n de desarrolladores y ayudarles a adentrarse en el emocionante mundo de la programaci\u00f3n y la tecnolog\u00eda.</p> <p>Para cualquier consulta o mejora, pueden escribirme a trav\u00e9s de mi correo electr\u00f3nico p.marti2@edu.gva.es.</p>"},{"location":"ud1/18xmlfiles/","title":"Ficheros XML","text":"<p>XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.</p>"},{"location":"ud1/18xmlfiles/#estructura-de-un-documento-xml","title":"Estructura de un documento XML","text":"<p>Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <code>&lt;nombre&gt;</code>, donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.</p>"},{"location":"ud1/18xmlfiles/#documento-xml-valido","title":"Documento XML v\u00e1lido","text":"<p>Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones:</p> <ol> <li>Cada etiqueta de apertura tiene una etiqueta de cierre.</li> <li>Todas las etiquetas est\u00e1n completamente anidadas.</li> <li>Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial.</li> <li>El XML es sensible a may\u00fasculas y min\u00fasculas.</li> </ol>"},{"location":"ud1/18xmlfiles/#partes-de-un-documento-xml","title":"Partes de un documento XML","text":""},{"location":"ud1/18xmlfiles/#prologo","title":"Pr\u00f3logo","text":"<p>Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas.</p> <p>El pr\u00f3logo de un documento XML contiene:</p> <ul> <li>Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML.</li> <li>Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo.</li> <li>Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n</code></pre>"},{"location":"ud1/18xmlfiles/#cuerpo","title":"Cuerpo","text":"<p>A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.</p>"},{"location":"ud1/18xmlfiles/#elementos","title":"Elementos","text":"<p>Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.</p>"},{"location":"ud1/18xmlfiles/#atributos","title":"Atributos","text":"<p>Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas.</p> <pre><code>&lt;person sex=\"female\"&gt;\n&lt;firstname&gt;Patricia&lt;/firstname&gt;\n&lt;lastname&gt;Marti&lt;/lastname&gt;\n&lt;/person&gt;\n</code></pre> <p>En el ejemplo, el elemento <code>person</code> tiene un atributo <code>sex</code>.</p>"},{"location":"ud1/18xmlfiles/#comentarios","title":"Comentarios","text":"<p>Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato:</p> <pre><code>  &lt;!-- Comment --&gt;\n</code></pre>"},{"location":"ud1/18xmlfiles/#ejemplo-de-un-documento-xml","title":"Ejemplo de un documento XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"&gt;\n\n&lt;!-- This is a comment --&gt;\n&lt;products&gt; &lt;product&gt; &lt;name&gt;Cereales&lt;/name&gt; &lt;price&gt;3.45&lt;/price&gt; &lt;/product&gt; &lt;product&gt; &lt;name&gt;Colacao&lt;/name&gt; &lt;price&gt;1.45&lt;/price&gt; &lt;/product&gt; &lt;product&gt; &lt;name&gt;Agua mineral&lt;/name&gt; &lt;price&gt;1.00&lt;/price&gt; &lt;/product&gt; &lt;/products&gt;\n</code></pre>"},{"location":"ud1/18xmlfiles/#url-xml","title":"Url XML","text":"<p>El est\u00e1ndar XML</p>"},{"location":"ud1/18xmlfiles/#java-xml","title":"Java XML","text":"<p>Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos.</p> <p>En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming).</p>"},{"location":"ud1/18xmlfiles/#dom","title":"DOM","text":"<p>El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria.</p> <p>DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.</p>"},{"location":"ud1/18xmlfiles/#sax","title":"SAX","text":"<p>La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial.</p> <p>El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.</p>"},{"location":"ud1/18xmlfiles/#stax","title":"StAX","text":"<p>Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.</p>"},{"location":"ud1/18xmlfiles/#ejemplo-lectura-xml-desde-una-api","title":"Ejemplo lectura XML desde una API","text":"<pre><code>private static Document loadXMLDocument(String url)  {\ntry (InputStream input = new URL(url).openStream()) {\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nDocumentBuilder builder = factory.newDocumentBuilder();\nreturn builder.parse(input);\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud1/18xmlfiles/#escritura-de-un-documento-xml","title":"Escritura de un documento XML","text":"<pre><code>private static void writeXml(Document doc,\nOutputStream output)\nthrows TransformerException {\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\nTransformer transformer = transformerFactory.newTransformer();\ntransformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(output);\ntransformer.transform(source, result);\n}\n</code></pre>"},{"location":"ud1/binaryfiles/","title":"\ud83d\udcbe Operaciones con ficheros binarios en Java","text":"<p>Los ficheros binarios almacenan datos en forma de bytes. Se utilizan para archivos no de texto, como im\u00e1genes, audio, v\u00eddeo, ficheros comprimidos, bases de datos, etc.</p> <p>Para leer y escribir este tipo de ficheros, se usan flujos de entrada/salida de bytes.</p>"},{"location":"ud1/binaryfiles/#clases-principales-para-flujos-binarios-javaio","title":"\u270d\ufe0f Clases principales para flujos binarios (<code>java.io</code>)","text":"Operaci\u00f3n Clase usada Descripci\u00f3n Lectura binaria <code>FileInputStream</code> Lee byte a byte desde un fichero Escritura binaria <code>FileOutputStream</code> Escribe byte a byte en un fichero Lectura r\u00e1pida <code>BufferedInputStream</code> A\u00f1ade un b\u00fafer para mayor eficiencia Escritura r\u00e1pida <code>BufferedOutputStream</code> B\u00fafer de salida para rendimiento <p>Estas clases forman parte de la API cl\u00e1sica <code>java.io</code>.</p>"},{"location":"ud1/binaryfiles/#lectura-binaria-con-fileinputstream","title":"\ud83d\udce5 Lectura binaria con <code>FileInputStream</code>","text":"<p><pre><code>try (FileInputStream fis = new FileInputStream(\"entrada.bin\")) {\nint byteLeido;\nwhile ((byteLeido = fis.read()) != -1) {\nSystem.out.println(byteLeido);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> \ud83d\udd0e Este c\u00f3digo lee byte a byte. Para archivos grandes, es mejor usar un buffer.</p>"},{"location":"ud1/binaryfiles/#escritura-binaria-con-fileoutputstream","title":"\ud83d\udce5 Escritura binaria con <code>FileOutputStream</code>","text":"<p><pre><code>try (FileOutputStream fos = new FileOutputStream(\"salida.bin\")) {\nbyte[] datos = {65, 66, 67}; // A, B, C\nfos.write(datos);\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> \u270f\ufe0f Tambi\u00e9n puedes escribir byte a byte con fos.write(int b);</p>"},{"location":"ud1/binaryfiles/#operaciones-con-buffers","title":"Operaciones con buffers","text":"<p>Un buffer es una memoria intermedia que almacena temporalmente datos antes de leerlos o escribirlos. Esto hace que el programa:</p> <ul> <li>Haga menos accesos al disco (que son lentos)</li> <li>Sea m\u00e1s eficiente y r\u00e1pido</li> </ul> <p>Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez.</p> <p>Cuando se cierra el stream <code>close()</code>, es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo. Tambi\u00e9n la operaci\u00f3n <code>flush()</code> que guarda en el fichero lo que contiene el buffer actualmente.</p>"},{"location":"ud1/binaryfiles/#ejemplo-escritura-sin-buffer","title":"\ud83e\uddf1 Ejemplo escritura sin buffer","text":"<p><pre><code>try (FileOutputStream fos = new FileOutputStream(\"datos.bin\")) {\nfor (int i = 0; i &lt; 1000; i++) {\nfos.write(i); // Se escribe en disco 1000 veces, esto es muy lento\n}\n}\n</code></pre> \u26a0\ufe0f Cada <code>write()</code> escribe directamente al disco. Muy lento.</p>"},{"location":"ud1/binaryfiles/#ejemplo-de-escritura-con-bufferedoutputstream-buffer","title":"\u2705 Ejemplo de escritura con BufferedOutputStream (buffer)","text":"<p><pre><code>try (BufferedOutputStream bos = new BufferedOutputStream(\nnew FileOutputStream(\"datos.bin\"))) {\nfor (int i = 0; i &lt; 1000; i++) {\nbos.write(i); // Se acumulan en memoria y luego se escriben de golpe cuando se hace el close autom\u00e1tico\n}\n}\n</code></pre> \u2705 El buffer agrupa muchos bytes y los escribe en bloque, mejorando el rendimiento. Si queremos guardar en un punto del programa podemos hacer <code>bos.flush()</code> que realiza un volcado del buffer al fichero, guarda.</p>"},{"location":"ud1/binaryfiles/#ejemplo-de-lectura-con-bufferedinputstream-buffer","title":"\u2705 Ejemplo de lectura con BufferedInputStream (buffer)","text":"<p><pre><code>try (BufferedInputStream bis = new BufferedInputStream(\nnew FileInputStream(\"datos.bin\"))) {\nint byteLeido;\nwhile ((byteLeido = bis.read()) != -1) {\nSystem.out.println(byteLeido);\n}\n}\n</code></pre> <code>BufferedInputStream</code> crea un buffer interno. Cuando llamas por primera vez a <code>bis.read()</code>, no lee 1 byte del disco, sino que:      </p> <ul> <li>Lee miles de bytes del disco de golpe (llamada costosa de E/S).</li> <li>Los guarda en memoria (en su buffer interno).</li> <li>Luego, cada llamada a <code>.read()</code> devuelve el siguiente byte del buffer, lo cual es muy r\u00e1pido porque accede a memoria, no al disco.</li> <li>Cuando el buffer se vac\u00eda, se vuelve a rellenar con otros 8192 bytes del fichero.</li> </ul>"},{"location":"ud1/binaryfiles/#que-son-los-wrappers-y-por-que-usar-buffers","title":"\ud83e\uddfb \u00bfQu\u00e9 son los wrappers y por qu\u00e9 usar buffers?","text":"<p>En Java, muchas clases de entrada/salida se envuelven unas dentro de otras para mejorar su funcionamiento. Esto se llama patr\u00f3n decorador (decorator pattern) y permite a\u00f1adir funcionalidades sin modificar la clase original.</p> <p>La clase <code>BufferedInputStream</code>/<code>BufferedOuputStream</code> necesita siempre envolver otro <code>InputStream</code>, por lo tanto no se puede usar sola sin un wrapper.</p>"},{"location":"ud1/binaryfiles/#por-que","title":"\ud83d\udd0d \u00bfPor qu\u00e9?","text":"<p>Porque la clase <code>BufferedInputStream</code> o <code>BufferedOuputStream</code> no sabe de d\u00f3nde leer/escribir datos por s\u00ed misma. Su funci\u00f3n es a\u00f1adir un b\u00fafer a otro flujo de entrada (por ejemplo, FileInputStream/FileOutputStream), pero necesita que alguien le proporcione los datos reales.</p> <p><pre><code>try (BufferedInputStream bis = new BufferedInputStream(\nnew FileInputStream(\"archivo.bin\"))) {\n// leer datos\n}\n</code></pre> Aqu\u00ed, <code>FileInputStream</code> accede al archivo y <code>BufferedInputStream</code> a\u00f1ade un buffer por encima.</p>"},{"location":"ud1/binaryfiles/#leer-y-escribir-ficheros-binarios-con-javaniofilefiles-new-io-desde-java-14","title":"\u270d\ufe0f Leer y escribir ficheros binarios con <code>java.nio.file.Files</code> (New I/O, desde Java 1.4)","text":"<p>En Java, la clase <code>java.nio.file.Files</code> ofrece formas muy sencillas y potentes de leer y escribir ficheros binarios o de texto. Aqu\u00ed veremos las principales formas y las diferencias entre ellas para que puedas elegir la mejor seg\u00fan tu caso.</p>"},{"location":"ud1/binaryfiles/#escribir-en-un-fichero-con-files","title":"\ud83d\udce4 Escribir en un fichero con <code>Files</code>","text":""},{"location":"ud1/binaryfiles/#1-fileswritepath-path-byte-bytes-todo-el-contenido-de-golpe","title":"1. <code>Files.write(Path path, byte[] bytes)</code> (todo el contenido de golpe)","text":"<p>Escribe todos los bytes en un fichero. Sobrescribe si ya existe el fichero.</p> <pre><code>Path salida = Paths.get(\"salida.bin\");\ntry {\nbyte[] datos = {10, 20, 30, 40, 50};\nFiles.write(salida, datos);\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Muy simple</li> <li>\u26a0\ufe0f Sobrescribe el fichero por defecto</li> </ul>"},{"location":"ud1/binaryfiles/#3-fileswritepath-path-byte-bytes-openoption","title":"3. <code>Files.write(Path path, byte[] bytes, OpenOption...)</code>","text":"<p>Permite modificar el comportamiento de la escritura. Por ejemplo, al usar la opci\u00f3n <code>StandardOpenOption.APPEND</code> se a\u00f1ade al final y no sobrescribe el fichero:</p> <pre><code>Files.write(Paths.get(\"datos.log\"), datos, StandardOpenOption.APPEND);\n</code></pre> <ul> <li>\u2705 Puedes a\u00f1adir <code>StandardOpenOption.APPEND</code>, <code>CREATE</code>, <code>TRUNCATE_EXISTING</code>, etc.</li> <li>\u2705 Ideal para logs u operaciones controladas</li> </ul>"},{"location":"ud1/binaryfiles/#leer-desde-un-fichero-con-files","title":"\ud83d\udce5 Leer desde un fichero con <code>Files</code>","text":""},{"location":"ud1/binaryfiles/#1-filesreadallbytespath-path-todo-el-contenido-de-golpe","title":"1. <code>Files.readAllBytes(Path path)</code> (todo el contenido de golpe)","text":"<p>Lee el contenido del fichero como un array de bytes.</p> <pre><code>Path ruta = Paths.get(\"salida.bin\");\ntry {\nbyte[] contenido = Files.readAllBytes(ruta);\nSystem.out.println(\"Tama\u00f1o: \" + contenido.length);\nSystem.out.println(Arrays.toString(contenido));\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Ideal para ficheros peque\u00f1os o medianos</li> <li>\u26a0\ufe0f Carga todo el archivo a memoria</li> </ul> <p>Warning</p> <p><code>Files.readAllBytes()</code> y <code>Files.write()</code> no necesitan el uso de try-with-resources, internamente estas funciones abren y cierran autom\u00e1ticamente el recurso durante la operaci\u00f3n. Pero s\u00ed debes capturar la excepci\u00f3n <code>IOException</code>, ya que puede producirse si el archivo no existe, no hay permisos, etc.</p>"},{"location":"ud1/binaryfiles/#tabla-resumen-que-clasemetodo-usar-segun-la-situacion","title":"\ud83e\udde0 Tabla resumen: \u00bfQu\u00e9 clase/m\u00e9todo usar seg\u00fan la situaci\u00f3n?","text":"Herramienta \u00bfCu\u00e1ndo usarla? \u00bfBuffer incluido? \u00bfRequiere cerrar? Comentario \u00fatil <code>BufferedInputStream</code> / <code>BufferedOutputStream</code> Cuando necesitas rendimiento en lectura/escritura binaria byte a byte. \u2705 S\u00ed \u2705 S\u00ed \u00datil para ficheros grandes y lectura frecuente. <code>FileInputStream</code> / <code>FileOutputStream</code> Para acceso b\u00e1sico y directo a bytes. \u274c No \u2705 S\u00ed Bajo nivel, necesita envolverse si quieres buffer. <code>Files.readAllBytes()</code> Lectura r\u00e1pida de archivos binarios peque\u00f1os/medianos. \u274c No \u274c No Carga todo el archivo a memoria. <code>Files.write(byte[])</code> Escritura sencilla y r\u00e1pida de arrays de bytes."},{"location":"ud1/binaryfiles/#conclusion","title":"\u2705 Conclusi\u00f3n","text":"<ul> <li>Usa <code>BufferedInputStream</code> y <code>BufferedOutputStream</code> si vas a leer o escribir muchos datos en bucle.</li> <li>No hace falta usar buffer si usas m\u00e9todos como <code>Files.readAllBytes()</code> o <code>Files.write()</code>, porque ya internamente usan buffers.</li> <li>Siempre cierra bien los recursos con <code>try-with-resources</code>.</li> </ul>"},{"location":"ud1/characterfiles/","title":"\ud83d\udcdd Operaciones con ficheros de caracteres en Java","text":"<p>Los ficheros de caracteres almacenan datos en formato de texto, codificados habitualmente en UTF-8. Son los m\u00e1s usados cuando trabajamos con logs, ficheros de configuraci\u00f3n, resultados de programas, etc.</p> <p>Para trabajar con ellos, utilizamos flujos de caracteres (character streams), en lugar de flujos binarios.</p>"},{"location":"ud1/characterfiles/#clases-principales-para-flujos-de-caracteres-javaio","title":"\u270d\ufe0f Clases principales para flujos de caracteres (<code>java.io</code>)","text":"Operaci\u00f3n Clase usada Descripci\u00f3n Lectura <code>FileReader</code> Lee caracteres desde un fichero Escritura <code>FileWriter</code> Escribe caracteres en un fichero Lectura con buffer <code>BufferedReader</code> Mejora el rendimiento al leer texto Escritura con buffer <code>BufferedWriter</code> Escribe texto m\u00e1s r\u00e1pidamente Escritura formateada <code>PrintWriter</code> Para escribir texto formateado (print, println)"},{"location":"ud1/characterfiles/#operaciones-con-javaio","title":"\ud83d\uddc2\ufe0f Operaciones con <code>java.io</code>","text":""},{"location":"ud1/characterfiles/#lectura-de-texto-javaio","title":"\ud83d\udce5 Lectura de texto (<code>java.io</code>)","text":""},{"location":"ud1/characterfiles/#1-filereader","title":"1. <code>FileReader</code>","text":"<pre><code>try (FileReader fr = new FileReader(\"entrada.txt\")) {\nint c;\nwhile ((c = fr.read()) != -1) {\nSystem.out.print((char) c);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u274c Lento para ficheros grandes. Aunque <code>FileReader</code> internamente usa un buffer en memoria, para ficheros grandes es m\u00e1s eficiente usar un <code>BufferedReader</code>, porque este maneja buffers m\u00e1s grandes y est\u00e1 optimizado</li> <li>\u2705 Adecuado para ejemplos sencillos o pruebas</li> </ul>"},{"location":"ud1/characterfiles/#2-bufferedreader-lectura-eficiente","title":"2. <code>BufferedReader</code> (lectura eficiente)","text":"<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(\"entrada.txt\"))) {\nString linea;\nwhile ((linea = br.readLine()) != null) {\nSystem.out.println(linea);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Muy eficiente</li> <li>\u2705 Ideal para lectura l\u00ednea a l\u00ednea</li> </ul>"},{"location":"ud1/characterfiles/#escritura-de-texto-javaio","title":"\u270d\ufe0f Escritura de texto (<code>java.io</code>)","text":""},{"location":"ud1/characterfiles/#1-filewriter","title":"1. <code>FileWriter</code>","text":"<pre><code>try (FileWriter fw = new FileWriter(\"salida.txt\")) {\nfw.write(\"Hola mundo\\n\");\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Adecuado para ejemplos sencillos o pruebas</li> <li>\u274c Menos eficiente que <code>BufferedWriter</code>. No aporta un buffer grande de caracteres como BufferedWriter. Pero si tiene un buffer/cach\u00e9 del sistema operativo y un buffer de codificaci\u00f3n interno (con OutputStreamWriter), que puede retener bytes.     </li> <li>Sin close()/flush(), no garantizas que todo lo escrito haya salido de esos buffers hacia el fichero.  </li> <li>Al salir del try-with-resources, se ejecuta autom\u00e1ticamente <code>fw.close()</code>, que internamente hace un flush() \u2192 ah\u00ed se asegura que todo lo que estaba en memoria s\u00ed se escriba en el fichero.</li> </ul>"},{"location":"ud1/characterfiles/#2-bufferedwriter","title":"2. <code>BufferedWriter</code>","text":"<pre><code>try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"salida.txt\"))) {\nbw.write(\"Hola mundo\");\nbw.newLine();\nbw.write(\"Otra l\u00ednea\");\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Escritura m\u00e1s r\u00e1pida y controlada. Mantiene un buffer m\u00e1s grande en memoria.   </li> <li>Solo cuando el buffer se llena o haces flush()/close() escribe en disco.      </li> </ul>"},{"location":"ud1/characterfiles/#3-printwriter","title":"3. <code>PrintWriter</code>","text":"<pre><code>try (PrintWriter pw = new PrintWriter(\"log.txt\")) {\npw.println(\"Inicio del log\");\npw.printf(\"Valor: %.2f\", 12.345);\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Permite formateo avanzado de texto</li> </ul>"},{"location":"ud1/characterfiles/#operaciones-con-javaniofilefiles","title":"\ud83d\uddc2\ufe0f Operaciones con <code>java.nio.file.Files</code>","text":""},{"location":"ud1/characterfiles/#lectura-de-texto-javanio","title":"\ud83d\udce5 Lectura de texto (<code>java.nio</code>)","text":""},{"location":"ud1/characterfiles/#1-filesreadalllines","title":"1. <code>Files.readAllLines()</code>","text":"<pre><code>Path ruta = Paths.get(\"entrada.txt\");\nList&lt;String&gt; lineas = Files.readAllLines(ruta);\n</code></pre> <ul> <li>\u2705 Muy c\u00f3modo para archivos peque\u00f1os o medianos</li> <li>\u26a0\ufe0f Carga todo a memoria</li> </ul>"},{"location":"ud1/characterfiles/#2-fileslines-stream","title":"2. <code>Files.lines()</code> (stream)","text":"<p>Devuelve un Stream de l\u00edneas, \u00fatil para procesar ficheros grandes. No carga todo el fichero en memoria de golpe. Va leyendo l\u00ednea a l\u00ednea bajo demanda, a medida que el stream se consume.</p> <pre><code>try (Stream&lt;String&gt; lineas = Files.lines(Paths.get(\"entrada.txt\"))) {\nlineas.forEach(System.out::println);\n}\n</code></pre> <ul> <li>\u2705 No carga todo en memoria: lectura perezosa (lazy), ideal para ficheros grandes</li> <li>\u2705 Puedes usar operaciones con Stream (<code>filter</code>, <code>map</code>, etc.), filtros y transformaciones</li> <li>\u2705 Devuelve un Stream que est\u00e1 respaldado por un BufferedReader interno. <li>\u26a0\ufe0f Necesita <code>try-with-resources</code> porque abre un recurso</li>"},{"location":"ud1/characterfiles/#3-filesreadstring-java-11","title":"3. <code>Files.readString()</code> (Java 11+)","text":"<pre><code>try {\nString contenido = Files.readString(Paths.get(\"entrada.txt\"));\nSystem.out.println(contenido);\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Ideal si necesitas todo el contenido como una sola cadena</li> <li>\u2705 Muy simple y directo</li> <li>\u26a0\ufe0f Carga todo a memoria</li> </ul>"},{"location":"ud1/characterfiles/#4-filesnewbufferedreader","title":"4. <code>Files.newBufferedReader()</code>","text":"<pre><code>try (BufferedReader br = Files.newBufferedReader(Paths.get(\"entrada.txt\"))) {\nString linea;\nwhile ((linea = br.readLine()) != null) {\nSystem.out.println(linea);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Lectura eficiente sin necesidad de envolver <code>FileReader</code></li> <li>\u2705 Permite pasar <code>Charset</code> como segundo argumento opcional, lo cual es \u00fatil si quieres controlar la codificaci\u00f3n del texto (por ejemplo, UTF-8, ISO-8859-1, etc.)</li> </ul>"},{"location":"ud1/characterfiles/#escritura-de-texto-javanio","title":"\u270d\ufe0f Escritura de texto (<code>java.nio</code>)","text":""},{"location":"ud1/characterfiles/#1-fileswriteliststring","title":"1. <code>Files.write(List&lt;String&gt;)</code>","text":"<p>Sobrescribe por defecto el texto si no pasas opciones como <code>StandardOpenOption.APPEND</code>.</p> <pre><code>List&lt;String&gt; contenido = List.of(\"L\u00ednea 1\", \"L\u00ednea 2\");\nFiles.write(Paths.get(\"salida.txt\"), contenido);\n//otra opci\u00f3n para no sobrescribir el texto\nFiles.write(Paths.get(\"salida.txt\"), contenido, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n</code></pre> <ul> <li>\u2705 F\u00e1cil de usar, sobrescribe por defecto</li> <li>\u2705 Codificaci\u00f3n UTF-8 por defecto</li> <li>\u26a0\ufe0f Carga todo en memoria</li> </ul>"},{"location":"ud1/characterfiles/#2-fileswritestring-java-11","title":"2. <code>Files.writeString()</code> (Java 11+)","text":"<pre><code>try {\nFiles.writeString(Paths.get(\"salida.txt\"), \"Texto de ejemplo\");\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Muy c\u00f3modo para una sola cadena</li> <li>\u2705 Puedes pasar un <code>Charset</code></li> <li>\u26a0\ufe0f Carga todo en memoria</li> </ul>"},{"location":"ud1/characterfiles/#3-filesnewbufferedwriter","title":"3. <code>Files.newBufferedWriter()</code>","text":"<pre><code>try (BufferedWriter bw = Files.newBufferedWriter(Paths.get(\"salida.txt\"))) {\nbw.write(\"Primera l\u00ednea\\nSegunda l\u00ednea\");\nbw.newLine();  // salto de l\u00ednea\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>\u2705 Similar a <code>BufferedWriter</code>, pero m\u00e1s moderno y flexible</li> <li>\u2705 Permite pasar <code>Charset</code> como segundo argumento opcional, lo cual es \u00fatil si quieres controlar la codificaci\u00f3n del texto (por ejemplo, UTF-8, ISO-8859-1, etc.)</li> </ul>"},{"location":"ud1/characterfiles/#tabla-resumen-que-clase-usar-segun-la-situacion","title":"\ud83e\udde0 Tabla resumen: \u00bfQu\u00e9 clase usar seg\u00fan la situaci\u00f3n?","text":"Herramienta \u00bfCu\u00e1ndo usarla? \u00bfBuffer incluido? \u00bfRequiere cerrar? Comentario <code>BufferedReader</code> / <code>BufferedWriter</code> Lectura/escritura eficiente de texto l\u00ednea a l\u00ednea \u2705 S\u00ed \u2705 S\u00ed Ideal para logs o lectura l\u00ednea a l\u00ednea <code>PrintWriter</code> Cuando necesitas imprimir texto con formato \u2705 S\u00ed \u2705 S\u00ed Ofrece m\u00e9todos print/println/printf <code>FileReader</code> / <code>FileWriter</code> Acceso directo a caracteres, sin buffer \u274c No \u2705 S\u00ed Puede ser ineficiente si no se envuelve <code>Files.readAllLines()</code> Lectura sencilla si el archivo es peque\u00f1o o mediano \u274c No \u274c No Devuelve <code>List&lt;String&gt;</code> <code>Files.lines()</code> Lectura de grandes archivos como <code>Stream&lt;String&gt;</code> \u2705 S\u00ed \u2705 S\u00ed Lectura perezosa, se debe cerrar el stream <code>Files.readString()</code> Lectura completa como cadena (Java 11+) \u274c No \u274c No Muy c\u00f3modo si necesitas todo el texto <code>Files.newBufferedReader()</code> Lectura eficiente con Charset opcional \u2705 S\u00ed \u2705 S\u00ed Alternativa moderna a <code>BufferedReader</code> <code>Files.write(List)</code> Escritura r\u00e1pida de texto si ya tienes las l\u00edneas \u274c No \u274c No Simple y c\u00f3modo <code>Files.writeString()</code> Escritura de cadena completa (Java 11+) \u274c No \u274c No Muy directo y moderno <code>Files.newBufferedWriter()</code> Escritura eficiente y configurable \u2705 S\u00ed \u2705 S\u00ed Permite especificar codificaci\u00f3n"},{"location":"ud1/characterfiles/#recomendaciones","title":"\u2705 Recomendaciones","text":"<ul> <li>Usa <code>BufferedReader</code> / <code>BufferedWriter</code> cuando leas o escribas muchas l\u00edneas.</li> <li>Usa <code>Files.readAllLines()</code> o <code>Files.write()</code> para tareas sencillas y ficheros peque\u00f1os.</li> <li>Usa <code>Files.lines()</code> para procesar ficheros grandes sin cargarlos enteros a memoria.</li> <li>Usa <code>PrintWriter</code> si necesitas formatear tu salida con precisi\u00f3n.</li> <li>Usa <code>Files.readString()</code> y <code>Files.writeString()</code> si trabajas con cadenas completas (Java 11+).</li> <li>Usa <code>Files.newBufferedReader()</code> y <code>Files.newBufferedWriter()</code> si quieres un enfoque moderno con control de codificaci\u00f3n.</li> </ul>"},{"location":"ud1/createjar/","title":"C\u00f3mo crear un jar en IntelliJ","text":"<ol> <li>Vamos a File --&gt; Project Structure</li> </ol> <ol> <li>En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --&gt; \"From modules with dependencies\"</li> </ol> <ol> <li>Le decimos cu\u00e1l es la clase main y aceptamos.</li> </ol> <ol> <li>Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --&gt; \"Build Artifact\".</li> </ol> <ol> <li>Seleccionamos \"Build\".</li> </ol> <p>El .jar estar\u00e1 en la carpeta del proyecto dentro de /out/artifacts/...</p>"},{"location":"ud1/fileswalk/","title":"\ud83d\udcc1 Recorrido de directorios con Java NIO","text":"<p>En esta p\u00e1gina exploramos las distintas formas modernas de recorrer directorios utilizando la API java.nio.file.</p>"},{"location":"ud1/fileswalk/#por-que-usar-javanio-para-recorrer-directorios","title":"\ud83d\udccc \u00bfPor qu\u00e9 usar java.nio para recorrer directorios?","text":"<p>Java NIO ofrece una forma m\u00e1s moderna, flexible y funcional de acceder a ficheros y directorios, evitando la necesidad de estructuras cl\u00e1sicas m\u00e1s verbosas como <code>File</code>.</p> <p>Sus ventajas:</p> <ul> <li>Uso de streams para trabajar con los ficheros como flujos de datos.</li> <li>Posibilidad de aplicar filtros y operaciones funcionales.</li> <li>Facilidad para recorrer subdirectorios.</li> <li>Mejor manejo de excepciones.</li> </ul>"},{"location":"ud1/fileswalk/#metodos-principales-de-recorrido","title":"\ud83d\udcda M\u00e9todos principales de recorrido","text":""},{"location":"ud1/fileswalk/#fileslistpath","title":"\u2705 <code>Files.list(Path)</code>","text":"<ul> <li>Lista solo los archivos y carpetas de primer nivel.</li> <li>Devuelve un <code>Stream&lt;Path&gt;</code>.</li> <li>\u26a0\ufe0f No entra en subdirectorios.</li> </ul> <pre><code>try (Stream&lt;Path&gt; stream = Files.list(Paths.get(\"miDirectorio\"))) {\nstream.forEach(System.out::println);\n}\n</code></pre>"},{"location":"ud1/fileswalk/#fileswalkpath","title":"\u2705 <code>Files.walk(Path)</code>","text":"<ul> <li>Recorre recursivamente todos los subdirectorios.</li> <li>Devuelve un <code>Stream&lt;Path&gt;</code>.</li> <li>Admite profundidad m\u00e1xima opcional.</li> </ul> <pre><code>try (Stream&lt;Path&gt; stream = Files.walk(Paths.get(\"miDirectorio\"))) {\nstream.forEach(System.out::println);\n}\n</code></pre> <p>El m\u00e9todo walk contempla un segundo argumento, para limitar la profundidad:</p> <pre><code>Files.walk(Paths.get(\"miDirectorio\"), 2)\n</code></pre>"},{"location":"ud1/fileswalk/#filesfindpath-int-bipredicate","title":"\u2705 <code>Files.find(Path, int, BiPredicate)</code>","text":"<ul> <li>Recorre recursivamente con filtros personalizados.</li> <li>\ud83d\udd0d Permite especificar una funci\u00f3n lambda como predicado que se puede usar para buscar por nombre, tama\u00f1o, tipo, fechas, etc.</li> </ul> <pre><code>try (Stream&lt;Path&gt; stream = Files.find(\nPaths.get(\"miDirectorio\"),\nInteger.MAX_VALUE,\n(path, attr) -&gt; attr.isRegularFile() &amp;&amp; path.toString().endsWith(\".txt\")\n)) {\nstream.forEach(System.out::println);\n}\n</code></pre>"},{"location":"ud1/fileswalk/#filesnewdirectorystreampath","title":"\u2705 <code>Files.newDirectoryStream(Path)</code>","text":"<ul> <li>M\u00e9todo cl\u00e1sico de NIO para recorrer directorios de un solo nivel.</li> <li>Devuelve un <code>DirectoryStream&lt;Path&gt;</code> que se puede recorrer con un bucle <code>for</code>.</li> <li>Consume poca memoria y permite aplicar filtros.</li> </ul> <pre><code>try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(Paths.get(\"miDirectorio\"))) {\nfor (Path path : stream) {\nSystem.out.println(path);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <p>Tambi\u00e9n permite usar un filtro directamente:</p> <pre><code>try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(Paths.get(\"miDirectorio\"), \"*.java\")) {\nfor (Path path : stream) {\nSystem.out.println(path);\n}\n}\n</code></pre>"},{"location":"ud1/fileswalk/#tabla-comparativa-de-metodos","title":"\ud83e\uddf2 Tabla comparativa de m\u00e9todos","text":"M\u00e9todo Recursivo Permite filtrar Devuelve Comentario \u00fatil <code>Files.list()</code> \u274c No \u26a0\ufe0f No directo <code>Stream&lt;Path&gt;</code> R\u00e1pido para listar ra\u00edz <code>Files.walk()</code> \u2705 S\u00ed \u2705 S\u00ed <code>Stream&lt;Path&gt;</code> Perfecto para \u00e1rboles de carpetas <code>Files.find()</code> \u2705 S\u00ed \u2705 Muy flexible <code>Stream&lt;Path&gt;</code> Potente para b\u00fasquedas personalizadas <code>Files.newDirectoryStream()</code> \u274c No \u2705 S\u00ed <code>DirectoryStream&lt;Path&gt;</code> Alternativa cl\u00e1sica y eficiente"},{"location":"ud1/fileswalk/#recomendacion-final","title":"\ud83d\udcce Recomendaci\u00f3n final","text":"<p>Usa: - <code>Files.list()</code> si solo necesitas el contenido directo del directorio - <code>Files.walk()</code> si necesitas recorrer subdirectorios - <code>Files.find()</code> si quieres aplicar condiciones de b\u00fasqueda - <code>DirectoryStream</code> si prefieres no usar streams o necesitas menor consumo</p>"},{"location":"ud1/fileswalk/#uso-de-try-with-resources","title":"\ud83e\udde0 USO de <code>try-with-resources</code>","text":"<p>Los m\u00e9todos anteriores devuelven objetos que abren recursos del sistema, como descriptores de directorios. </p> <p>Si no los cierras correctamente, puedes provocar: - Fugas de memoria - Archivos bloqueados - Excepciones en sistemas como Windows</p> <p>\ud83d\udd12 Por eso se recomienda SIEMPRE usarlos con <code>try-with-resources</code>, incluso aunque Java no te lo exija.</p>"},{"location":"ud1/filevsfiles/","title":"\ud83d\udcc1 Gesti\u00f3n de ficheros con Java","text":""},{"location":"ud1/filevsfiles/#ficheros","title":"Ficheros","text":"<p>Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.</p> <pre><code>../Ada/Ejemplo/src/Main.java                --&gt; Ruta relativa\nc:\\User\\Patricia\\Ada\\Ejemplo\\src\\Main.java  --&gt; Ruta absoluta\n</code></pre>"},{"location":"ud1/filevsfiles/#javaio-vs-javanio","title":"\ud83d\udd70\ufe0f <code>java.io</code> vs <code>java.nio</code>","text":"<p>Java ofrece varias formas de trabajar con archivos y directorios. A lo largo del tiempo, el lenguaje ha ido evolucionando:</p> <ul> <li> <p><code>java.io</code> fue la primera API de entrada/salida. Apareci\u00f3 con Java 1.0 (en 1996) y ofrec\u00eda clases como <code>File</code>, <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, <code>Writer</code>, etc. Permit\u00eda hacer operaciones b\u00e1sicas, pero de forma limitada y poco robusta.</p> </li> <li> <p><code>java.nio</code> (New Input/Output) se introdujo en Java 1.4 (2002), y se ampli\u00f3 con el paquete <code>java.nio.file</code> en Java 7 (2011). Esta nueva API ofrece clases modernas como <code>Path</code>, <code>Files</code> o <code>DirectoryStream</code>, y un enfoque m\u00e1s seguro y potente para trabajar con el sistema de archivos.</p> </li> </ul>"},{"location":"ud1/filevsfiles/#cual-usar-y-por-que","title":"\u26a0\ufe0f \u00bfCu\u00e1l usar y por qu\u00e9?","text":"<p>Aunque <code>java.io.File</code> a\u00fan funciona, tiene muchas limitaciones. Por eso recomendamos usar <code>java.nio.file</code> siempre que sea posible.</p> <ul> <li>Mejor gesti\u00f3n de errores (lanzando excepciones con mensajes \u00fatiles)</li> <li>Soporte para rutas absolutas, relativas y enlaces simb\u00f3licos</li> <li>M\u00e9todos directos para copiar, mover, borrar o leer archivos</li> <li>M\u00e1s control y modularidad</li> </ul> <p>En esta unidad aprender\u00e1s directamente a usar <code>java.nio.file</code>, pero tambi\u00e9n conocer\u00e1s brevemente las limitaciones de <code>java.io.File</code> para que puedas comparar y entender por qu\u00e9 hoy se considera una API anticuada.</p>"},{"location":"ud1/filevsfiles/#que-hay-dentro-de-javaio","title":"\ud83d\udcc2 \u00bfQu\u00e9 hay dentro de <code>java.io</code>?","text":"<p>El paquete <code>java.io</code> es uno de los m\u00e1s antiguos de Java, e incluye clases para:</p>"},{"location":"ud1/filevsfiles/#1-entradasalida-en-archivos","title":"1. Entrada/salida en archivos","text":"<ul> <li><code>File</code> \u2192 representa rutas de archivos/directorios</li> <li><code>FileInputStream</code>, <code>FileOutputStream</code> \u2192 lectura/escritura en binario</li> <li><code>FileReader</code>, <code>FileWriter</code> \u2192 lectura/escritura en texto</li> </ul>"},{"location":"ud1/filevsfiles/#2-lecturaescritura-con-buffers","title":"2. Lectura/escritura con buffers","text":"<ul> <li><code>BufferedReader</code>, <code>BufferedWriter</code></li> <li><code>BufferedInputStream</code>, <code>BufferedOutputStream</code></li> </ul>"},{"location":"ud1/filevsfiles/#3-serializacion","title":"3. Serializaci\u00f3n","text":"<ul> <li><code>ObjectInputStream</code>, <code>ObjectOutputStream</code></li> <li><code>Serializable</code> (interfaz)</li> </ul>"},{"location":"ud1/filevsfiles/#4-comunicacion-entre-procesos","title":"4. Comunicaci\u00f3n entre procesos","text":"<ul> <li><code>PipedInputStream</code>, <code>PipedOutputStream</code></li> <li><code>PipedReader</code>, <code>PipedWriter</code></li> </ul>"},{"location":"ud1/filevsfiles/#5-flujos-abstractos","title":"5. Flujos abstractos","text":"<ul> <li><code>InputStream</code>, <code>OutputStream</code> (abstractas)</li> <li><code>Reader</code>, <code>Writer</code> (abstractas)</li> </ul>"},{"location":"ud1/filevsfiles/#6-otros","title":"6. Otros","text":"<ul> <li><code>PrintWriter</code>, <code>PrintStream</code></li> <li><code>IOException</code>, <code>EOFException</code>, <code>FileNotFoundException</code>, etc.</li> </ul>"},{"location":"ud1/filevsfiles/#crear-un-objeto-file","title":"\ud83d\udcc2 Crear un objeto File","text":"<p><pre><code>File f = new File(\"C:\\\\Users\\\\temp\\\\data.txt\");\n</code></pre> Un objeto <code>File</code> NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo.</p>"},{"location":"ud1/filevsfiles/#curiosidad-didactica","title":"\ud83e\udde0 Curiosidad did\u00e1ctica","text":"<ul> <li><code>java.io</code> es una gran colecci\u00f3n de clases que forman parte del n\u00facleo de Java desde sus inicios.</li> <li>Muchas de ellas son abstractas o extensibles, pensadas para que puedas combinarlas (por ejemplo: envolver un <code>FileReader</code> con un <code>BufferedReader</code>).</li> <li>Aunque hoy en d\u00eda muchas tareas se pueden hacer mejor con <code>java.nio</code>, algunas de estas clases a\u00fan tienen utilidad complementaria, sobre todo en flujos de texto o para serializaci\u00f3n b\u00e1sica.</li> </ul>"},{"location":"ud1/filevsfiles/#que-hay-dentro-de-javaniofile","title":"\ud83d\udcc2 \u00bfQu\u00e9 hay dentro de <code>java.nio.file</code>?","text":"<p>El paquete <code>java.nio.file</code> fue introducido en Java 7 y es parte de la API moderna para trabajar con rutas, archivos y directorios de forma segura y eficiente.</p>"},{"location":"ud1/filevsfiles/#clases-principales","title":"\ud83d\udd27 Clases principales","text":"<ul> <li><code>Path</code>   Representa una ruta (ya sea de un archivo o un directorio) de forma independiente del sistema operativo. Ejemplo:</li> </ul> <pre><code>Path ruta = Path.of(\"archivos/ejemplo.txt\");\n</code></pre> <ul> <li> <p><code>Paths</code>   Clase auxiliar que se usa para construir objetos <code>Path</code> a partir de una cadena de texto.</p> </li> <li> <p><code>Files</code>   Clase con m\u00e9todos est\u00e1ticos para operar directamente sobre archivos y carpetas: crear, borrar, copiar, mover, leer y escribir.</p> </li> <li> <p><code>DirectoryStream</code>   Permite recorrer el contenido de un directorio como si fuera una colecci\u00f3n. Es seguro y compatible con <code>try-with-resources</code>.</p> </li> </ul>"},{"location":"ud1/filevsfiles/#operaciones-basicas-con-ficheros","title":"\ud83d\udee0\ufe0f Operaciones b\u00e1sicas con ficheros","text":"<ul> <li>Crear un objeto Path que representa la ruta relativa al fichero nota.txt, dentro del directorio documentos. Si nota.txt no existe no falla, Paths.get(...) solo crea un objeto Path, es decir, una representaci\u00f3n en memoria de una ruta. No comprueba si existe ni intenta acceder al fichero. <pre><code>Path archivo = Paths.get(\"documentos/nota.txt\");\n</code></pre></li> </ul> <p>Warning</p> <p>\u2757Importante: Esto NO crea el fichero f\u00edsicamente. Solo est\u00e1s creando una referencia l\u00f3gica en Java que apunta a esa ruta.</p> <ul> <li>Comprobar si existe un fichero:</li> </ul> <pre><code>boolean exists = Files.exists(archivo);\n</code></pre> <ul> <li>Crear un archivo. Devuelve la ruta del fichero creado:</li> </ul> <pre><code>Path newFile = Files.createFile(archivo);\n</code></pre> <ul> <li>Borrar un fichero:</li> </ul> <pre><code>Files.delete(archivo);\n</code></pre> <ul> <li>Copiar un fichero. Devuelve la ruta del fichero copiado:</li> </ul> <pre><code>Path copiedFile = Files.copy(archivo, Paths.get(\"copia.txt\"), StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <ul> <li>Mover (o renombrar) un fichero. Devuelve la ruta del fichero movido:</li> </ul> <pre><code>Path movedFile = Files.move(archivo, Paths.get(\"nuevos/nota.txt\"), StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <ul> <li>Devolver el tama\u00f1o en bytes del fichero representado por Path:</li> </ul> <p><pre><code>Path path = Path.of(\"fichero.txt\");\nlong tama\u00f1o = Files.size(path);\n</code></pre> Si el path apunta a un fichero, devuelve el tama\u00f1o del contenido del fichero. Si el path apunta a un directorio, lanza una excepci\u00f3n (IOException o AccessDeniedException), ya que NO SE PUEDE MEDIR EL TAMA\u00d1O DE UN DIRECTORIO.</p>"},{"location":"ud1/filevsfiles/#operaciones-basicas-con-directorios","title":"\ud83d\udcc1 Operaciones b\u00e1sicas con directorios","text":"<ul> <li>Paths.get es un m\u00e9todo est\u00e1tico que crea un objeto de tipo Path. En este caso, crea una ruta relativa al directorio actual con el nombre \"nuevaCarpeta\".: <pre><code>Path carpeta = Paths.get(\"nuevaCarpeta\");\n</code></pre></li> </ul> <p>Warning</p> <p>\u00bfLa carpeta existe? No necesariamente. Esta l\u00ednea solo crea la representaci\u00f3n de la ruta como objeto Path, pero no crea la carpeta en el sistema de archivos.</p> <ul> <li>Crear un directorio. Devuelve la ruta del nuevo directorio creado:</li> </ul> <pre><code>Path newDir = Files.createDirectory(carpeta);\n</code></pre> <ul> <li>Crear varios directorios anidados. Devuelve la ruta del \u00faltimo directorio creado:</li> </ul> <pre><code>Path lastNewDir = Files.createDirectories(Paths.get(\"usuarios/admin/documentos\"));\n</code></pre> <p>Warning</p> <p>Crea todos los directorios necesarios en la ruta dada, si no existen. Si ya existen, NO lanza excepci\u00f3n. Si no especificas una ruta absoluta, se crean en el directorio actual. El ejemplo crear\u00e1 una ruta compuesta por 3 directorios: usuarios/ usuarios/admin/ usuarios/admin/documentos/</p> <ul> <li>Listar el contenido de un directorio. Abre un flujo (DirectoryStream) con todos los elementos (ficheros y subdirectorios) que contiene la ruta especificada. No es recursivo (no entra dentro de subdirectorios): <pre><code>try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(Path.of(\"/home\"))) {\nfor (Path archivo : stream) {\nSystem.out.println(archivo.getFileName());\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre> <ul> <li>Comprobar si una ruta es un directorio:</li> </ul> <pre><code>boolean isDir = Files.isDirectory(carpeta);\n</code></pre>"},{"location":"ud1/filevsfiles/#vista-general-de-javaio","title":"\ud83d\uddbc\ufe0f Vista general de <code>java.io</code>","text":"<p>La siguiente imagen muestra la jerarqu\u00eda de clases dentro del paquete <code>java.io</code>:</p> <p></p>"},{"location":"ud1/filevsfiles/#vista-general-de-javaniofile","title":"\ud83d\uddbc\ufe0f Vista general de <code>java.nio.file</code>","text":"<p>La siguiente imagen muestra las clases m\u00e1s importantes dentro de <code>java.nio.file</code>:</p> <p></p>"},{"location":"ud1/filevsfiles/#comparativa-entre-javaiofile-y-javaniofile","title":"\ud83c\udd9a Comparativa entre <code>java.io.File</code> y <code>java.nio.file</code>","text":"Funcionalidad <code>java.io.File</code> (limitada) <code>java.nio.file</code> (moderna) Crear archivo <code>file.createNewFile()</code>\u274c Devuelve <code>false</code>, sin detalles <code>Files.createFile(path)</code>\u2705 Lanza excepci\u00f3n \u00fatil Comprobar si existe <code>file.exists()</code> <code>Files.exists(path)</code> Crear directorio <code>file.mkdir()</code> <code>Files.createDirectory(path)</code> Listar archivos <code>file.listFiles()</code>\u274c Devuelve <code>null</code> si falla <code>DirectoryStream&lt;Path&gt;</code>\u2705 M\u00e1s controlado Eliminar archivo <code>file.delete()</code>\u274c Devuelve <code>false</code> <code>Files.delete(path)</code>\u2705 Con control de errores Copiar/Mover archivos \u274c No se puede directamente \u2705 <code>Files.copy()</code>, <code>Files.move()</code> Leer archivo completo \u274c Necesita bucles y buffers \u2705 <code>Files.readAllLines(path)</code> Manejo de errores \u274c Poca informaci\u00f3n \u2705 Lanza excepciones claras"},{"location":"ud1/filevsfiles/#buenas-practicas-con-javaniofile","title":"\u2705 Buenas pr\u00e1cticas con <code>java.nio.file</code>","text":"<ul> <li>Usa <code>try-catch</code> para manejar excepciones como <code>IOException</code>.</li> <li>Si abres un recurso que debe cerrarse (como un <code>DirectoryStream</code>), usa <code>try-with-resources</code>. Recursos se refiere a objetos como streams, buffers, o lectores que ocupan memoria activa del sistema operativo.</li> <li>Divide tu c\u00f3digo en m\u00e9todos peque\u00f1os y reutilizables para mantenerlo limpio.</li> <li>Comenta el c\u00f3digo si haces operaciones delicadas (como borrar o mover archivos).</li> <li>Siempre verifica si los archivos o directorios existen antes de operar sobre ellos.</li> <li>Usa REPLACE_EXISTING en copias o movimientos si quieres sobreescribir.</li> </ul>"},{"location":"ud1/io/","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n","text":"<p>Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream).</p> <p></p> <p>Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa.</p>"},{"location":"ud1/io/#formas-de-acceso-a-un-fichero-en-java","title":"\ud83d\udee3\ufe0f Formas de acceso a un fichero en Java","text":"<p>Java permite trabajar con ficheros de distintas formas, dependiendo de lo que queramos hacer con ellos. Las principales son:</p> Forma de acceso Descripci\u00f3n Ventajas principales Acceso secuencial Se accede al fichero de principio a fin, en orden. Simple, eficiente para leer o escribir de forma lineal. Ideal para archivos de texto. Acceso aleatorio Permite posicionarse en cualquier parte del archivo. \u00datil cuando se necesita modificar o consultar partes concretas. M\u00e1s complejo. Lectura completa en memoria Se lee todo el contenido del archivo y se guarda en una estructura (por ejemplo, una lista de l\u00edneas). Muy c\u00f3modo para trabajar, pero no recomendado si el archivo es muy grande."},{"location":"ud1/io/#que-significa-acceso-secuencial","title":"\ud83d\udcdd \u00bfQu\u00e9 significa acceso secuencial?","text":"<p>Significa que el archivo se lee o escribe de principio a fin. No se puede saltar directamente a una posici\u00f3n concreta, sino que hay que recorrerlo.</p> <p>Ejemplo: <code>BufferedReader</code>, <code>BufferedWriter</code>, <code>Files.newBufferedReader()</code>, <code>Files.write()</code>...</p>"},{"location":"ud1/io/#y-acceso-aleatorio","title":"\ud83e\udded \u00bfY acceso aleatorio?","text":"<p>Significa que puedes moverte a cualquier parte del archivo (por ejemplo, al byte 250) y empezar a leer o escribir desde ah\u00ed.</p> <p>Ejemplo: <code>RandomAccessFile</code> (lo veremos m\u00e1s adelante).</p>"},{"location":"ud1/io/#y-leerlo-todo-de-golpe","title":"\u26a1 \u00bfY leerlo todo de golpe?","text":"<p>A veces quieres leer un archivo peque\u00f1o entero, por ejemplo:</p> <pre><code>List&lt;String&gt; lineas = Files.readAllLines(Paths.get(\"archivo.txt\"));\n</code></pre>"},{"location":"ud1/io/#tipos-de-flujos-en-java-binarios-vs-caracteres","title":"\ud83d\udd04 Tipos de flujos en Java: Binarios vs Caracteres","text":"<p>Cuando trabajamos con ficheros en Java, es importante entender qu\u00e9 tipo de datos estamos leyendo o escribiendo. Esto influye en el tipo de flujo (stream) que debemos usar. Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. </p> <p>Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams). Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\".</p> <p>Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto.</p>"},{"location":"ud1/io/#flujos-binarios-byte-streams","title":"\ud83d\udce6 Flujos binarios (byte streams)","text":"<ul> <li>Usados para leer o escribir datos en formato binario (im\u00e1genes, v\u00eddeos, ficheros PDF, etc.).</li> <li>No interpretan el contenido como texto, sino como bytes puros.</li> </ul> <p>Clases t\u00edpicas: - <code>InputStream</code> (abstracta)   - <code>FileInputStream</code>   - <code>BufferedInputStream</code> - <code>OutputStream</code> (abstracta)   - <code>FileOutputStream</code>   - <code>BufferedOutputStream</code></p>"},{"location":"ud1/io/#flujos-de-caracteres","title":"\ud83d\udd24 Flujos de caracteres","text":"<p>Usados para trabajar con texto (ficheros .txt, .csv, .xml...). Est\u00e1n optimizados para datos de caracteres.</p> <p>Interpretan los datos usando una codificaci\u00f3n de caracteres (como UTF-8).</p> <p>Clases t\u00edpicas: - <code>Reader</code> (abstracta)   - <code>FileReader</code>   - <code>BufferedReader</code> - <code>Writer</code> (abstracta)   - <code>FileWriter</code>   - <code>BufferedWriter</code></p> <p>La siguiente figura muestra la jerarqu\u00eda del paquete <code>java.io</code>:</p> <p></p>"},{"location":"ud1/io/#resumen-de-flujos-en-java","title":"\ud83d\udccb Resumen de flujos en Java","text":"Forma de acceso Descripci\u00f3n breve \u00bfCu\u00e1ndo usarla? Clases m\u00e1s importantes Basado en rutas (<code>File</code>, <code>Path</code>) Trabaja con rutas de ficheros y directorios, sin leer ni escribir contenido. Para comprobar si existe, crear carpetas, borrar archivos, mover, copiar... <code>File</code>, <code>Path</code>, <code>Paths</code>, <code>Files</code> Flujos binarios Trabajan con bytes. Adecuado para im\u00e1genes, audio, datos binarios sin formato. Cuando se manejan archivos no de texto o binarios puros <code>InputStream</code>, <code>OutputStream</code>, <code>FileInputStream</code>, <code>FileOutputStream</code> Flujos de caracteres Trabajan con texto. Se basan en caracteres Unicode. Lectura y escritura de archivos <code>.txt</code>, <code>.csv</code>, <code>.json</code>, etc. <code>Reader</code>, <code>Writer</code>, <code>FileReader</code>, <code>FileWriter</code>, <code>BufferedReader</code>, <code>BufferedWriter</code> NIO.2 (<code>java.nio.file</code>) API moderna desde Java 7. M\u00e1s robusta, segura, con mejor gesti\u00f3n de errores. Siempre que puedas. Sustituye a muchas tareas antiguas de <code>java.io</code> <code>Files</code>, <code>Path</code>, <code>Paths</code>, <code>DirectoryStream</code> Acceso aleatorio Permite leer y escribir en cualquier parte del archivo sin recorrerlo todo. Para editar partes espec\u00edficas de archivos grandes <code>RandomAccessFile</code>"},{"location":"ud1/jsonfiles/","title":"\ud83e\uddfe Ficheros JSON en Java","text":"<p>En esta secci\u00f3n nos centraremos en trabajar con ficheros JSON (JavaScript Object Notation) como formato ligero de intercambio de datos en Java. Aunque existen otros como XML o YAML, JSON es el est\u00e1ndar actual en la mayor\u00eda de APIs por su simplicidad, legibilidad y facilidad de uso.</p>"},{"location":"ud1/jsonfiles/#por-que-centrarnos-en-json","title":"\u2705 \u00bfPor qu\u00e9 centrarnos en JSON?","text":"<ul> <li>Es ligero, legible y f\u00e1cil de generar.</li> <li>Tiene soporte nativo en la mayor\u00eda de lenguajes de programaci\u00f3n.</li> <li>Es ampliamente usado en servicios web y APIs REST.</li> <li>Hay muchas librer\u00edas Java para leer y escribir JSON.</li> </ul>"},{"location":"ud1/jsonfiles/#estructura-de-un-json","title":"\ud83d\udce6 Estructura de un JSON","text":"<pre><code>{\n\"nombre\": \"Juan\",\n\"edad\": 30,\n\"hobbies\": [\"leer\", \"programar\", \"jugar\"],\n\"activo\": true\n}\n</code></pre> <ul> <li>Objetos: pares clave/valor delimitados por llaves <code>{}</code>.</li> <li>Arrays: listas ordenadas delimitadas por corchetes <code>[]</code>.</li> <li>Valores: cadenas, n\u00fameros, booleanos, null, objetos o arrays.</li> </ul>"},{"location":"ud1/jsonfiles/#tipos-de-datos-disponibles","title":"\ud83e\udded Tipos de datos disponibles","text":"<ol> <li>N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456</li> <li>Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\"</li> <li>Booleanos: Representan valores booleanos y pueden tener dos valores: true y false</li> <li>null: Representan el valor nulo.</li> <li>Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes.</li> <li>Objetos: Son colecciones no ordenadas de pares de la forma <code>nombre:valor</code> separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.</li> </ol>"},{"location":"ud1/jsonfiles/#ejemplo-de-fichero-json","title":"\ud83e\udde0 Ejemplo de fichero JSON","text":"<pre><code># Fichero JSON {\"web-app\": {\n\"servlet\": [   {\n\"servlet-name\": \"cofaxCDS\",\n\"servlet-class\": \"org.cofax.cds.CDSServlet\",\n\"init-param\": {\n\"configGlossary:installationAt\": \"Philadelphia, PA\",\n\"configGlossary:adminEmail\": \"p.marti2@edu.gva.es\",\n\"configGlossary:poweredBy\": \"Patricia Marti\",\n\"configGlossary:poweredByIcon\": \"/images/cofax.gif\",\n\"configGlossary:staticPath\": \"/content/static\",\n\"templateProcessorClass\": \"org.cofax.WysiwygTemplate\",\n\"templateLoaderClass\": \"org.cofax.FilesTemplateLoader\",\n\"templatePath\": \"templates\",\n\"templateOverridePath\": \"\",\n\"defaultListTemplate\": \"listTemplate.htm\",\n\"defaultFileTemplate\": \"articleTemplate.htm\",\n\"useJSP\": false,\n\"dataStoreMaxConns\": 100\n}\n},\nnull,\n{\n\"servlet-name\": \"cofaxEmail\",\n\"servlet-class\": \"org.cofax.cds.EmailServlet\",\n\"init-param\": {\n\"mailHost\": \"mail1\",\n\"mailHostOverride\": \"mail2\"\n}\n}],\n\"servlet-mapping\": {\n\"cofaxCDS\": \"/\",\n\"cofaxEmail\": \"/cofaxutil/aemail/*\",\n\"cofaxAdmin\": \"/admin/*\",\n\"fileServlet\": \"/static/*\",\n\"cofaxTools\": \"/tools/*\"\n},\n\"taglib\": {\n\"taglib-uri\": \"cofax.tld\",\n\"taglib-location\": \"/WEB-INF/tlds/cofax.tld\"\n}\n}\n}\n</code></pre> <p>El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase <code>Servlet</code>, donde la clase <code>Servlet</code> estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc.</p>"},{"location":"ud1/jsonfiles/#librerias-java-recomendadas","title":"\ud83d\udcda Librer\u00edas Java recomendadas","text":"Librer\u00eda Ventajas principales Gson Simple, ligera, de Google Jackson M\u00e1s completa, vers\u00e1til y robusta org.json Muy directa, sin anotaciones <p>A continuaci\u00f3n veremos Gson y Jackson, por ser las m\u00e1s utilizadas.</p>"},{"location":"ud1/jsonfiles/#usando-gson-google","title":"\ud83d\udd27 Usando Gson (Google)","text":"<p>Es necesario agregar la dependencia de gson al proyecto para poder usarla.</p>"},{"location":"ud1/jsonfiles/#1-crear-clase-java","title":"1. Crear clase Java","text":"<pre><code>public class Persona {\nprivate String nombre;\nprivate int edad;\nprivate List&lt;String&gt; hobbies;\nprivate boolean activo;\n// Constructor, getters y setters\n}\n</code></pre>"},{"location":"ud1/jsonfiles/#2-serializar-a-json","title":"2. Serializar a JSON","text":"<pre><code>Gson gson = new Gson();\n//si quiero imprimir el json en formato \"bonito\" (tabulado e indentado)\n/*Gson gson = new GsonBuilder()\n                .setPrettyPrinting()\n                .create();*/\nPersona p = new Persona(\"Ana\", 25, List.of(\"leer\", \"bailar\"), true);\nString json = gson.toJson(p);\nSystem.out.println(json);\n</code></pre>"},{"location":"ud1/jsonfiles/#3-deserializar-desde-json","title":"3. Deserializar desde JSON","text":"<pre><code>String entrada = \"{\\\"nombre\\\":\\\"Ana\\\",\\\"edad\\\":25,\" +\n\"\\\"hobbies\\\":[\\\"leer\\\",\\\"bailar\\\"],\\\"activo\\\":true}\";\nPersona p2 = gson.fromJson(entrada, Persona.class);\nSystem.out.println(p2.getNombre());\n</code></pre>"},{"location":"ud1/jsonfiles/#usando-jackson","title":"\ud83e\uddf0 Usando Jackson","text":"<p>Es necesario agregar la dependencia de jackson al proyecto para poder usarla.</p>"},{"location":"ud1/jsonfiles/#1-crear-clase-java_1","title":"1. Crear clase Java","text":"<pre><code>public class Persona {\nprivate String nombre;\nprivate int edad;\nprivate List&lt;String&gt; hobbies;\nprivate boolean activo;\n// Constructor, getters, setters\n}\n</code></pre>"},{"location":"ud1/jsonfiles/#2-serializar-a-json_1","title":"2. Serializar a JSON","text":"<pre><code>ObjectMapper mapper = new ObjectMapper();\nPersona p = new Persona(\"Luis\", 28, List.of(\"cine\", \"deporte\"), false);\nString json = mapper.writeValueAsString(p);\nSystem.out.println(json);\n</code></pre>"},{"location":"ud1/jsonfiles/#3-deserializar-desde-json_1","title":"3. Deserializar desde JSON","text":"<pre><code>String entrada = \"{\\\"nombre\\\":\\\"Luis\\\",\\\"edad\\\":28,\" +\n\"\\\"hobbies\\\":[\\\"cine\\\",\\\"deporte\\\"],\\\"activo\\\":false}\";\nPersona p2 = mapper.readValue(entrada, Persona.class);\nSystem.out.println(p2.getEdad());\n</code></pre>"},{"location":"ud1/jsonfiles/#comparativa-gson-vs-jackson","title":"\ud83d\udcdd Comparativa Gson vs Jackson","text":"Caracter\u00edstica Gson Jackson Curva de aprendizaje Muy sencilla Media Velocidad R\u00e1pida M\u00e1s r\u00e1pida en general Anotaciones avanzadas Limitadas Muy completas Soporte de formatos Solo JSON JSON, XML, YAML..."},{"location":"ud1/propertiesfile/","title":"\ud83d\udcd1 Ficheros de propiedades en Java","text":"<p>En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades.</p> <p>Un fichero <code>.properties</code> en Java:</p> <ul> <li>Es un fichero de texto plano con extensi\u00f3n <code>.properties</code>.</li> <li>Cada l\u00ednea contiene una pareja clave=valor.</li> <li>Los comentarios se indican con <code>#</code>.</li> <li>Se usa para parametrizar aplicaciones sin cambiar el c\u00f3digo fuente.</li> </ul> <p>Java nos proporciona la clase <code>Properties</code>, para leer de forma sencilla los ficheros de configuraci\u00f3n.</p> <p>Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado <code>datasource.properties</code>, que almacena informaci\u00f3n sobre la base de datos:</p> <p>Ejemplo: <code>datasource.properties</code></p> <pre><code># Configuraci\u00f3n de la base de datos\ndb.username=admin\ndb.password=secret\ndb.port=3306\n</code></pre>"},{"location":"ud1/propertiesfile/#cargar-propiedades-del-fichero","title":"\ud83d\udce5 Cargar propiedades del fichero","text":"<p>Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties. Este objeto ser\u00e1 el contenedor en memoria de todas las claves/valores.</p> <pre><code>Properties properties = new Properties();\n</code></pre> <p>Esta clase tiene un m\u00e9todo <code>load()</code> que permite cargar el fichero. No tenemos m\u00e1s que pasarle un <code>InputStream</code> o un <code>Reader</code> de java.</p> <pre><code>try (Reader/BufferedReader reader = Files.newBufferedReader(Paths.get(\"datasource.properties\"))) {\nproperties.load(reader); //carga el fichero en el objeto properties\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud1/propertiesfile/#leer-una-propiedad","title":"\ud83d\udcd6 Leer una propiedad","text":"<p>El m\u00e9todo <code>properties.getProperty(String)</code> nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\", obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero).</p> <p>Si la clave no existe, obtendremos <code>null</code> como resultado. Sin embargo, tenemos una variante de <code>getProperty()</code> que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo:</p> <pre><code>properties.getProperty(\"db.username\", \"default value\"));\n</code></pre> <p>Al m\u00e9todo <code>getProperty()</code> le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado.</p>"},{"location":"ud1/propertiesfile/#leer-todas-las-propiedades-cargadas","title":"\ud83d\udd01 Leer todas las propiedades cargadas","text":"<p>La clase <code>Properties</code> tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto <code>Enumeration</code> que nos permitir\u00e1 iterar sobre ellas.</p> <pre><code>Enumeration&lt;Object&gt; keys = properties.keys(); while (keys.hasMoreElements()) {\nObject key = keys.nextElement(); System.out.println(key + \" = \"+ properties.get(key));\n}\n//otra forma\nproperties.forEach((key, value) -&gt; System.out.println(key + \" = \" + value));\n</code></pre>"},{"location":"ud1/propertiesfile/#anadir-o-modificar-una-propiedad-esto-no-modifica-el-fichero","title":"\u270d\ufe0f A\u00f1adir o modificar una propiedad (esto no modifica el fichero)","text":"<p>Para a\u00f1adir/modificar el valor de una propiedad, la clase <code>Properties</code> tiene un m\u00e9todo llamado <code>setProperty(String key, String value)</code> que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente.</p> <pre><code>properties.setProperty(\"db.port\", \"4020\");\n</code></pre>"},{"location":"ud1/propertiesfile/#guardar-las-propiedades-en-el-fichero","title":"\ud83d\udce6 Guardar las propiedades en el fichero","text":"<p>Una vez que hemos modificado/a\u00f1adido propiedades, tendremos que guardarlas en el fichero. Para ello la clase <code>Properties</code> tiene dos m\u00e9todos: <code>save()</code> y <code>store()</code>. El m\u00e9todo <code>save()</code> est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a <code>store()</code> pas\u00e1ndole un <code>OutputStream</code> o un <code>Writer</code> de java.</p> <pre><code>try (Writer/BufferedWriter writer = Files.newBufferedWriter(Paths.get(\"datasource.properties\"))) {\nproperties.store(writer, \"Added database port\");\n} catch (IOException e) {\n//manejar excepci\u00f3n\n}\n</code></pre> <p>El m\u00e9todo <code>store()</code> admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero.</p>"},{"location":"ud1/randomaccessfile/","title":"\ud83d\udd01 Operaciones con ficheros de acceso aleatorio en Java","text":"<p>Los ficheros de acceso aleatorio permiten leer y escribir en cualquier posici\u00f3n del fichero, sin necesidad de recorrerlo secuencialmente desde el inicio.</p> <p>Se utilizan cuando necesitamos modificar partes concretas de un fichero sin tener que cargarlo entero a memoria. Muy usados en bases de datos, archivos binarios estructurados, etc.</p> <p>Aunque puedes guardar texto en ellos (usando por ejemplo <code>writeUTF()</code> o <code>writeChars()</code>), la clase <code>RandomAccessFile</code> escribe y lee bytes directamente y trata los datos como secuencias de bytes con posiciones concretas. Por tanto:</p> <p>Los datos no est\u00e1n codificados como texto plano (como UTF-8), sino en su representaci\u00f3n binaria interna.</p> <p>Se trabaja con int, double, char, etc., codificados en binario seg\u00fan el est\u00e1ndar de Java.</p> <p>Incluso los m\u00e9todos de texto como <code>writeUTF()</code> guardan la longitud y caracteres como bytes binarios.</p>"},{"location":"ud1/randomaccessfile/#clase-principal-randomaccessfile","title":"\ud83e\uddf0 Clase principal: <code>RandomAccessFile</code>","text":"<p>La clase <code>java.io.RandomAccessFile</code> permite acceder a cualquier parte de un fichero para leer o escribir datos. Soporta acceso de lectura y escritura, seg\u00fan el modo de apertura (<code>\"r\"</code>, <code>\"rw\"</code>, etc.).</p>"},{"location":"ud1/randomaccessfile/#modos-de-apertura","title":"\u2705 Modos de apertura","text":"Modo Descripci\u00f3n <code>\"r\"</code> Solo lectura <code>\"rw\"</code> Lectura y escritura <code>\"rws\"</code> Escritura sin buffer, sincronizaci\u00f3n inmediata <code>\"rwd\"</code> Escritura de datos (no metadatos), sin buffer"},{"location":"ud1/randomaccessfile/#escritura-y-lectura-de-datos-binarios","title":"\ud83d\udcc2 Escritura y lectura de datos binarios","text":"<pre><code>try (RandomAccessFile raf = new RandomAccessFile(\"datos.bin\", \"rw\")) {\nraf.writeInt(100);      // escribe un entero (4 bytes)\nraf.writeDouble(3.14);  // escribe un double (8 bytes)\nraf.seek(0);            // mueve el puntero al inicio\nint valor = raf.readInt();         // lee 4 bytes desde el inicio\ndouble decimal = raf.readDouble(); // lee los siguientes 8 bytes\nSystem.out.println(\"Le\u00eddo: \" + valor + \", \" + decimal);\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud1/randomaccessfile/#metodos-importantes-de-randomaccessfile","title":"\ud83d\udd0d M\u00e9todos importantes de <code>RandomAccessFile</code>","text":"M\u00e9todo Descripci\u00f3n <code>seek(long pos)</code> Mueve el puntero de lectura/escritura a la posici\u00f3n indicada <code>getFilePointer()</code> Devuelve la posici\u00f3n actual del puntero <code>length()</code> Devuelve el tama\u00f1o del fichero (en bytes) <code>setLength(long l)</code> Cambia el tama\u00f1o del fichero <code>readX()</code> / <code>writeX()</code> M\u00e9todos para leer y escribir tipos primitivos (<code>int</code>, <code>double</code>, <code>char</code>, etc.)"},{"location":"ud1/randomaccessfile/#ejemplo-modificar-un-valor-sin-tocar-el-resto","title":"\ud83d\udd04 Ejemplo: Modificar un valor sin tocar el resto","text":"<pre><code>try (RandomAccessFile raf = new RandomAccessFile(\"numeros.dat\", \"rw\")) {\nraf.writeInt(10); // pos 0\nraf.writeInt(20); // pos 4\nraf.writeInt(30); // pos 8\nraf.seek(4); // vamos a la segunda posici\u00f3n\nraf.writeInt(999); // sobrescribimos el valor 20\n} catch (IOException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud1/randomaccessfile/#puntero-de-la-clase-randomaccessfile","title":"Puntero de la clase <code>RandomAccessFile</code>","text":"<p>Un fichero de acceso aleatorio se comporta como un gran array de bytes almacenados en el sistema de archivos. Hay un puntero especial, o \u00edndice en el array impl\u00edcito, llamado file pointer (puntero de fichero). El puntero indica la posici\u00f3n actual en el fichero.</p> <p>Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir. En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero.</p> <p>Cuando se abre un <code>RandomAcessFile</code>, el puntero se establece en 0, lo que indica el inicio del fichero. Para mover el file pointer, se ejecuta el m\u00e9todo <code>seek</code>, pas\u00e1ndole un valor long, que es la posici\u00f3n en el fichero a la que deseamos movernos.</p> <p>Para obtener la posici\u00f3n del file pointer se ejecuta el m\u00e9todo <code>getFilePointer()</code>.</p> <p>Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte). Pero, dependiendo del tipo de m\u00e9todo de lectura o escritura que estemos usando, el puntero se mover\u00e1 un determinado n\u00famero de bytes cuando finalicen esas operaciones.</p> <p>Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n.</p> <p></p> <pre><code>RandomAccessFile raf = ....\nraf.seek(position); //mueve el puntero a una posici\u00f3n\nraf.seek(0); //mueve el puntero al inicio del fichero\nraf.seek(raf.length()); //mueve el puntero al final del fichero\n</code></pre>"},{"location":"ud1/randomaccessfile/#ejemplo-de-un-programa-que-anade-texto-al-final-de-un-fichero","title":"Ejemplo de un programa que a\u00f1ade texto al final de un fichero","text":"<pre><code>public static void main(String[] args) {\n//Se abre con el puntero al inicio del fichero\ntry (RandomAccessFile ra = new RandomAccessFile(\"files/file.dat\", \"rw\")) {\nra.writeUTF(\"Java\");\nra.writeChar('\\n');\nra.seek(0); //muevo el puntero al inicio del fichero\nra.seek(ra.length());//muevo el punto al final del fichero\nra.writeUTF(\"Acceso aleatorio\");\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud1/randomaccessfile/#diferencias-con-otros-tipos-de-ficheros","title":"\u2753 Diferencias con otros tipos de ficheros","text":"Tipo de fichero Acceso Memoria usada Uso t\u00edpico Secuencial (<code>FileInputStream</code>, etc.) De principio a fin Baja Logs, texto plano Acceso aleatorio Cualquier posici\u00f3n Media/Alta Bases de datos, estructuras fijas"},{"location":"ud1/randomaccessfile/#ventajas-del-acceso-aleatorio","title":"\ud83d\udcaa Ventajas del acceso aleatorio","text":"<ul> <li>Leer y escribir directamente en una posici\u00f3n sin recorrer todo el archivo.</li> <li>Mayor rendimiento cuando se necesita acceder a partes espec\u00edficas.</li> <li>Permite estructuras como ficheros indexados o registros fijos.</li> </ul>"},{"location":"ud1/randomaccessfile/#inconvenientes","title":"\ud83d\udeab Inconvenientes","text":"<ul> <li>M\u00e1s complejidad en la gesti\u00f3n del puntero.</li> <li>Requiere mayor precisi\u00f3n en el dise\u00f1o del formato del fichero.</li> <li>No hay soporte directo para estructuras complejas como listas u objetos.</li> </ul>"},{"location":"ud1/randomaccessfile/#cuando-usar-acceso-aleatorio","title":"\ud83e\udd14 Cu\u00e1ndo usar acceso aleatorio","text":"<ul> <li>Cuando se necesite acceder, modificar o leer partes espec\u00edficas del fichero con frecuencia.</li> <li>Cuando los datos tienen una estructura fija y conocida (ej. cada registro ocupa 100 bytes).</li> <li>Cuando se trabaja con bases de datos simples sin SGBD o ficheros de configuraci\u00f3n binarios.</li> </ul>"},{"location":"ud1/randomaccessfile/#recomendaciones","title":"\ud83e\udde0 Recomendaciones","text":"<ul> <li>Siempre usar <code>try-with-resources</code> para cerrar el <code>RandomAccessFile</code> correctamente.</li> <li>Documentar la estructura del fichero para no cometer errores con los <code>seek()</code>.</li> <li>Preferir formatos m\u00e1s legibles o portables (como JSON) si no se requiere rendimiento extremo o acceso directo.</li> </ul>"},{"location":"ud1/serialization/","title":"\ud83d\udcceSerializaci\u00f3n y deserializaci\u00f3n de objetos en Java","text":"<p>En esta sesi\u00f3n aprender\u00e1s a guardar objetos Java en archivos y recuperarlos m\u00e1s tarde mediante el proceso de serializaci\u00f3n y deserializaci\u00f3n.</p>"},{"location":"ud1/serialization/#que-es-la-serializacion","title":"\ud83d\udce6 \u00bfQu\u00e9 es la serializaci\u00f3n?","text":"<p>La serializaci\u00f3n es el proceso de convertir un objeto en una secuencia de bytes que, representa el estado del objeto, incluidos sus datos y la estructura, para almacenarlo en un fichero, enviarlo por red o guardarlo en memoria. Se usa para:</p> <ul> <li>Guardar el estado de un objeto.</li> <li>Enviar objetos a trav\u00e9s de sockets.</li> <li>Persistir datos sin usar una base de datos.</li> </ul> <p>Despu\u00e9s se hace la operaci\u00f3n inversa deserializaci\u00f3n, donde se reconstruye ese objeto desde los bytes.</p>"},{"location":"ud1/serialization/#clases-y-conceptos-clave-javaio","title":"\u2728 Clases y conceptos clave (<code>java.io</code>)","text":"Elemento Descripci\u00f3n <code>Serializable</code> Interfaz que debe implementar una clase para ser serializable. <code>ObjectOutputStream</code> Clase para escribir objetos en un flujo de salida. <code>ObjectInputStream</code> Clase para leer objetos desde un flujo de entrada. <code>serialVersionUID</code> Identificador de versi\u00f3n para compatibilidad entre clases serializadas. <code>transient</code> Palabra clave para excluir un atributo de la serializaci\u00f3n."},{"location":"ud1/serialization/#serializacion-binaria-de-java-objectoutputstream","title":"\ud83d\udce6 Serializaci\u00f3n binaria de Java (<code>ObjectOutputStream</code>)","text":"<p>Imaginemos que tenemos la clase <code>Employee</code> que nos permitir\u00e1 crear objetos de empleados y queremos enviar o guardar estos objetos.</p> <p>\ud83d\udccc Es obligatorio para serializar a\u00f1adir <code>implements Serializable</code> en la clase. Serializable es una interfaz marcadora (marker interface). No tiene m\u00e9todos \u2192 solo sirve para indicar a la JVM: \u201cesta clase se puede serializar\u201d.</p> <pre><code>class Employee implements Serializable {\nprivate String name;\nprivate int age;\nprivate List&lt;String&gt; address;\npublic Employee(String name, int age, List&lt;String&gt; address) {\nthis.name = name;\nthis.age = age;\nthis.address = address;\n}\n@Override\npublic String toString() {\nreturn new StringJoiner(\", \", Employee.class.getSimpleName() + \"[\", \"]\")\n.add(\"name='\" + name + \"'\")\n.add(\"age=\" + age)\n.add(\"address=\" + address)\n.toString();\n}\n}\n</code></pre> WriteObject.java<pre><code>//M\u00e9todo para escribir objectos de empleados en un fichero\nprivate static void writeObject(Path path, Employee employee) {\ntry(ObjectOutputStream os = new ObjectOutputStream(Files.newOutputStream(path))) {\nos.writeObject(employee);\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud1/serialization/#deserializacion-binaria-de-java-objectinputstream","title":"\ud83c\udf86 Deserializaci\u00f3n binaria de Java (<code>ObjectInputStream</code>)","text":"<p>La serializaci\u00f3n por defecto escribe la clase del objeto, la firma de la clase, y los valores de los campos no est\u00e1ticos. Estos elementos se utilizan para restaurar el objeto y su estado durante la operaci\u00f3n de lectura. A este proceso se le conoce como reconstituci\u00f3n de los datos o deserializaci\u00f3n.</p> ReadObject.java<pre><code>//M\u00e9todo para leer objectos que han sido serializados\nprivate static void readObject(Path path) {\ntry(ObjectInputStream os = new ObjectInputStream(Files.newInputStream(path))) {\nSystem.out.println((Employee) os.readObject());\n} catch (IOException | ClassNotFoundException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud1/serialization/#como-serializa-y-deserializa-java-los-objetos","title":"\u2699\ufe0f \u00bfC\u00f3mo serializa y deserializa Java los objetos?","text":"<p>\u00bfQu\u00e9 pasar\u00eda si cambiamos el campo age de la clase Employee de int a long despu\u00e9s de haberlo serializado y, ahora volvemos a leerlo?</p> <p>Que se generar\u00eda una excepci\u00f3n de tipo <code>InvalidClassException</code> con el mensaje clase incompatible, con serialVersionUID diferentes.</p>"},{"location":"ud1/serialization/#que-es-el-campo-serialversionuid","title":"\ud83d\udce4 \u00bfQu\u00e9 es el campo serialVersionUID?","text":"<p>El campo <code>serialVersionUID</code> es un campo num\u00e9rico tipo <code>long</code> que genera el compilador autom\u00e1ticamente impl\u00edcitamente en tiempo de ejecuci\u00f3n si no se declara uno expl\u00edcitamente, para las clases serializables. Se crea a partir de detalles de la clase (atributos, m\u00e9todos, modificadores\u2026).</p> <p>Cuando serializas un objeto, Java guarda tambi\u00e9n ese n\u00famero. Al deserializar, comprueba que el n\u00famero de la clase actual coincida con el que ten\u00eda la clase al momento de la serializaci\u00f3n. Si no coincide \u2192 lanza InvalidClassException.</p> <p>Por tanto, cambiar un campo como hemos hecho antes, generar\u00e1 un UID diferente. Cuando leemos un objeto de un stream, el runtime comprueba el serialVersionUID almacenado. Que se almacena con el objeto escrito en el fichero y lo compara con el compilado de la clase. Si no coinciden, entonces hay un problema de compatibilidad y el runtime lanza esa excepci\u00f3n de clase inv\u00e1lida.</p> <p>Note</p> <p>Tambi\u00e9n ocurre que, diferentes compiladores pueden generar autom\u00e1ticamente diferentes versiones de UID. Incluso en nuevas versiones de Java tambi\u00e9n se generan diferentes versiones de UID para un mismo c\u00f3digo, y puede ser que no seamos capaces de deserializar nuestros datos.</p> <p>Para asegurarnos que esto no pase, es encarecidamente recomendable incluir el campo de serialVersionUID como un campo est\u00e1tico de la clase como se muestra a continuaci\u00f3n:</p> <pre><code>class Employee implements Serializable {\nprivate final static long serialVersionUID = 1L;\nprivate String name;\nprivate int age;\nprivate List&lt;String&gt; address;\n...\n}\n</code></pre> <p>Ha de ser de tipo long y se puede ver como una especie de n\u00famero de versi\u00f3n de la clase.</p> <p>Ahora si volvemos a probar podemos pensar que funciona, pero da otro error de tipos incompatibles. Aunque hayamos pasado de int a long sigue habiendo repercusiones. Por eso es importante entender las reglas de la serializaci\u00f3n.</p>"},{"location":"ud1/serialization/#que-puede-ser-un-cambio-incompatible-que-no-me-va-a-dejar-deserializar","title":"\ud83d\udc31\u200d\ud83d\ude80 \u00bfQu\u00e9 puede ser un cambio incompatible? \u00bfQu\u00e9 no me va a dejar deserializar?","text":"<ol> <li>Cambiar el tipo declarado de un campo primitivo. (Es porque los tipos de datos primitivos toman cierta cantidad de espacio y si eso cambia cuando vayamos a leer tendremos que cambiar cu\u00e1ntos bytes leemos)</li> <li>Eliminar campos.</li> <li>Cambiar un campo de no est\u00e1tico a est\u00e1tico.</li> <li>Cambiar la clase de jerarqu\u00eda.</li> <li>Hay m\u00e1s que podemos encontrar en la documentaci\u00f3n de java en incompatible-changes.</li> </ol>"},{"location":"ud1/serialization/#que-cambios-son-compatibles-con-serialization-deserilization","title":"\ud83d\udc31\u200d\ud83d\ude80 \u00bfQu\u00e9 cambios son compatibles con serialization-deserilization?","text":"<ol> <li>A\u00f1adir campos.</li> <li>Cambiar el acceso a un campo. Private, public, etc.</li> <li>Cambiar un campo de est\u00e1tico a no-est\u00e1tico. Es como a\u00f1adir un campo a la clase.</li> </ol>"},{"location":"ud1/serialization/#el-modificador-transient","title":"\ud83e\ude85 El modificador transient","text":"<p>Se utiliza para indicar que un campo no debe serializarse. Esto puede ser \u00faltil para variables o atributos que contienen informaci\u00f3n sensible. O simplemente variables que no queremos que persistan de ninguna manera, ya sea en ficheros o bases de datos.</p> <pre><code>class Employee implements Serializable {\nprivate final static long serialVersionUID = 1L;\nprivate final transient long accountId;\nprivate String name;\nprivate int age;\nprivate List&lt;String&gt; address;\n...\n}\n</code></pre> <p>Si probamos a escribir un objeto Employee con su accountId, veremos que al deserializarlo el accountId ser\u00e1 0, no se escribir\u00e1 nada porque lo hemos declarado como transitorio o transient.</p>"},{"location":"ud1/serialization/#otras-formas-de-serializar-objetos-en-java","title":"\ud83c\udf10 Otras formas de serializar objetos en Java","text":"<p>Hasta ahora hemos visto la serializaci\u00f3n binaria nativa con <code>ObjectOutputStream</code>, pero no es la \u00fanica forma de persistir o enviar objetos. Seg\u00fan el caso de uso, te interesar\u00e1 usar formatos portables, legibles, o muy eficientes.</p>"},{"location":"ud1/serialization/#comparativa-rapida","title":"\ud83d\udd00 Comparativa r\u00e1pida","text":"M\u00e9todo Formato Ventajas principales Inconvenientes / Avisos <code>ObjectOutputStream</code> Binario (Java) Simple en Java, guarda estructura y estado No portable entre lenguajes, versi\u00f3n de clases JSON Texto (JSON) Interoperable, legible, muy usado en APIs y microservicios Tipado laxo, tama\u00f1o mayor que binario, integraci\u00f3n con otros lenguajes XML Texto (XML) Estandarizado, validaci\u00f3n con XSD Verboso, m\u00e1s pesado Bases de datos Estructurado Consulta/filtrado, persistencia robusta No es serializaci\u00f3n 1:1 del objeto, no est\u00e1s guardando el objeto completo directamente, sino su informaci\u00f3n descompuesta en otra forma de representaci\u00f3n."},{"location":"ud1/trywithresources/","title":"\ud83e\udd73 try-with-resources en Java","text":"<p>La sentencia <code>try-with-resources</code> es una versi\u00f3n especial de <code>try</code> que se usa cuando trabajamos con recursos que deben cerrarse, como archivos, streams, sockets o conexiones de BD.</p> <p>\ud83e\udde0 Un recurso es cualquier objeto que necesita ser cerrado cuando ya no se usa, como un <code>FileWriter</code>, <code>Scanner</code> o <code>BufferedReader</code>, etc. La instrucci\u00f3n try-with-resources garantiza que cada recurso se cierre al final de la instrucci\u00f3n.</p>"},{"location":"ud1/trywithresources/#cuando-si-usar-try-with-resources","title":"\u2705 \u00bfCu\u00e1ndo S\u00cd usar try-with-resources?","text":"<p>Cuando trabajas con objetos que implementan <code>java.lang.AutoCloseable</code>. Esto incluye todos los objetos que implementan o extienden de la interfaz <code>java.io.Closeable</code>.</p> <p>Al usar try-with-resources no ser\u00eda necesario realizar la sentencia <code>recurso.close()</code>. \ud83d\udd12 Java se encarga de llamar autom\u00e1ticamente a <code>.close()</code> por ti cuando termina el bloque <code>try</code>, incluso si ocurre una excepci\u00f3n.</p> <p>Antes de Java SE 7 (antes de try-with-resources), se pod\u00eda usar un bloque <code>finally</code> para asegurarse de que un recurso se cerraba, independientemente de si el try generaba excepci\u00f3n o no.</p>"},{"location":"ud1/trywithresources/#ejemplo-de-clases-que-implementan-autocloseable","title":"Ejemplo de clases que implementan AutoCloseable:","text":"<ul> <li><code>BufferedReader</code></li> <li><code>BufferedWriter</code></li> <li><code>FileReader</code> / <code>FileWriter</code></li> <li><code>InputStream</code> / <code>OutputStream</code></li> <li><code>Scanner</code></li> <li><code>DirectoryStream</code></li> <li>Conexiones JDBC (<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>)</li> </ul>"},{"location":"ud1/trywithresources/#antes-de-java-7-cerrar-recursos-a-mano","title":"\ud83d\ude13 Antes de Java 7: cerrar recursos a mano","text":"<p>El siguiente ejemplo muestra c\u00f3mo se cerraban los recursos antes de que apareciera try-with-resources. Creamos el objeto <code>FileWriter</code> en la l\u00ednea 2, en vez de hacerlo en la 4 porque el <code>finally</code> de la l\u00ednea 8 se encuentra en otro scope y la variable <code>fw</code> no existe.</p> <p><pre><code>public static void main(String[] args) {\nFileWriter fw = null;\ntry {\nfw = new FileWriter(\"prueba.txt\");\nfw.write(\"Hola mundo\");\n} catch (IOException e) {\ne.printStackTrace();\n} finally {\ntry {\nif (fw != null) {\nSystem.out.println(\"El fichero se cierra\");\nfw.close();\n}\n}catch (IOException e) {\ne.printStackTrace();\n}\n}\n}\n</code></pre> \ud83d\ude44 Este enfoque es largo, propenso a errores, y puede ocultar excepciones importantes.</p> <p>Al hacer el <code>close()</code> manualmente, vemos que el c\u00f3digo queda bastante engorroso, ya que la sentencia close lanza una excepci\u00f3n que hay que capturar.</p>"},{"location":"ud1/trywithresources/#desde-java-7-try-with-resources","title":"\ud83d\ude80 Desde Java 7: try-with-resources","text":"<p>El mismo ejemplo usando try-with-resources. Vemos que el c\u00f3digo queda mucho m\u00e1s limpio y seguro \u2705:</p> <pre><code>public static void main(String[] args) {\ntry (FileWriter fw = new FileWriter(\"prueba.txt\")) {\nfw.write(\"Hola mundo\");\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n</code></pre>"},{"location":"ud1/trywithresources/#y-si-quiero-usar-mas-de-un-recurso","title":"\ud83e\uddea \u00bfY si quiero usar m\u00e1s de un recurso?","text":"<pre><code>public static void main (String[] args) throws IOException {\ntry(FileWriter fw = new FileWriter(\"prueba.txt\");\nFileWriter fw2 = new FileWriter(\"prueba2.txt\")) {\nfw.write(\"texto de prueba\");\nfw2.write(\"texto de prueba\");\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n</code></pre> <p>Nota \ud83e\udd13</p> <p>Podemos declarar varios recursos dentro de un mismo try como se ve en el ejemplo.</p>"},{"location":"ud1/trywithresources/#importante-diferencia-clave-entre-try-con-finally-y-try-with-resources","title":"\u26a0\ufe0f IMPORTANTE - Diferencia clave entre try con finally y try-with-resources \ud83e\udd14","text":"<p>Supongamos que se lanza una excepci\u00f3n dentro del bloque try y otra en el m\u00e9todo close(). \u00bfCu\u00e1l de las dos excepciones se propaga?</p>"},{"location":"ud1/trywithresources/#en-un-try-con-finally","title":"En un try con finally:","text":"<p>La excepci\u00f3n lanzada en el finally (al hacer close()) sobrescribe la excepci\u00f3n original que se lanz\u00f3 primero dentro del bloque try.</p> <p>Es decir: <pre><code>...\ntry {\nfw = new FileWriter(\"prueba.txt\");\nfw.write(\"texto de prueba\");\n} catch (IOException e) {\nSystem.out.println(\"Error al escribir o crear el fichero\");\n} finally {\ntry {\nif (fw != null) { fw.close(); }\n} catch (IOException e) {\nSystem.out.println(\"Error al cerrar el fichero\");\n}\n}\n</code></pre> \u2192 Se propagar\u00e1 solo la excepci\u00f3n del <code>close()</code>: \"Error en close\".</p> <p>La excepci\u00f3n m\u00e1s importante (la que caus\u00f3 el fallo original) se pierde.</p>"},{"location":"ud1/trywithresources/#en-try-with-resources","title":"En <code>try-with-resources</code>:","text":"<p>Java mantiene la excepci\u00f3n original (la del bloque <code>try</code>) y a\u00f1ade la del bloque close como excepci\u00f3n suprimida.</p> <pre><code>try (FileWriter fw = new FileWriter(\"prueba.txt\")) {\nfw.write(\"Hola mundo\");\n} catch (IOException e) {\nSystem.out.println(\"Error al crear o escribir el fichero\");\n} // Al cerrar, tambi\u00e9n lanza IOException(\"Error en close\")  \n</code></pre> <p>\u2192 Se propagar\u00e1 la excepci\u00f3n original generada en el try (<code>Error al crear o escribir el fichero</code>), y la del <code>close()</code> quedar\u00e1 registrada como \"suppressed exception\".</p> <p>\u2705 Esto permite que la excepci\u00f3n m\u00e1s relevante no se pierda y que el programador pueda acceder a toda la informaci\u00f3n posible de las causas de error.</p> <p>!!! important \"Conclusi\u00f3n clave\" - <code>try</code> con <code>finally</code>: se pierde la excepci\u00f3n original si <code>close()</code> lanza otra. - <code>try-with-resources</code>: se mantiene la excepci\u00f3n del <code>try</code> y se a\u00f1aden las suprimidas.</p>"},{"location":"ud1/trywithresources/#por-que-debemos-cerrar-los-recursos-en-java","title":"\ud83e\udde8 \u00bfPor qu\u00e9 debemos cerrar los recursos en Java?","text":"<p>Cerrar los recursos en Java (como archivos, streams, sockets o conexiones a bases de datos) es fundamental por varias razones:</p>"},{"location":"ud1/trywithresources/#1-fugas-de-memoria-o-recursos","title":"1. Fugas de memoria o recursos","text":"<p>Cuando abres un recurso y no lo cierras, ese recurso permanece activo en el sistema (por ejemplo, un archivo abierto o una conexi\u00f3n sin liberar).</p> <ul> <li>Puede agotar el n\u00famero de descriptores de archivo del sistema operativo.</li> <li>En programas grandes o de larga duraci\u00f3n, esto provoca que se queden sin recursos disponibles y empiecen a fallar.</li> </ul> <p>Ejemplo real: abrir muchos archivos sin cerrar \u2192 <code>java.io.IOException: Too many open files</code></p>"},{"location":"ud1/trywithresources/#2-bloqueos-de-archivos","title":"2. Bloqueos de archivos","text":"<p>Si un archivo est\u00e1 abierto por un proceso y no se cierra, otro proceso o hilo no podr\u00e1 acceder a \u00e9l correctamente.</p> <ul> <li>En algunos sistemas operativos (como Windows), no puedes volver a abrir el archivo si sigue abierto.</li> <li>Esto bloquea escritura, renombrado o borrado.</li> </ul>"},{"location":"ud1/trywithresources/#3-datos-no-guardados-buffers-sin-volcar","title":"3. Datos no guardados (buffers sin volcar)","text":"<p>Muchos recursos (como <code>BufferedWriter</code> o <code>FileOutputStream</code>) usan buffers de memoria.</p> <ul> <li>Si no cierras el recurso, el buffer podr\u00eda no volcarse al disco.</li> <li>Resultado: el archivo se queda incompleto o vac\u00edo.</li> </ul>"},{"location":"ud1/trywithresources/#4-conexiones-a-bases-de-datos-colapsadas","title":"4. Conexiones a bases de datos colapsadas","text":"<p>Si no cierras una conexi\u00f3n JDBC (<code>Connection</code>), esta sigue ocupando espacio en el pool de conexiones.</p> <ul> <li>Al poco tiempo, ya no se pueden abrir m\u00e1s conexiones.</li> <li>El sistema queda bloqueado hasta reiniciar o liberar manualmente.</li> </ul>"},{"location":"ud1/trywithresources/#en-resumen","title":"\ud83e\udde0 En resumen","text":"Problema si no cierras Consecuencia Fugas de recursos Memoria llena, errores Archivos bloqueados No se pueden usar Datos sin guardar Archivos corruptos Conexiones abiertas Fallos de conexi\u00f3n <p>Por eso, try-with-resources es la forma recomendada para evitar estos problemas autom\u00e1ticamente.</p>"},{"location":"ud2/26rendimiento/","title":"\ud83e\udde0 Mejora del rendimiento y buenas pr\u00e1cticas","text":"<p>Optimizar el acceso a BD no va solo de \u201chacer menos queries\u201d, sino de gestionar bien las conexiones y ejecutar SQL eficientemente. Estos son los puntos clave:</p>"},{"location":"ud2/26rendimiento/#conexion-singleton-o-pool","title":"\ud83d\udd0c Conexi\u00f3n: \u00bfsingleton o pool?","text":"<p>\ud83d\udd39 Singleton - Patr\u00f3n de dise\u00f1o que asegura que solo exista una instancia de una clase en toda la aplicaci\u00f3n.</p> <p>\ud83d\udd39 Pool de conexiones - Conjunto de m\u00faltiples conexiones abiertas y gestionadas por un <code>DataSource</code>.</p> <ul> <li>\u274c Evita un <code>Connection</code> \u201csingleton\u201d en aplicaciones con concurrencia:<ul> <li>Una <code>Connection</code> no es thread-safe \u2192 cuellos de botella y errores, compartir una misma conexi\u00f3n entre hilos.</li> <li>Punto \u00fanico de fallo (si cae, cae todo).</li> <li>Conexiones largas pueden caducar o quedar \u201ccolgadas\u201d.</li> <li>Se caduca (timeouts, ca\u00eddas de red); si la \u00fanica conexi\u00f3n muere, tu app tambi\u00e9n.</li> </ul> </li> </ul> <p>Bloquea transacciones: una \u00fanica conexi\u00f3n obliga a serializar todo.</p> <ul> <li>\u2705 Usa un pool de conexiones (<code>DataSource</code>) en su lugar:<ul> <li>Reutiliza conexiones abiertas (muy r\u00e1pido).</li> <li>Gestiona caducidad, validaci\u00f3n, tama\u00f1o del pool y timeouts.</li> <li>Ideal tanto para apps de escritorio con cierta concurrencia como para aplicaciones web.</li> </ul> </li> </ul>"},{"location":"ud2/26rendimiento/#ejemplo-con-hikaricp-recomendado","title":"Ejemplo con HikariCP (recomendado)","text":"<pre><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport javax.sql.DataSource;\npublic final class DataSourceSingleton {\nprivate static final HikariDataSource ds;\nstatic {\nHikariConfig cfg = new HikariConfig();\ncfg.setJdbcUrl(\"jdbc:mysql://localhost:3306/severo?useSSL=false\");\ncfg.setUsername(\"patricia\");\ncfg.setPassword(\"marti\");\n// Configuraci\u00f3n del pool\ncfg.setMaximumPoolSize(10);\ncfg.setMinimumIdle(2);\ncfg.setConnectionTimeout(10000); // ms\ncfg.setIdleTimeout(600000);      // ms\ncfg.setMaxLifetime(1800000);     // ms\nds = new HikariDataSource(cfg);\n}\nprivate DataSourceSingleton() {}\npublic static DataSource getDataSource() { return ds; }\n}\n</code></pre> <ul> <li>Hay un \u00fanico HikariDataSource (singleton) por cada origen de datos.  <ul> <li>Ese DataSource gestiona internamente un pool de conexiones. Un pool paraleliza</li> <li>Los DataSource con pool (HikariCP, c3p0, DBCP\u2026) est\u00e1n dise\u00f1ados para uso concurrente. Internamente gestionan un conjunto de conexiones y sincronizan el acceso. T\u00fa llamas <code>getConnection()</code> desde muchos hilos y el pool reparte conexiones libres o crea nuevas hasta el maximumPoolSize.    </li> <li>Es un \u00fanico gestor de muchas conexiones.</li> <li>Cada vez que llamas a <code>getConnection()</code> de <code>DataSource</code>, no abre un socket nuevo:  </li> <li>\u2705 Si hay una conexi\u00f3n libre en el pool \u2192 te la entrega.  </li> <li>\u2705 Si no, crea una nueva hasta llegar al maximumPoolSize.</li> <li>\u2705 Cuando cierras la conexi\u00f3n (try-with-resources), no se destruye, sino que vuelve al pool para reutilizarse. Ese pr\u00e9stamo/devoluci\u00f3n es muy r\u00e1pido y thread-safe.</li> </ul> </li> </ul> <p>Uso: <pre><code>try (Connection con = DataSourceSingleton.getDataSource().getConnection();\nPreparedStatement ps = con.prepareStatement(\"SELECT id, user_name FROM login WHERE id &lt; ?\")) {\nps.setInt(1, 10);\ntry (ResultSet rs = ps.executeQuery()) {\nwhile (rs.next()) {\nSystem.out.println(rs.getInt(\"id\") + \" - \" + rs.getString(\"user_name\"));\n}\n}\n}\n</code></pre></p>"},{"location":"ud2/26rendimiento/#como-anadir-hikaricp","title":"\ud83d\udce6 \u00bfC\u00f3mo a\u00f1adir HikariCP?","text":"<p>HikariCP no forma parte de Java SE, hay que a\u00f1adirlo como dependencia externa.</p>"},{"location":"ud2/26rendimiento/#con-maven","title":"Con Maven","text":"<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.zaxxer&lt;/groupId&gt;\n&lt;artifactId&gt;HikariCP&lt;/artifactId&gt;\n&lt;version&gt;5.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"ud2/26rendimiento/#con-gradle","title":"Con Gradle","text":"<pre><code>implementation 'com.zaxxer:HikariCP:5.1.0'\n</code></pre>"},{"location":"ud2/26rendimiento/#manualmente","title":"Manualmente","text":"<ul> <li>Descargar el <code>.jar</code> de Maven Central.  </li> <li>A\u00f1adirlo al classpath del proyecto en IntelliJ/Eclipse.  </li> <li>Tambi\u00e9n se necesita el driver JDBC de la BD (ej: <code>mysql-connector-j</code>).</li> </ul>"},{"location":"ud2/26rendimiento/#multihilo-y-conexiones","title":"\ud83e\uddf5 Multihilo y conexiones","text":"<ul> <li>Un hilo \u2260 una conexi\u00f3n fija. Pide la conexi\u00f3n al pool cuando la necesites y ci\u00e9rrala lo antes posible.  </li> <li>No compartas <code>Connection</code>, <code>Statement</code> o <code>ResultSet</code> entre hilos.  </li> <li>Mant\u00e9n las transacciones cortas para reducir bloqueos.</li> </ul>"},{"location":"ud2/26rendimiento/#preparedstatement-y-cache","title":"\u2699\ufe0f PreparedStatement y cach\u00e9","text":"<ul> <li>Usa <code>PreparedStatement</code> para casi todo tipo de SQL (tambi\u00e9n <code>SELECT</code>).  </li> <li>Previene SQL Injection y mejora el rendimiento gracias al plan cache del SGBD.</li> <li>Activa la cach\u00e9 de prepareds en MySQL con:  </li> <li><code>cachePrepStmts=true&amp;prepStmtCacheSize=256&amp;prepStmtCacheSqlLimit=2048</code> </li> </ul>"},{"location":"ud2/26rendimiento/#inserciones-masivas-con-batch","title":"\ud83d\ude80 Inserciones masivas con batch","text":"<p>Para grandes vol\u00famenes de datos, agrupa operaciones con <code>addBatch()</code>:</p> <pre><code>String sql = \"INSERT INTO login(user_name, password) VALUES (?, ?)\";\ntry (final Connection con = DataSourceSingleton.getDataSource().getConnection();\nPreparedStatement ps = con.prepareStatement(sql)) {\ncon.setAutoCommit(false);\nfor (Login l : lista) {\nps.setString(1, l.getUsername());\nps.setString(2, l.getPassword());\nps.addBatch();\n}\nps.executeBatch(); // \ud83d\ude80 se env\u00eda todo junto en un lote\ncon.commit();\n}\n</code></pre>"},{"location":"ud2/26rendimiento/#transacciones","title":"\ud83d\udd12 Transacciones","text":"<ul> <li>Desactiva <code>autoCommit</code> solo cuando necesites agrupar operaciones.  </li> <li>Confirma con <code>commit()</code> y revierte con <code>rollback()</code> en caso de error.  </li> <li>Ejemplo: <pre><code>con.setAutoCommit(false);\ntry {\n// operaciones SQL\ncon.commit();\n} catch (SQLException e) {\ncon.rollback();\n}\n</code></pre></li> </ul>"},{"location":"ud2/26rendimiento/#otras-buenas-practicas","title":"\ud83e\uddf9 Otras buenas pr\u00e1cticas","text":"<ul> <li>Selecciona solo las columnas necesarias (<code>SELECT columna1, columna2</code>).</li> <li>Usa \u00edndices adecuados en el SGBD.</li> <li>Define <code>setQueryTimeout</code> para queries largas.</li> <li>Cierra siempre recursos en orden: <code>ResultSet</code> \u2192 <code>Statement</code> \u2192 <code>Connection</code>. Usa <code>try-with-resources</code>.</li> <li>Nunca guardes <code>Connection</code> en campos est\u00e1ticos, variables globales o Singleton.</li> <li>Abrir/cerrar una <code>Connection</code> por operaci\u00f3n o por transacci\u00f3n (try-with-resources).     </li> </ul>"},{"location":"ud2/27projectstructure/","title":"\ud83e\udded Desarrollo de aplicaciones completas con JDBC","text":"<p>Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador). En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes:</p> <p></p>"},{"location":"ud2/27projectstructure/#1-creando-la-bbdd","title":"1\ufe0f\u20e3 - Creando la BBDD","text":"<p>Aseg\u00farate de que tienes el servidor de base de datos instalado y la base de datos creada con las tablas necesarias para tu aplicaci\u00f3n.  </p> <p></p> <p>Creamos tambi\u00e9n la tabla login con la que vamos a trabajar en los ejemplos:</p> <pre><code>CREATE TABLE `login` (\n`id` int NOT NULL AUTO_INCREMENT,\n`user_name` varchar(50) NOT NULL,\n`password` varchar(255) NOT NULL,\n`created_at` datetime DEFAULT CURRENT_TIMESTAMP,\nPRIMARY KEY (`id`),\nUNIQUE KEY `user_name` (`user_name`)\n);\n</code></pre>"},{"location":"ud2/27projectstructure/#2-clase-de-conexion-con-singleton-de-datasource","title":"2\ufe0f\u20e3 - Clase de conexi\u00f3n con Singleton de DataSource","text":"<p>Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, usaremos un Singleton de <code>DataSource</code> con pool de conexiones. Esto es mucho m\u00e1s eficiente y seguro en aplicaciones reales.</p> <p>Esta clase estar\u00e1 ubicada dentro del paquete util.</p> <p>Ejemplo de conexi\u00f3n a la BBDD usando Singleton:</p> DataSourceSingleton.java<pre><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport javax.sql.DataSource;\npublic final class DataSourceSingleton {\nprivate static final HikariDataSource ds;\nstatic {\nHikariConfig cfg = new HikariConfig();\ncfg.setJdbcUrl(\"jdbc:mysql://localhost:3306/severo?useSSL=false\");\ncfg.setUsername(\"patricia\");\ncfg.setPassword(\"marti\");\ncfg.setMaximumPoolSize(10);\ncfg.setMinimumIdle(2);\ncfg.setConnectionTimeout(10000);\ncfg.setIdleTimeout(600000);\ncfg.setMaxLifetime(1800000);\nds = new HikariDataSource(cfg);\n}\nprivate DataSourceSingleton() {}\npublic static DataSource getDataSource() { return ds; }\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#3-creando-el-modelo","title":"3\ufe0f\u20e3 - Creando el modelo","text":"<p>El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio.</p> <p>Para el ejemplo, el modelo de <code>Login</code> debe contener los atributos que contiene la tabla login como variables de la clase. Normalmente los modelos de la clase se encuentran en un paquete llamado model.</p> Login.java<pre><code>public class Login {\nprivate int id;\nprivate String username;\nprivate String password;\nprivate LocalDateTime createdAt;\n//constructors\n//getters y setters\n@Override\npublic String toString() {\nreturn \"Login{\" +\n\"id=\" + id +\n\", username='\" + username + '\\'' +\n\", password='\" + password + '\\'' +\n\", createdAt=\" + createdAt +\n'}';\n}\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#4-clases-para-la-manipulacion-de-la-base-de-datos","title":"4\ufe0f\u20e3 - Clases para la manipulaci\u00f3n de la base de datos","text":"<p>Dentro del paquete mysql a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. </p> <p>En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla login.</p> LoginAccessDB.java<pre><code>public class LoginAccessDB {\npublic List&lt;Login&gt; getLogins() throws SQLException {\nString sql = \"SELECT * FROM login\";\nList&lt;Login&gt; lista = new ArrayList&lt;&gt;();\ntry (Connection con = DataSourceSingleton.getDataSource().getConnection();\nStatement st = con.createStatement();\nResultSet rs = st.executeQuery(sql)) {\nwhile (rs.next()) {\nLogin login = new Login();\nlogin.setId(rs.getInt(\"id\"));\nlogin.setUsername(rs.getString(\"user_name\"));\nlogin.setPassword(rs.getString(\"password\"));\nlogin.setCreatedAt(rs.getTimestamp(\"created_at\").toLocalDateTime());\nlista.add(login);\n}\n}\nreturn lista;\n}\n}\n</code></pre> <p>\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota</p> <p>M\u00e1s adelante veremos el patr\u00f3n DAO para estructurar mejor el acceso a BD.</p>"},{"location":"ud2/27projectstructure/#5-test","title":"5\ufe0f\u20e3 - Test","text":"<p>Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro <code>main</code>.</p> MainApp.java<pre><code>public class MainApp {\npublic static void main(String[] args) {\nLoginAccessDB loginHandleDB = new LoginAccessDB();\ntry {\nfor (Login l: loginHandleDB.getLogins()) {\nSystem.out.println(l);\n}\n} catch (SQLException ex) {\nSystem.out.println(\"SQLException: \" + ex.getMessage());\nSystem.out.println(\"SQLState: \" + ex.getSQLState());\nSystem.out.println(\"VendorError: \" + ex.getErrorCode());\n}\n}\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#6-crud-basico-con-jdbc","title":"6\ufe0f\u20e3 CRUD b\u00e1sico con JDBC","text":"<p>Ejemplos de operaciones cl\u00e1sicas:</p> <pre><code>// INSERT\nString insert = \"INSERT INTO login(user_name, password) VALUES(?, ?)\";\ntry (Connection con = DataSourceSingleton.getDataSource().getConnection();\nPreparedStatement ps = con.prepareStatement(insert)) {\nps.setString(1, \"ana\");\nps.setString(2, \"1234\");\nps.executeUpdate();\n}\n// UPDATE\nString update = \"UPDATE login SET password=? WHERE user_name=?\";\ntry (Connection con = DataSourceSingleton.getDataSource().getConnection();\nPreparedStatement ps = con.prepareStatement(update)) {\nps.setString(1, \"nuevaPass\");\nps.setString(2, \"ana\");\nps.executeUpdate();\n}\n// DELETE\nString delete = \"DELETE FROM login WHERE user_name=?\";\ntry (Connection con = DataSourceSingleton.getDataSource().getConnection();\nPreparedStatement ps = con.prepareStatement(delete)) {\nps.setString(1, \"ana\");\nps.executeUpdate();\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#7-uso-de-transacciones","title":"7\ufe0f\u20e3 Uso de transacciones","text":"<p>Ejemplo de dos operaciones que deben ir juntas:</p> <pre><code>try (Connection con = DataSourceSingleton.getDataSource().getConnection()) {\ncon.setAutoCommit(false);\ntry (PreparedStatement ps1 = con.prepareStatement(\"UPDATE cuentas SET saldo = saldo - ? WHERE id=?\");\nPreparedStatement ps2 = con.prepareStatement(\"UPDATE cuentas SET saldo = saldo + ? WHERE id=?\")) {\nps1.setInt(1, 100);\nps1.setInt(2, 1);\nps1.executeUpdate();\nps2.setInt(1, 100);\nps2.setInt(2, 2);\nps2.executeUpdate();\ncon.commit();\n} catch (SQLException e) {\ncon.rollback();\n}\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#8-procedimientos-almacenados","title":"8\ufe0f\u20e3 Procedimientos almacenados","text":"<p>Ejemplo en MySQL:</p> <pre><code>DELIMITER //\nCREATE PROCEDURE obtenerLogin(IN userName VARCHAR(50))\nBEGIN\nSELECT * FROM login WHERE user_name = userName;\nEND //\nDELIMITER ;\n</code></pre> <p>Invocaci\u00f3n en Java:</p> <pre><code>String sql = \"{ call obtenerLogin(?) }\";\ntry (Connection con = DataSourceSingleton.getDataSource().getConnection();\nCallableStatement cs = con.prepareCall(sql)) {\ncs.setString(1, \"patricia\");\nResultSet rs = cs.executeQuery();\nif (rs.next()) {\nSystem.out.println(rs.getString(\"user_name\"));\n}\n}\n</code></pre>"},{"location":"ud2/27projectstructure/#9-fichero-readme","title":"9\ufe0f\u20e3 - Fichero README","text":"<p>Readme: el propio nombre, l\u00e9eme, indica su prop\u00f3sito: ser le\u00eddo. El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto, por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta.</p> <p>Consejo</p> <p>El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas.</p>"},{"location":"ud2/27projectstructure/#que-suelen-incluir-los-ficheros-readme","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?","text":"<p>Suelen incluir informaci\u00f3n sobre:</p> <ul> <li>Una descripci\u00f3n general del sistema o proyecto.</li> <li>El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado.</li> <li>Los requisitos del entorno de desarrollo para la integraci\u00f3n.</li> <li>Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n.</li> <li>Bugs conocidos y posibles correcciones de errores.</li> <li>Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha.</li> <li>Informaci\u00f3n sobre derechos de autor y licencias.</li> </ul>"},{"location":"ud2/27projectstructure/#como-escribir-un-fichero-readme","title":"C\u00f3mo escribir un fichero README","text":"<p>El contenido del fichero README debe estar en ingl\u00e9s.</p> <p></p> <p>C\u00f3mo crear un fichero README</p>"},{"location":"ud2/27projectstructure/#exportar-la-bbdd-de-mysql","title":"Exportar la BBDD de MySQL","text":"<p>En MySQL workbench seleccionamos Server --&gt; Data Export</p> <p></p> <p>Selecciono el esquema de BBDD que quiero exportar y hago click en Start export</p> <p></p> <p>Workbench me muestra d\u00f3nde se ha generado el fichero:</p> <p></p>"},{"location":"ud2/conectores/","title":"\ud83d\udcda Fundamentos de JDBC: conexi\u00f3n, recursos y ejecuci\u00f3n","text":"<p>Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos.</p>"},{"location":"ud2/conectores/#carga-del-driver","title":"\ud83d\udce5 Carga del driver","text":"<p>Para que Java pueda comunicarse con una base de datos necesitamos el driver JDBC correspondiente. Ese driver se a\u00f1ade normalmente como un archivo <code>.jar</code> en el proyecto.</p> <p>Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven: MySQL JDBC</p> <p>En versiones antiguas de Java era necesario cargar expl\u00edcitamente el driver con <code>Class.forName()</code>:</p> <pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>Hoy en d\u00eda, si el driver est\u00e1 en el classpath, se carga autom\u00e1ticamente, por lo que no suele ser necesario llamar a Class.forName.</p>"},{"location":"ud2/conectores/#clase-drivermanager","title":"\ud83d\udee0\ufe0f Clase DriverManager","text":"<p>La clase DriverManager es la encargada de gestionar los drivers JDBC instalados y proporcionar conexiones a la base de datos.</p> <p>M\u00e9todo m\u00e1s utilizado:</p> <pre><code>Connection con = DriverManager.getConnection(url, usuario, contrase\u00f1a);\n</code></pre> <p>Par\u00e1metros:</p> <ul> <li>url: cadena con el protocolo y los datos de conexi\u00f3n, por ejemplo <code>jdbc:mysql://localhost:3306/mi_bd</code> </li> <li>usuario: nombre del usuario de la base de datos.  </li> <li>contrase\u00f1a: la clave de acceso.  </li> </ul>"},{"location":"ud2/conectores/#interfaces-y-clases-principales-de-jdbc","title":"\ud83e\udde9 Interfaces y clases principales de JDBC","text":"<p>Las m\u00e1s utilizadas en cualquier aplicaci\u00f3n JDBC son:</p> <ul> <li><code>Connection</code> \u2192 Representa la conexi\u00f3n activa con la base de datos.</li> <li><code>Statement</code> \u2192 Ejecuta sentencias SQL est\u00e1ticas (sin par\u00e1metros). \u00datil para DDL o consultas sencillas</li> <li><code>PreparedStatement</code> \u2192 Versi\u00f3n mejorada de Statement, permite parametrizar con el s\u00edmbolo \"?\". M\u00e1s seguro (previene SQL Injection) y eficiente en ejecuciones repetidas.</li> <li><code>CallableStatement</code> \u2192 Se utiliza para ejecutar procedimientos almacenados en la base de datos.</li> <li><code>ResultSet</code> \u2192 Representa el conjunto de resultados devuelto por una consulta SELECT. Permite recorrer las filas y leer los datos columna a columna.</li> </ul>"},{"location":"ud2/conectores/#objeto-connection","title":"\ud83d\udd0c Objeto Connection","text":"<p><code>Connection</code> representa una conexi\u00f3n activa con la base de datos. Con este objeto podremos:</p> <ul> <li>Crear sentencias (<code>Statement</code>, <code>PreparedStatement</code>, <code>CallableStatement</code>).  </li> <li>Ejecutar consultas y modificaciones.  </li> <li>Controlar transacciones (commit, rollback).  </li> <li>Cerrar la conexi\u00f3n cuando ya no sea necesaria.  </li> </ul> <p>Ejemplo b\u00e1sico:</p> <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n...\npublic static void main(String[] args) {\nString user = \"patricia\";\nString password = \"marti\";\nString url = \"jdbc:mysql://localhost/severo_ad\";\ntry (final Connection connection = DriverManager.getConnection(url, user, password)) {\nSystem.out.println(connection.getCatalog());\n} catch (SQLException ex) {\nSystem.out.println(\"SQLException: \" + ex.getMessage());\nSystem.out.println(\"SQLState: \" + ex.getSQLState());\nSystem.out.println(\"VendorError: \" + ex.getErrorCode());\n}\n}\n</code></pre> <p>Con <code>try-with-resources</code> la conexi\u00f3n se cerrar\u00e1 autom\u00e1ticamente al finalizar el bloque.</p>"},{"location":"ud2/conectores/#sqlexception","title":"\ud83e\udd13 SQLException","text":"<p>Es la excepci\u00f3n que se lanza cuando ocurre un problema entre la base de datos y el programa Java JDBC. Algunos de sus m\u00e9todos m\u00e1s importantes son:</p> <ul> <li><code>.getMessage()</code> \u2192 Descripci\u00f3n del error.  </li> <li><code>.getSQLState()</code> \u2192 C\u00f3digo SQL est\u00e1ndar ISO/ANSI que identifica el error. SQLState Official </li> <li><code>.getErrorCode()</code> \u2192 C\u00f3digo espec\u00edfico del proveedor de BD.  </li> <li><code>.getCause()</code> \u2192 Devuelve la excepci\u00f3n original que provoc\u00f3 el error (si existe).  </li> <li><code>.getNextException()</code> \u2192 Permite recorrer la cadena de excepciones encadenadas.  </li> </ul> <pre><code>try (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement()) {\nResultSet rs = st.executeQuery(\"SELECT * FROM tabla_inexistente\");\n} catch (SQLException e) {\nSystem.out.println(\"Error: \" + e.getMessage());\nSystem.out.println(\"SQLState: \" + e.getSQLState());\nSystem.out.println(\"C\u00f3digo de error: \" + e.getErrorCode());\n}\n</code></pre>"},{"location":"ud2/conectores/#liberacion-de-recursos-en-jdbc","title":"\ud83d\udd12 Liberaci\u00f3n de recursos en JDBC","text":"<p>Los objetos de JDBC (<code>Connection</code>, <code>Statement</code> y <code>ResultSet</code>) consumen recursos importantes tanto en el cliente como en el servidor. Por ello, deben cerrarse siempre cuando ya no se necesiten.  </p>"},{"location":"ud2/conectores/#por-que-cerrarlos","title":"\u26a1 \u00bfPor qu\u00e9 cerrarlos?","text":"<ul> <li><code>Connection</code> mantiene la conexi\u00f3n abierta con el SGBD y consume recursos del servidor.  </li> <li><code>Statement</code> almacena informaci\u00f3n de ejecuci\u00f3n y mantiene cursores abiertos.  </li> <li><code>ResultSet</code> ocupa memoria y punteros sobre los resultados de una consulta.  </li> </ul> <p>Si no se cierran manualmente: - El garbage collector los liberar\u00e1 m\u00e1s tarde, pero mientras tanto siguen consumiendo recursos. - Se pueden producir fugas de memoria o saturar el servidor de BD con conexiones abiertas.</p>"},{"location":"ud2/conectores/#orden-recomendado-de-cierre","title":"\ud83d\udcd1 Orden recomendado de cierre","text":"<ol> <li><code>ResultSet</code> </li> <li><code>Statement</code> </li> <li><code>Connection</code> </li> </ol> <p>\u26a0\ufe0f Si se cierra la conexi\u00f3n antes que el statement, al intentar cerrarlo despu\u00e9s lanzar\u00e1 una <code>SQLException</code>.  </p> <p>Adem\u00e1s: - Cerrar un <code>Statement</code> cierra autom\u00e1ticamente su <code>ResultSet</code> asociado. - Pero cerrar una <code>Connection</code> no cierra autom\u00e1ticamente todos los statements.</p> <pre><code>public class CierreRecursos {\npublic static void main(String[] args) {\nString url = \"jdbc:mysql://localhost:3306/mi_bd\";\nString user = \"root\";\nString password = \"1234\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement();) {//al cerrar el Statement se cierra autom\u00e1ticamente el ResultSet\nResultSet rs = st.executeQuery(\"SELECT id, nombre FROM alumnos\");\nwhile (rs.next()) {\nSystem.out.println(rs.getInt(\"id\") + \" - \" + rs.getString(\"nombre\"));\n}\n} catch (SQLException e) {\ne.printStackTrace();\n}\n}\n}\n</code></pre>"},{"location":"ud2/conectores/#metodos-principales-para-ejecutar-sql-en-jdbc","title":"\u26a1 M\u00e9todos principales para ejecutar SQL en JDBC","text":"<p>En JDBC disponemos de tres m\u00e9todos principales para ejecutar sentencias SQL desde las interfaces <code>Statement</code> o <code>PreparedStatement</code>. Cada uno est\u00e1 pensado para un tipo distinto de operaci\u00f3n:</p>"},{"location":"ud2/conectores/#executequerystring-sql","title":"\ud83d\udd0d <code>executeQuery(String sql)</code>","text":"<ul> <li>Uso: consultas de lectura (SELECT).  </li> <li>Devuelve: un objeto <code>ResultSet</code> con las filas obtenidas.  </li> <li>Ejemplo:</li> </ul> <pre><code>ResultSet rs = st.executeQuery(\"SELECT * FROM alumnos\");\nwhile (rs.next()) {\nSystem.out.println(rs.getString(\"nombre\"));\n}\n</code></pre>"},{"location":"ud2/conectores/#executeupdatestring-sql","title":"\u270d\ufe0f <code>executeUpdate(String sql)</code>","text":"<ul> <li>Uso: operaciones de modificaci\u00f3n de datos (DML) y sentencias DDL.  </li> <li>DML: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>.  </li> <li>DDL: <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>.  </li> <li>Devuelve: un <code>int</code> con el n\u00famero de filas afectadas (en DML) o <code>0</code> en DDL.  </li> <li>Ejemplo:</li> </ul> <pre><code>int filas = st.executeUpdate(\"INSERT INTO alumnos VALUES (1, 'Ana', 20)\");\nSystem.out.println(\"Filas insertadas: \" + filas);\n</code></pre>"},{"location":"ud2/conectores/#executestring-sql","title":"\ud83c\udf00 <code>execute(String sql)</code>","text":"<ul> <li>Uso: gen\u00e9rico. Puede ejecutar cualquier tipo de sentencia SQL.  </li> <li>Devuelve:  </li> <li><code>true</code> \u2192 si la operaci\u00f3n devuelve un <code>ResultSet</code>.  </li> <li><code>false</code> \u2192 si devuelve solo un n\u00famero de filas afectadas.  </li> <li>Ejemplo:</li> </ul> <pre><code>boolean tieneResultados = st.execute(\"SELECT * FROM alumnos\");\nif (tieneResultados) {\nResultSet rs = st.getResultSet();\nwhile (rs.next()) {\nSystem.out.println(rs.getString(\"nombre\"));\n}\n} else {\nint filas = st.getUpdateCount();\nSystem.out.println(\"Filas modificadas: \" + filas);\n}\n</code></pre>"},{"location":"ud2/conectores/#resumen-de-uso","title":"\ud83d\udccc Resumen de uso","text":"M\u00e9todo Uso principal Devuelve <code>executeQuery(sql)</code> Consultas <code>SELECT</code> <code>ResultSet</code> <code>executeUpdate(sql)</code> <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, DDL N\u00ba filas afectadas (<code>int</code>) <code>execute(sql)</code> Cualquier sentencia (menos habitual) <code>boolean</code> + <code>ResultSet</code>/<code>int</code>"},{"location":"ud2/ddl/","title":"\ud83c\udfd7\ufe0f Definici\u00f3n de estructuras de BD y ejecuci\u00f3n de sentencias DDL","text":""},{"location":"ud2/ddl/#sentencias-sql-ddl","title":"\ud83d\udcd8 Sentencias SQL DDL","text":"<p>El lenguaje de definici\u00f3n de datos (DDL) permite crear, modificar y eliminar la estructura de las bases de datos. Las sentencias m\u00e1s importantes son:</p> <ul> <li>CREATE \u2192 Crea bases de datos, tablas, \u00edndices o vistas.  </li> <li>ALTER \u2192 Modifica estructuras existentes (a\u00f1adir columnas, cambiar tipos, etc.).  </li> <li>DROP \u2192 Elimina bases de datos u objetos (tablas, \u00edndices, vistas).  </li> </ul> <p>Ejemplo:</p> <pre><code>CREATE TABLE alumnos (\nid INT PRIMARY KEY,\nnombre VARCHAR(50),\nedad INT\n);\nALTER TABLE alumnos ADD COLUMN email VARCHAR(100);\nDROP TABLE alumnos;\n</code></pre>"},{"location":"ud2/ddl/#ejecucion-en-java-con-statement","title":"\ud83d\udcbb Ejecuci\u00f3n en Java con Statement","text":"<p>En JDBC, las sentencias DDL se ejecutan usando el m\u00e9todo <code>executeUpdate()</code> de la interfaz <code>Statement</code>.</p> <pre><code>public class CrearTabla {\npublic static void main(String[] args) {\nString url = \"jdbc:mysql://localhost:3306/mi_bd\";\nString user = \"root\";\nString password = \"1234\";\nString sql = \"CREATE TABLE alumnos (\" +\n\"id INT PRIMARY KEY,\" +\n\"nombre VARCHAR(50),\" +\n\"edad INT)\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement()) {\nst.executeUpdate(sql);\nSystem.out.println(\"Tabla creada correctamente.\");\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}\n</code></pre>"},{"location":"ud2/ddl/#creacion-y-borrado-de-tablas-desde-java","title":"\ud83d\uddd1\ufe0f Creaci\u00f3n y borrado de tablas desde Java","text":"<p>Adem\u00e1s de crear tablas, tambi\u00e9n podemos borrarlas con <code>DROP TABLE</code> desde nuestro programa Java:</p> <ul> <li>\u26a0\ufe0f Atenci\u00f3n: <code>DROP TABLE</code> borra la tabla y todos sus datos de forma permanente.</li> </ul> <pre><code>String sql = \"DROP TABLE alumnos\";\nst.executeUpdate(sql);\nSystem.out.println(\"Tabla eliminada.\");\n</code></pre>"},{"location":"ud2/ddl/#resumen","title":"\ud83d\udccc Resumen","text":"<ul> <li>Las sentencias DDL (CREATE, ALTER, DROP) definen la estructura de la base de datos.</li> <li>En Java, se ejecutan mediante <code>Statement.executeUpdate(sql)</code>.</li> <li>Podemos crear o eliminar tablas directamente desde c\u00f3digo Java.</li> </ul>"},{"location":"ud2/ddl/#statement-vs-preparedstatement-en-ddl","title":"\ud83d\udee0\ufe0f Statement vs PreparedStatement en DDL","text":"<ul> <li>En DDL se usa <code>Statement</code> porque las sentencias de creaci\u00f3n de estructuras suelen ser fijas (no llevan par\u00e1metros din\u00e1micos). Es decir, no se le pasa ning\u00fan par\u00e1metro o variable a la consulta.</li> <li>En DML se recomienda <code>PreparedStatement</code>, ya que permite parametrizar (<code>?</code>), evitar inyecci\u00f3n SQL y reutilizar la sentencia compilada.  </li> </ul>"},{"location":"ud2/dml/","title":"\u270d\ufe0f Modificaci\u00f3n de datos con JDBC","text":""},{"location":"ud2/dml/#sentencias-sql-dml","title":"\ud83d\udcd8 Sentencias SQL DML","text":"<p>El lenguaje de manipulaci\u00f3n de datos (DML) permite insertar, modificar y eliminar registros en las tablas de una base de datos. Las sentencias m\u00e1s utilizadas son:</p> <ul> <li>INSERT \u2192 A\u00f1ade registros.  </li> <li>UPDATE \u2192 Modifica registros existentes.  </li> <li>DELETE \u2192 Elimina registros.  </li> </ul> <p>Ejemplos:</p> <pre><code>INSERT INTO alumnos (id, nombre, edad) VALUES (1, 'Ana', 20);\nUPDATE alumnos SET edad = 21 WHERE id = 1;\nDELETE FROM alumnos WHERE id = 1;\n</code></pre>"},{"location":"ud2/dml/#uso-con-statement-no-recomendado-en-dml","title":"\ud83d\udcbb Uso con Statement (No recomendado en DML)","text":"<p>Podemos ejecutar sentencias DML en Java con el m\u00e9todo <code>executeUpdate()</code> de la interfaz <code>Statement</code>. Pero no es muy recomendable. Su uso se ce\u00f1ir\u00eda solamente para consultas est\u00e1ticas a las que no se les pasa ning\u00fan par\u00e1metro.</p> <p>Ejemplo:</p> <pre><code>try (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement()) {\nString sql = \"INSERT INTO alumnos (id, nombre, edad) VALUES (2, 'Luis', 22)\";\nint filas = st.executeUpdate(sql);\nSystem.out.println(\"Filas insertadas: \" + filas);\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre> <p>\u26a0\ufe0f No es recomendable su uso. Por seguridad y eficiencia es mejor usar <code>PreparedStatement</code> para DML.</p>"},{"location":"ud2/dml/#uso-con-preparedstatement-recomendado","title":"\ud83d\udee0\ufe0f Uso con PreparedStatement - Recomendado","text":"<p><code>PreparedStatement</code> es una versi\u00f3n mejorada de <code>Statement</code> que permite parametrizar sentencias SQL mediante el uso de <code>?</code>. Esto evita errores, facilita la reutilizaci\u00f3n de la sentencia y protege contra inyecciones SQL.  </p> <p>Ejemplo:</p> <pre><code>String sql = \"INSERT INTO alumnos (id, nombre, edad) VALUES (?, ?, ?)\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nPreparedStatement ps = con.prepareStatement(sql)) {\nps.setInt(1, 3);\nps.setString(2, \"Mar\u00eda\");\nps.setInt(3, 19);\nint filas = ps.executeUpdate();\nSystem.out.println(\"Filas insertadas: \" + filas);\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/dml/#obtener-el-id-autogenerado-tras-un-insert","title":"\ud83c\udfaf Obtener el ID autogenerado tras un INSERT","text":"<p>Usa <code>prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)</code>. Tras <code>executeUpdate()</code>, llama a <code>ps.getGeneratedKeys()</code>.</p> <p>Si la tabla tiene clave compuesta o m\u00faltiples claves, el ResultSet puede traer varias columnas.</p> <pre><code>String sql = \"INSERT INTO alumnos (nombre, edad) VALUES (?, ?)\";\ntry (Connection con = DriverManager.getConnection(url, user, password);\nPreparedStatement ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\nps.setString(1, \"Mar\u00eda\");\nps.setInt(2, 19);\nint filas = ps.executeUpdate();\nSystem.out.println(\"Filas insertadas: \" + filas);\ntry (ResultSet rs = ps.getGeneratedKeys()) {\nif (rs.next()) {\nlong idGenerado = rs.getLong(1); // primera columna devuelta\nSystem.out.println(\"ID generado: \" + idGenerado);\n}\n}\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/dml/#consejos-adicionales","title":"\ud83e\udde9 Consejos adicionales","text":"<ul> <li>\ud83e\ude84 Batch inserts: si usas addBatch() + executeBatch(), puedes recorrer ps.getGeneratedKeys() para obtener todos los IDs generados.        </li> <li>\ud83d\udd22 Tipo del ID: usa getInt(1) o getLong(1) seg\u00fan el tipo de la columna.       </li> <li>Si la clave primaria no es autoincremental (por ejemplo, UUID), deber\u00e1s gestionarla manualmente en la aplicaci\u00f3n.    </li> </ul>"},{"location":"ud2/dml/#prevencion-de-sql-injection","title":"\ud83d\udd12 Prevenci\u00f3n de SQL Injection","text":"<p>El uso de <code>PreparedStatement</code> es la mejor pr\u00e1ctica para prevenir SQL Injection. Ejemplo de riesgo con <code>Statement</code>:</p> <pre><code>String usuario = \"pepe\";\nString password = \"' OR '1'='1\";\nString sql = \"SELECT * FROM usuarios WHERE user='\" + usuario + \"' AND pass='\" + password + \"'\";\n// Devuelve todos los usuarios, ya que la condici\u00f3n siempre es verdadera.\n</code></pre> <p>Con <code>PreparedStatement</code>:</p> <pre><code>String sql = \"SELECT * FROM usuarios WHERE user=? AND pass=?\";\ntry (PreparedStatement ps = con.prepareStatement(sql)) {\nps.setString(1, usuario);\nps.setString(2, password);\nResultSet rs = ps.executeQuery();\n}\n</code></pre> <p>En este caso, los par\u00e1metros se env\u00edan al SGBD de forma segura, sin alterar la estructura de la sentencia.</p>"},{"location":"ud2/dml/#otro-ejemplo-sql-inyection","title":"Otro Ejemplo SQL Inyection","text":"<pre><code>public void check(String name) {\nString query = \"SELECT * FROM users WHERE name = '\" + name + \"';\";\nStatement statement = connection.createStatement();\nstatement.executeUpdate(query);\n}\n</code></pre> <p>Si un usuario malintencionado escribe como nombre de usuario a consultar: </p> <p><code>Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '%</code></p> <p>Se generar\u00eda la siguiente consulta SQL, (el color verde es lo que pretende el programador, el azul es el dato, y el rojo, el c\u00f3digo SQL inyectado):</p> <p></p> <p>En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.'</p>"},{"location":"ud2/dml/#resumen","title":"\ud83d\udccc Resumen","text":"<ul> <li>El DML (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) modifica registros de la base de datos.  </li> <li><code>PreparedStatement</code> es preferible porque:  </li> <li>Permite parametrizar valores.  </li> <li>Mejora el rendimiento en ejecuciones repetidas.  </li> <li>Previene ataques de SQL Injection.  </li> </ul>"},{"location":"ud2/dql/","title":"\ud83d\udd0e Consultas y manipulaci\u00f3n de resultados con JDBC (DQL)","text":""},{"location":"ud2/dql/#sentencias-select","title":"\ud83d\udcd8 Sentencias SELECT","text":"<p>Las consultas de lectura en SQL se realizan mediante la sentencia SELECT. Ejemplos:</p> <pre><code>SELECT * FROM alumnos;\nSELECT nombre, edad FROM alumnos WHERE edad &gt; 18;\nSELECT COUNT(*) FROM alumnos;\n</code></pre> <p>En JDBC, las sentencias <code>SELECT</code> se ejecutan con el m\u00e9todo <code>executeQuery()</code>, que devuelve un objeto <code>ResultSet</code>.</p>"},{"location":"ud2/dql/#objeto-resultset","title":"\ud83d\udcca Objeto ResultSet","text":"<p>El objeto <code>ResultSet</code> representa la tabla de resultados de una consulta SQL. Permite recorrer fila a fila los registros devueltos por la consulta y acceder a las columnas por nombre o por \u00edndice.</p> <p>Ejemplo:</p> <pre><code>String sql = \"SELECT id, nombre, edad FROM alumnos\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement();\nResultSet rs = st.executeQuery(sql)) {\nwhile (rs.next()) {\nint id = rs.getInt(\"id\");\nString nombre = rs.getString(\"nombre\");\nint edad = rs.getInt(\"edad\");\nSystem.out.println(id + \" - \" + nombre + \" - \" + edad);\n}\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/dql/#tipos-de-cursores","title":"\ud83d\udd04 Tipos de cursores","text":"<p>El <code>ResultSet</code> se comporta como un cursor que recorre los resultados.  </p> <p>Existen distintos tipos seg\u00fan c\u00f3mo se puedan mover, pero nosotros usaremos el Forward-only (por defecto): - Solo permite avanzar hacia adelante (<code>next()</code>). - Es el m\u00e1s r\u00e1pido y ligero.</p>"},{"location":"ud2/dql/#mapeo-de-resultados-a-objetos","title":"\ud83e\udde9 Mapeo de resultados a objetos","text":"<p>En aplicaciones reales, los datos obtenidos con <code>ResultSet</code> suelen mapearse a objetos de Java. Esto permite trabajar de forma m\u00e1s natural con la informaci\u00f3n.</p> <p>Ejemplo: mapeo a una clase <code>Alumno</code>.</p> <pre><code>public class Alumno {\nprivate int id;\nprivate String nombre;\nprivate int edad;\n// Constructor, getters y setters...\n}\n</code></pre> <p>Uso en la consulta:</p> <pre><code>List&lt;Alumno&gt; lista = new ArrayList&lt;&gt;();\nString sql = \"SELECT id, nombre, edad FROM alumnos\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nStatement st = con.createStatement();\nResultSet rs = st.executeQuery(sql)) {\nwhile (rs.next()) {\nAlumno a = new Alumno();\na.setId(rs.getInt(\"id\"));\na.setNombre(rs.getString(\"nombre\"));\na.setEdad(rs.getInt(\"edad\"));\nlista.add(a);\n}\n} catch (SQLException e) {\ne.printStackTrace();\n}\nSystem.out.println(\"Alumnos cargados: \" + lista.size());\n</code></pre>"},{"location":"ud2/dql/#statement-vs-preparedstatement-en-consultas-select","title":"\ud83d\udee0\ufe0f Statement vs PreparedStatement en consultas SELECT","text":"<p>En las consultas DQL (<code>SELECT</code>) se pueden usar tanto <code>Statement</code> como <code>PreparedStatement</code>, pero presentan diferencias importantes:</p>"},{"location":"ud2/dql/#statement","title":"\ud83d\udcc4 Statement","text":"<ul> <li>Adecuado para consultas simples y est\u00e1ticas.  </li> <li>Ejemplo: <pre><code>Statement st = con.createStatement();\nResultSet rs = st.executeQuery(\"SELECT * FROM alumnos\");\n</code></pre></li> <li>\u2705 Ventaja: sencillo de usar en pruebas o consultas fijas.</li> <li>\u274c Inconveniente: vulnerable a SQL Injection si concatenamos par\u00e1metros en la cadena SQL.</li> </ul>"},{"location":"ud2/dql/#preparedstatement","title":"\ud83d\udd12 PreparedStatement","text":"<ul> <li>Recomendado para consultas con par\u00e1metros din\u00e1micos.</li> <li>Ejemplo: <pre><code>String sql = \"SELECT * FROM alumnos WHERE edad &gt; ?\";\nPreparedStatement ps = con.prepareStatement(sql);\nps.setInt(1, 18);\nResultSet rs = ps.executeQuery();\n</code></pre></li> <li>\u2705 Ventajas:</li> <li>Previene ataques de SQL Injection.</li> <li>Mejor rendimiento en consultas repetidas (se precompila en el SGBD).</li> <li>C\u00f3digo m\u00e1s claro y mantenible.</li> </ul>"},{"location":"ud2/dql/#resumen","title":"\ud83d\udccc Resumen","text":"<ul> <li>Las consultas SQL se realizan con <code>SELECT</code>.  </li> <li>En JDBC, se ejecutan con <code>executeQuery()</code>, que devuelve un <code>ResultSet</code>.  </li> <li><code>ResultSet</code> permite recorrer los registros y acceder a los valores por nombre o \u00edndice.  </li> <li>Los cursores pueden ser forward-only o scrollable.  </li> <li>Es buena pr\u00e1ctica mapear los resultados a objetos Java para facilitar el manejo de datos en la aplicaci\u00f3n.</li> </ul>"},{"location":"ud2/mapeo/","title":"\ud83d\udd0c Introducci\u00f3n a JDBC y conectores","text":"<p>Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos.</p> <p>En este curso, nos vamos a centrar en JDBC (Java Data Base Connectivity), puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos.</p>"},{"location":"ud2/mapeo/#que-es-jdbc","title":"\ud83d\udcd6 \u00bfQu\u00e9 es JDBC?","text":"<p>JDBC (Java DataBase Connectivity) es una API de Java dise\u00f1ada por Sun/Oracle que permite a las aplicaciones acceder a bases de datos relacionales de manera uniforme. Con JDBC podemos:</p> <ul> <li>\ud83d\udd17 Conectarnos a diferentes sistemas gestores de bases de datos (SGBD).  </li> <li>\ud83d\udcdd Ejecutar sentencias SQL.  </li> <li>\ud83d\udcca Recuperar y manipular resultados.  </li> </ul> <p>\ud83d\udc49 En resumen, JDBC act\u00faa como un puente entre Java y la base de datos.</p>"},{"location":"ud2/mapeo/#el-desfase-objetorelacional","title":"\u2696\ufe0f El desfase objeto\u2013relacional","text":"<p>Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos.</p> <p>Java trabaja con objetos, mientras que las bases de datos relacionales almacenan informaci\u00f3n en tablas con filas y columnas. Este desajuste se conoce como desfase objeto\u2013relacional (Object\u2013Relational Impedance Mismatch).</p> <p>Ejemplos de problemas comunes:</p> <ul> <li>\ud83d\udd04 Conversi\u00f3n entre tipos de datos (<code>int</code> \u2194 <code>INTEGER</code>, <code>String</code> \u2194 <code>VARCHAR</code>).  </li> <li>\ud83d\udd17 Representaci\u00f3n de relaciones (1:N, N:M) en estructuras de objetos.  </li> <li>\ud83e\uddec Manejo de herencia en BBDD que no la soportan de forma nativa.  </li> </ul> <p>\ud83d\udc49 En esta UD lo resolveremos manualmente con JDBC. M\u00e1s adelante veremos soluciones ORM como Hibernate.</p>"},{"location":"ud2/mapeo/#protocolos-de-acceso-a-bases-de-datos","title":"\ud83c\udf10 Protocolos de acceso a bases de datos","text":"<p>Los conectores JDBC utilizan protocolos de acceso est\u00e1ndar para comunicarse con el SGBD. Una URL de conexi\u00f3n JDBC suele tener la siguiente forma:</p> <p>Example \ud83e\udd13</p> <ul> <li>jdbc:bbdd://server:port/schema</li> <li>jdbc:mysql://localhost:3306/severo</li> </ul>"},{"location":"ud2/mapeo/#tipos-de-conectores-jdbc","title":"\ud83d\udd27 Tipos de conectores JDBC","text":"<p>Un conector JDBC (driver) es una librer\u00eda que implementa las interfaces de JDBC para un SGBD espec\u00edfico. Cada gestor (MySQL, PostgreSQL, Oracle\u2026) tiene su propio driver.</p> <p>Existen dos tipos principales:</p>"},{"location":"ud2/mapeo/#drivers-embebidos-embedded","title":"\ud83d\uddc2\ufe0f Drivers embebidos (embedded)","text":"<ul> <li>La base de datos se ejecuta dentro de la aplicaci\u00f3n.  </li> <li>Ejemplos: H2, Apache Derby.  </li> <li>\u2705 Ventajas: sencillos, portables, sin instalaci\u00f3n aparte.  </li> <li>\u274c Inconvenientes: poca escalabilidad, no aptos para producci\u00f3n masiva.  </li> </ul>"},{"location":"ud2/mapeo/#drivers-independientes-cliente-servidor","title":"\ud83d\udda5\ufe0f Drivers independientes (cliente-servidor)","text":"<ul> <li>Se conectan a un SGBD externo.  </li> <li>Ejemplos: MySQL, PostgreSQL, Oracle.  </li> <li>\u2705 Ventajas: potentes, multiusuario, adecuados para aplicaciones reales.  </li> <li>\u274c Inconvenientes: requieren instalaci\u00f3n y configuraci\u00f3n del servidor.  </li> </ul>"},{"location":"ud2/persistencia/","title":"\ud83d\udcbe Persistencia de la informaci\u00f3n","text":"<p>En la mayor\u00eda de aplicaciones, los datos no deben desaparecer al cerrar el programa: necesitamos guardarlos de forma persistente para poder volver a utilizarlos m\u00e1s tarde. A esta capacidad de guardar el estado de un objeto en un almacenamiento (ficheros, bases de datos, etc.) y restaurarlo posteriormente se le llama persistencia de la informaci\u00f3n.</p> <p></p> <p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar grandes vol\u00famenes de datos. Estos datos suelen guardarse en bases de datos relacionales, ya que son las m\u00e1s extendidas y estandarizadas.</p>"},{"location":"ud2/persistencia/#tipos-de-bases-de-datos","title":"\ud83d\udcc2 Tipos de bases de datos","text":"<p>Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que puedan consultarse y analizarse de forma eficiente. Las m\u00e1s modernas incorporan motores de an\u00e1lisis que permiten obtener informes y resultados complejos.</p> <p>Existen distintos tipos de bases de datos seg\u00fan su modelo de almacenamiento:</p> <ul> <li>Relacionales (SQL) \u2192 Representan la informaci\u00f3n en forma de tablas con filas y columnas que se relacionan mediante claves. Se consultan con el lenguaje SQL.  </li> <li>Distribuidas \u2192 Reparten los datos entre varios servidores o nodos, aumentando la disponibilidad y tolerancia a fallos.  </li> <li>NoSQL \u2192 No siguen un modelo tabular. Incluyen bases de datos de documentos (MongoDB), clave\u2013valor (Redis), orientadas a columnas (Cassandra) o a grafos.  </li> <li>Orientadas a objetos \u2192 Guardan objetos completos, m\u00e1s cercanas al paradigma de la Programaci\u00f3n Orientada a Objetos.  </li> <li>Gr\u00e1ficas \u2192 Optimizadas para representar y consultar relaciones complejas (ej.: redes sociales, rutas).  </li> </ul>"},{"location":"ud2/persistencia/#bases-de-datos-relacionales-y-sql","title":"\ud83d\udcdd Bases de datos relacionales y SQL","text":"<p>Las bases de datos relacionales (RDB) almacenan la informaci\u00f3n en tablas relacionadas entre s\u00ed mediante claves primarias y for\u00e1neas. Su lenguaje est\u00e1ndar es SQL (Structured Query Language), que permite:</p> <ul> <li>\ud83c\udfd7\ufe0f Definir estructuras de datos (DDL \u2013 Data Definition Language).  </li> <li>\u270d\ufe0f Insertar, modificar o eliminar registros (DML \u2013 Data Manipulation Language).  </li> <li>\ud83d\udd0d Realizar consultas para obtener informaci\u00f3n (DQL \u2013 Data Query Language).  </li> </ul>"},{"location":"ud2/persistencia/#sistemas-gestores-de-bases-de-datos-dbms-rdbms","title":"\ud83d\udee0\ufe0f Sistemas gestores de bases de datos (DBMS / RDBMS)","text":"<p>Un DBMS (Database Management System) es el software encargado de gestionar c\u00f3mo se almacenan, mantienen y recuperan los datos.</p> <p>Cuando el DBMS sigue el modelo relacional, se denomina RDBMS (Relational DBMS).</p> <p></p>"},{"location":"ud2/persistencia/#evolucion-y-necesidad-de-estandares","title":"\ud83d\udcc8 Evoluci\u00f3n y necesidad de est\u00e1ndares","text":"<p>En el pasado, trabajar con bases de datos resultaba complejo debido a la gran diversidad de productos, cada uno con su propio lenguaje y caracter\u00edsticas. Para solventar este problema, se estandariz\u00f3 el uso de SQL y, en el caso de Java, se cre\u00f3 una API com\u00fan: JDBC.</p> <p>\ud83d\udc49 En las siguientes secciones estudiaremos c\u00f3mo usar JDBC en Java para acceder a diferentes bases de datos sin depender directamente de cada gestor.</p>"},{"location":"ud2/procedures/","title":"\ud83d\udcd8 Procedimientos almacenados y CallableStatement","text":""},{"location":"ud2/procedures/#que-es-un-procedimiento-almacenado","title":"\ud83d\udcd8 \u00bfQu\u00e9 es un procedimiento almacenado?","text":"<p>Un procedimiento almacenado es un conjunto de sentencias SQL que se guarda en la base de datos y puede ejecutarse cuando se necesite. Se utiliza para:</p> <ul> <li>Reutilizar l\u00f3gica de negocio en el servidor.  </li> <li>Mejorar el rendimiento (menos tr\u00e1fico entre aplicaci\u00f3n y BD).  </li> <li>Centralizar validaciones o c\u00e1lculos.  </li> </ul> <p>Ejemplo en MySQL:</p> <pre><code>DELIMITER //\nCREATE PROCEDURE obtener_alumnos_mayores(IN edad_min INT)\nBEGIN\nSELECT * FROM alumnos WHERE edad &gt; edad_min;\nEND //\nDELIMITER ;\n</code></pre>"},{"location":"ud2/procedures/#ejecucion-en-java-con-callablestatement","title":"\ud83d\udcbb Ejecuci\u00f3n en Java con <code>CallableStatement</code>","text":"<p>Para invocar un procedimiento almacenado en JDBC se utiliza la interfaz <code>CallableStatement</code>. Se obtiene a trav\u00e9s de la conexi\u00f3n con el m\u00e9todo <code>prepareCall()</code>. Ejemplo b\u00e1sico:</p> <pre><code>String sql = \"{ call obtener_alumnos_mayores(?) }\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nCallableStatement cs = con.prepareCall(sql)) {\n// Par\u00e1metro de entrada\ncs.setInt(1, 18);\n// Ejecutar procedimiento\nResultSet rs = cs.executeQuery();\nwhile (rs.next()) {\nSystem.out.println(rs.getString(\"nombre\") + \" - \" + rs.getInt(\"edad\"));\n}\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/procedures/#parametros-de-entrada-y-salida","title":"\ud83d\udd04 Par\u00e1metros de entrada y salida","text":"<p>Los procedimientos almacenados pueden tener par\u00e1metros de entrada (IN), de salida (OUT) o ambos (INOUT).  </p> <p>Ejemplo de procedimiento con salida en MySQL:</p> <pre><code>DELIMITER //\nCREATE PROCEDURE contar_alumnos(IN edad_min INT, OUT total INT)\nBEGIN\nSELECT COUNT(*) INTO total FROM alumnos WHERE edad &gt; edad_min;\nEND //\nDELIMITER ;\n</code></pre> <p>Uso en Java:</p> <pre><code>String sql = \"{ call contar_alumnos(?, ?) }\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nCallableStatement cs = con.prepareCall(sql)) {\ncs.setInt(1, 18); // Par\u00e1metro IN\ncs.registerOutParameter(2, java.sql.Types.INTEGER); // Par\u00e1metro OUT\nboolean hasResultSet = cs.execute();\nint total = cs.getInt(2);\nSystem.out.println(\"N\u00famero de alumnos mayores de 18: \" + total);\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/procedures/#funciones-almacenadas","title":"\ud83e\uddfe Funciones almacenadas","text":"<p>Una funci\u00f3n almacenada es similar a un procedimiento, pero con diferencias importantes:</p> <ul> <li>Siempre devuelve un \u00fanico valor con <code>RETURN</code>.  </li> <li>Solo acepta par\u00e1metros de entrada (IN).  </li> <li>Puede usarse dentro de consultas SQL, igual que las funciones nativas (<code>SUM</code>, <code>AVG</code>, <code>NOW</code>, etc.).  </li> <li>Es ideal para realizar c\u00e1lculos o transformaciones sobre datos.</li> </ul>"},{"location":"ud2/procedures/#ejemplo-en-mysql","title":"\ud83d\udcd8 Ejemplo en MySQL","text":"<pre><code>DELIMITER //\nCREATE FUNCTION calcular_edad_media() RETURNS DECIMAL(5,2)\nNOT DETERMINISTIC\nREADS SQL DATA\nBEGIN\nDECLARE media DECIMAL(5,2);\nSELECT AVG(edad) INTO media FROM alumnos;\nRETURN media;\nEND //\nDELIMITER ;\n</code></pre>"},{"location":"ud2/procedures/#ejemplo-en-java-con-callablestatement","title":"\ud83d\udcbb Ejemplo en Java con CallableStatement","text":"<p>En JDBC se puede invocar una funci\u00f3n almacenada usando <code>CallableStatement</code>. La sintaxis utiliza <code>? = call ...</code> para capturar el valor devuelto.</p> <pre><code>String sql = \"{ ? = call calcular_edad_media() }\";\ntry (final Connection con = DriverManager.getConnection(url, user, password);\nCallableStatement cs = con.prepareCall(sql)) {\n// Registrar el par\u00e1metro de salida\ncs.registerOutParameter(1, java.sql.Types.DECIMAL);\n// Ejecutar\nboolean hasResultSet = cs.execute();\n// Recuperar el valor devuelto\ndouble media = cs.getDouble(1);\nSystem.out.println(\"Edad media: \" + media);\n} catch (SQLException e) {\ne.printStackTrace();\n}\n</code></pre>"},{"location":"ud2/procedures/#diferencia-con-procedimientos","title":"\ud83d\udccc Diferencia con procedimientos","text":"<ul> <li>Procedimiento almacenado \u2192 puede tener IN, OUT, INOUT y devolver conjuntos de resultados.</li> <li>Funci\u00f3n almacenada \u2192 solo IN, y devuelve un valor \u00fanico con RETURN.</li> </ul>"},{"location":"ud2/procedures/#resumen","title":"\ud83d\udccc Resumen","text":"<ul> <li>Los procedimientos y funciones almacenados permiten encapsular l\u00f3gica SQL en la base de datos.  </li> <li>Se ejecutan desde Java con <code>CallableStatement</code>.</li> <li>Son \u00fatiles para mejorar el rendimiento y la reutilizaci\u00f3n de c\u00f3digo.</li> <li>Solo OUT/INOUT \u2192 execute() y lee los OUT. No necesitas if (cs.execute()).</li> <li>Procedure que devuelve ResultSet \u2192 if(execute()) y usa el booleano/getResultSet().</li> <li>Si sabes que viene solo un ResultSet \u2192 executeQuery().</li> <li>No uses executeQuery() con OUT: puede fallar en algunos drivers.</li> </ul>"},{"location":"ud2/transactions/","title":"\u26a1Gesti\u00f3n de transacciones en JDBC","text":""},{"location":"ud2/transactions/#concepto-de-transaccion","title":"\ud83d\udcd8 Concepto de transacci\u00f3n","text":"<p>En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es un conjunto de sentencias SQL que se ejecutan como si fueran una sola, es decir, de forma at\u00f3mica. o se realizan todas con \u00e9xito, o ninguna de ellas se aplica. La idea principal es que las operaciones que la componen se deben ejecutar todas o ninguna. Esto ayuda a preservar la integridad de los datos e impide posibles desfases entre clientes y servidor.</p> <p>Una transacci\u00f3n tiene dos finales posibles: - <code>COMMIT</code> \u2192 confirma los cambios en la base de datos. - <code>ROLLBACK</code> \u2192 deshace los cambios efectuados hasta el momento.</p> <p></p> <p>Propiedades ACID de una transacci\u00f3n:</p> <ul> <li>Atomicidad \u2192 todas las operaciones se ejecutan o se deshacen.</li> <li>Consistencia \u2192 la base de datos pasa de un estado v\u00e1lido a otro v\u00e1lido.</li> <li>Aislamiento \u2192 las transacciones concurrentes no interfieren entre s\u00ed.</li> <li>Durabilidad \u2192 una vez confirmado, el resultado es permanente.</li> </ul>"},{"location":"ud2/transactions/#auto-commit-en-jdbc","title":"\u26a1 Auto-commit en JDBC","text":"<p>Por defecto, al menos en MySQL, una conexi\u00f3n trabaja en modo auto-commit = true. Esto significa que cada sentencia SQL es en s\u00ed misma una transacci\u00f3n: los cambios se aplican autom\u00e1ticamente si no hay error.  </p> <p>Para definir transacciones manuales de varias operaciones, debemos desactivar el auto-commit:</p> <pre><code>con.setAutoCommit(false);\n</code></pre>"},{"location":"ud2/transactions/#commit-y-rollback","title":"\u2705 commit() y \u274c rollback()","text":"<p>Cuando el auto-commit est\u00e1 desactivado, debemos controlar expl\u00edcitamente el final de la transacci\u00f3n: - commit() \u2192 Confirma la transacci\u00f3n y hace permanentes los cambios. - rollback() \u2192 Revierte los cambios realizados desde el \u00faltimo commit o rollback.  </p> <pre><code>public static void execute (String [] sqlqueries) throws SQLException {\nString user = \"patricia\";\nString password = \"marti\";\nString url = \"jdbc:mysql://localhost/severo_ad\";\ntry (final Connection con = DriverManager.getConnection(url, user, password)) {\ntry (Statement stmt = con.createStatement()) {\ncon.setAutoCommit(false);\nfor (String query : sqlqueries) {\nstmt.executeUpdate(query);\n}\ncon.commit();\ncon.setAutoCommit(true);\n} catch (SQLException ex) {\ncon.rollback();\nSystem.out.println(\"Error en la transacci\u00f3n. Cambios revertidos.\");\n}\n}\n}\n</code></pre>"},{"location":"ud3/31mapeo/","title":"\ud83d\uddc2\ufe0f Fundamentos del ORM","text":""},{"location":"ud3/31mapeo/#concepto-de-mapeo-objetorelacional-orm","title":"\ud83e\udde9 Concepto de mapeo objeto\u2011relacional (ORM)","text":"<p>Idea clave: El mapeo objeto-relacional es el conjunto de reglas que relaciona tu modelo orientado a objetos (clases, atributos, asociaciones, herencia) con el modelo relacional de una base de datos (tablas, columnas, claves y relaciones). Un ORM implementa este mapeo para que trabajes con objetos y no con SQL de bajo nivel.</p>"},{"location":"ud3/31mapeo/#correspondencias-basicas","title":"Correspondencias b\u00e1sicas","text":"<ul> <li>Clase \u2194 Tabla</li> <li>Atributo \u2194 Columna</li> <li>Identidad \u2194 Clave primaria</li> <li>Asociaci\u00f3n \u2194 Relaci\u00f3n</li> </ul>"},{"location":"ud3/31mapeo/#problemas-con-jdbc-y-necesidad-de-un-orm","title":"\u2699\ufe0f Problemas con JDBC y necesidad de un ORM","text":"<p>Aunque JDBC nos permit\u00eda abstraer la conexi\u00f3n del driver con la base de datos correcta, todav\u00eda presenta limitaciones:</p> <ul> <li>N\u00famero importante de l\u00edneas de c\u00f3digo.  </li> <li>Necesidad de trabajar con los dos modelos (relacional y orientado a objetos).  </li> <li>Cuanto mayor crece la base de datos m\u00e1s complicado resulta el mantenimiento.  </li> <li>Gesti\u00f3n manual de conexi\u00f3n, cierre de conexi\u00f3n, etc.  </li> <li>Persisten los problemas del desfase objeto-relacional: debemos descomponer los objetos para construir sentencias INSERT, DELETE o UPDATE.</li> </ul> <p></p>"},{"location":"ud3/31mapeo/#por-que-necesitamos-un-orm","title":"\ud83e\uddea \u00bfPor qu\u00e9 necesitamos un ORM?","text":"<p>Un ORM (Object Relational Mapping) act\u00faa como una capa intermedia que: - Define c\u00f3mo mapear clases \u2194 tablas y atributos \u2194 columnas. - Permite trabajar con objetos en memoria y sincronizarlos con la base de datos. - Ofrece una API unificada para operaciones de persistencia.</p> <p>Ejemplo con Hibernate:</p> <pre><code>Usuario u = new Usuario(\"ana\", \"1234\");\nsession.save(u);\n</code></pre>"},{"location":"ud3/31mapeo/#ventajas-de-orm","title":"\u2705 Ventajas de ORM","text":"<ul> <li>Menos c\u00f3digo repetitivo.  </li> <li>Persistencia de objetos con <code>persist()</code>.  </li> <li>Recuperaci\u00f3n sencilla de objetos con <code>get()</code> o <code>load()</code>.  </li> <li>Lenguaje propio de consultas (HQL, JPQL).  </li> <li>Independencia del motor de base de datos.  </li> </ul>"},{"location":"ud3/31mapeo/#desventajas-de-orm","title":"\u274c Desventajas de ORM","text":"<ul> <li>Curva de aprendizaje pronunciada.  </li> <li>Menor rendimiento relativo (traducci\u00f3n de consultas).  </li> <li>Complejidad en sistemas con modelos relacionales muy avanzados.  </li> </ul>"},{"location":"ud3/31mapeo/#caracteristicas-de-las-herramientas-orm","title":"\ud83d\udd0c Caracter\u00edsticas de las herramientas ORM","text":"<p>Las herramientas ORM comparten una serie de caracter\u00edsticas comunes:</p> <ul> <li>Abstracci\u00f3n del acceso a la base de datos: el programador trabaja con objetos.  </li> <li>Automatizaci\u00f3n del mapeo: entre clases \u2194 tablas y atributos \u2194 columnas.  </li> <li>Gesti\u00f3n de sesiones y estados: objetos transitorios, persistentes, separados.  </li> <li>Lenguaje de consultas orientado a objetos: HQL (Hibernate Query Language), JPQL (Java Persistence Query Language).  </li> <li>Gesti\u00f3n de transacciones integrada.  </li> <li>Independencia del motor de BD: cambiar de MySQL a PostgreSQL sin apenas modificar c\u00f3digo.  </li> <li>Compatibilidad con herencia y relaciones complejas.  </li> </ul>"},{"location":"ud3/31mapeo/#herramientas-orm-mas-utilizadas","title":"\ud83d\udce6 Herramientas ORM m\u00e1s utilizadas","text":"<ul> <li>Hibernate (Java).  </li> <li>JPA (Jakarta Persistence API) \u2013 est\u00e1ndar en Java EE y Spring.  </li> <li>EclipseLink (implementaci\u00f3n oficial de JPA).  </li> <li>MyBatis (Java, con mayor control de SQL).  </li> <li>Entity Framework (C#/.NET).  </li> <li>Django ORM (Python).  </li> <li>Sequelize (Node.js).  </li> </ul>"},{"location":"ud3/32jpa/","title":"Jakarta - JPA (Java Persistence API)","text":"<p>JPA es una especificaci\u00f3n que ofrece Java para implementar un Framework Object Relational Mapping (ORM), \u00e9sta especificaci\u00f3n indica c\u00f3mo se debe realizar la persistencia de los objetos en programas Java. </p> <p>F\u00edjate que se ha destacado la palabra \"especificaci\u00f3n\" porque JPA no tiene una implementaci\u00f3n concreta, sino que, existen diversas tecnolog\u00edas que implementan JPA para darle concreci\u00f3n.</p> <p>Persistencia en este contexto cubre tres \u00e1reas:</p> <ul> <li>La API en s\u00ed misma, definida en el paquete <code>jakarta.persistence</code></li> <li>El lenguaje de consulta Java Persistence Query Language (JPQL).</li> <li>Metadatos objeto/relacional.</li> </ul> <p>Importante</p> <p>The JPA was renamed as Jakarta Persistence in 2019 and version 3.0 was released in 2020. This included the renaming of packages and properties from javax.persistence to jakarta.persistence.</p>"},{"location":"ud3/32jpa/#como-funciona-jpa","title":"\u00bfC\u00f3mo funciona JPA?","text":"<p>Dado que es una especificaci\u00f3n, JPA no proporciona clase alguna para poder trabajar con la informaci\u00f3n. Lo que hace es proveernos de una serie de interfaces que podemos utilizar para implementar la capa de persistencia de nuestra aplicaci\u00f3n, apoy\u00e1ndonos en alguna implementaci\u00f3n concreta de JPA.</p> <p>Es decir, en la pr\u00e1ctica significa que lo que vamos a utilizar es una biblioteca de persistencia que implemente JPA, no JPA directamente.</p>"},{"location":"ud3/32jpa/#arquitectura","title":"Arquitectura","text":""},{"location":"ud3/32jpa/#entidades-entity","title":"\ud83d\udd05 Entidades - Entity","text":"<p>El concepto de entidad est\u00e1 muy relacionado con los SGBD y los modelos relacionales, sobre todo en sus fases de dise\u00f1o inicial con el que se denomina modelo Entidad-Relaci\u00f3n. Para JPA, las entidades son aquellos objetos de los que se desea almacenar su estado y que acabar\u00e1n transform\u00e1ndose en tablas y relaciones.</p> <p>En JPA todas las entidades son persistentes, pero no todos los objetos lo son. Para hacer que un objeto sea persistente hay que calificarlo de entidad o bien debe formar parte del estado de una entidad (en forma de atributo, por ejemplo).</p> <p>Todas las entidades se deben poder identificar de forma \u00fanica a partir de su estado. Normalmente, ser\u00e1 suficiente con una peque\u00f1a parte de sus atributos para lograr la identificaci\u00f3n. La selecci\u00f3n de atributos que cumplan este objetivo se denominan identificadores, y en el SGBD actuar\u00e1n como clave primaria.</p>"},{"location":"ud3/32jpa/#entitymanagerfactory-y-entitymanager","title":"\ud83d\udd05 EntityManagerFactory y EntityManager","text":"<p>JPA implementa una interfaz llamada <code>EntityManager</code> que actuar\u00e1 de gestor de las entidades de la aplicaci\u00f3n. Sobre esta clase recae toda la funcionalidad referida a los procesos de persistencia y sincronizaci\u00f3n de las entidades. Se trata, seguramente, de la clase m\u00e1s importante de la biblioteca JPA.</p> <p></p> <p>Un <code>EntityManager</code> asume toda la funcionalidad que una aplicaci\u00f3n pueda necesitar, pero \u00fanicamente a nivel local. JPA no permite instanciar los EntityManager directamente, sino que obliga a instanciarlos desde un <code>EntityManagerFactory</code>, el cual a su vez s\u00f3lo podr\u00e1 ser instanciado por la clase <code>Persistence</code>. Por consiguiente , el <code>EntityManager</code> ser\u00e1 el encargado de realizar todas las operaciones de tipo CRUD ( insertar , borrar ,seleccionar y actualizar etc) sobre las entidades.</p> <p>La responsabilidad del <code>EntityManagerFactory</code> est\u00e1 restringida a la creaci\u00f3n de gestores de entidades capaces de compartir un contexto de persistencia de forma coordinada.</p> <p>En una aplicaci\u00f3n, tambi\u00e9n en las distribuidas, s\u00f3lo puede haber una \u00fanica instancia de EntityManagerFactory por cada SGBD que haya que controlar. Cualquier intento de duplicar la EntityManagerFactory podr\u00eda dar resultados inconsistentes y totalmente inesperados. Es por ello que JPA obliga a instanciar los <code>EntityManagerFactory</code> usando el m\u00e9todo est\u00e1tico de la clase Persistence llamado <code>createEntityManagerFactory</code>.</p> <p>Importante</p> <p>La primera vez que se instancie un EntityManager se conectar\u00e1 al SGBD y comprobar\u00e1 si existen todas las tablas necesarias para mantener la persistencia de las entidades que este EntityManager controle. En caso de que falte alguna, se generar\u00e1n las sentencias de creaci\u00f3n adecuadas de acuerdo con los metadatos le\u00eddas del mapeo.</p>"},{"location":"ud3/32jpa/#jpa-y-persistencecontext","title":"\ud83d\udd05 JPA y PersistenceContext","text":"<p>\u00bfQu\u00e9 es un PersistenceContext? . En primer lugar hay que tener en cuenta que un EntityManager persistir\u00e1 un \u201cconjunto de objetos\u201d \u00bfPero qu\u00e9 objetos? Aquellos que hayan sufrido modificaciones a nivel de sus propiedades o atributos y no est\u00e9n sincronizados. Esto es a lo que comunmente se le denomina PersistenceContext.</p> <p></p> <p>Para conseguir que alguno de nuestros objetos pase a ubicarse dentro del PersistenceContext bastar\u00e1 con invocar los m\u00e9todos persist, merge, sobre \u00e9l.</p> <p></p> <pre><code>public static void main(String[] args) {\nPersona yo = new Persona(\"Patricia\", 12);\nEntityManagerFactory emf =\nPersistence.createEntityManagerFactory(\"default\");\nEntityManager em = emf.createEntityManager();\ntry {\nem.getTransaction().begin();\nem.persist(yo);\nem.getTransaction().commit();\n} catch (Exception e) {\ne.printStackTrace();\n} finally {\nem.close();\n}\n}\n</code></pre>"},{"location":"ud3/32jpa/#estados-de-las-entidades-en-jpa","title":"\ud83d\udd05 Estados de las entidades en JPA","text":"<p>Una de las cosas mas importantes a entender en JPA son los distintos estados de las entidades que manejamos. JPA soporta 4 estados:</p> <ul> <li> <p>New o Transient (Transitorio): Una entidad es transitoria cuando se acaba de crear mediante el operador new, pero a\u00fan no ha sido gestionada por el EntityManager. En este estado, la entidad no tiene una representaci\u00f3n persistente en la base de datos. No est\u00e1 asociado a ning\u00fan PersistenceContext.</p> </li> <li> <p>Managed (Gestionado): Una entidad est\u00e1 gestionada cuando ha sido recuperada de la base de datos o persistida en la base de datos y se encuentra bajo el control de un EntityManager. En este estado, cualquier cambio realizado en la entidad se reflejar\u00e1 en la base de datos cuando se confirme la transacci\u00f3n.</p> </li> <li> <p>Detached (Desconectado): Una entidad se encuentra en estado desconectado cuando ha sido gestionada por un EntityManager, pero ese EntityManager ya no la gestiona. Esto suele ocurrir cuando la transacci\u00f3n en la que se recuper\u00f3 la entidad ha finalizado o si se ha cerrado el EntityManager.</p> </li> <li> <p>Removed (eliminado) : Es el estado en el cual se encuentra una entidad que esta todavia controlada por el PersistenceContext pero va a ser eliminada de la base de datos.</p> </li> </ul>"},{"location":"ud3/32jpa/#relacion-de-metodos-jpa-con-estados-de-las-entidades","title":"\ud83d\udd05 Relaci\u00f3n de m\u00e9todos JPA con estados de las entidades","text":"<ul> <li><code>persist()</code>: cambia el estado de un objeto que est\u00e1 en estado new al estado managed y lo asocia a un contexto de persistencia.</li> <li><code>remove()</code>: pasa el estado de un objeto de managed a removed.</li> <li><code>detach()</code>: un objeto que estaba en estado managed lo pasa a estado detached. Mantiene su identidad de persistencia pero ya no est\u00e1 asociado a ning\u00fan contexto de persistencia.</li> <li><code>merge()</code>: se encarga de convertir un objeto nuevo o detached en uno nuevo managed. La diferencia fundamental con persist es que, persist no asume que el objeto existe en la base de datos previamente. Algo que si se puede dar con el m\u00e9todo merge.</li> </ul>"},{"location":"ud3/32jpa/#fichero-de-persistencia","title":"\ud83d\udd05 Fichero de persistencia","text":"<p>La configuraci\u00f3n de cada <code>EntityManagerFactory</code> se consigue a trav\u00e9s de un archivo XML llamado persistence.xml. Se encuentra situado en un directorio de la aplicaci\u00f3n llamado META-INF de un proyecto Java. Este fichero se encarga de conectarnos a la base de datos y define el conjunto de entidades que vamos a gestionar, por tanto, dentro de este archivo escribiremos todas las configuraciones de conexi\u00f3n necesarias para cada SGBD. Cada configuraci\u00f3n constituir\u00e1 lo que llamamos una unidad de persistencia. </p> <p>Las unidades de persistencia se identifican por medio de un nombre, el cual pasaremos como par\u00e1metro al m\u00e9todo <code>createEntityMangerFactory</code> de la clase Persistence, de modo que el <code>EntityManagerFactory</code> creado estar\u00e1 configurado para conectarse a un SGBD espec\u00edfico. </p> <p>Nota</p> <p>Muchas aplicaciones Java conectan a varias bases de datos, por tanto tendr\u00e1n diferentes EntityManagerFactorys. Cada uno estar\u00e1 ligado un PersistenceUnit diferente.</p> <p>El formato XML del archivo sigue el esquema que puede verse en la figura. Del elemento ra\u00edz llamado Persistence se pueden describir tantos Persistence-Unit como sea necesario. </p> <p>Dentro de un Persistence-Unit encontramos el elemento Provider, que contendr\u00e1 la clase principal de la herramienta que implementar\u00e1 JPA. Tambi\u00e9n podemos incluir el conjunto de clases de nuestra aplicaci\u00f3n a considerar entidades y que ser\u00e1n los objetos de la persistencia. Finalmente, el esquema presenta una manera de parametrizar la configuraci\u00f3n en funci\u00f3n de los diferentes providers o herramientas de implementaci\u00f3n de JPA. Nos referimos al elemento Properties.</p> <p>Ejemplo:</p> persistence.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;persistence xmlns=\"https://jakarta.ee/xml/ns/persistence\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd\"\nversion=\"3.0\"&gt;\n&lt;persistence-unit name=\"default\"&gt;\n&lt;class&gt;es.severo.entity.Tramite&lt;/class&gt;\n&lt;properties&gt;\n&lt;property name=\"hibernate.connection.url\" value=\"jdbc:mysql://localhost:3306/testdb2\"/&gt;\n&lt;property name=\"hibernate.connection.driver_class\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n&lt;property name=\"hibernate.connection.username\" value=\"root\"&gt;&lt;/property&gt;\n&lt;property name=\"hibernate.connection.password\" value=\"root\"&gt;&lt;/property&gt;\n&lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n&lt;/properties&gt;\n&lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> Tag name Description \ud83c\udf00 <code>&lt;persistence-unit&gt;</code> Se define una con un nombre que debe ser \u00fanico por cada proveedor que usemos. A esta persistence-unit se le puede poner un atributo transaction-type, cuyos valores pueden ser RESOURCE_LOCAL o JTA. \ud83c\udf00 <code>&lt;provider&gt;</code> Proveedor de persistencia. JPA s\u00f3lo define la API o interfaces que se deben cumplir si se quiere usa JPA, pero no implementa esas clases. Necesitamos una librer\u00eda externa que implemente esta API. Una de las m\u00e1s conocidas es Hibernate. Para este ejemplo, usaremos dos, Hibernate y EclipseLink. Por supuesto, para tener estos proveedores, necesitamos a\u00f1adir el jar correspondiente a nuestro proyecto. Si usamos maven, las dependencias ser\u00eda una de estas dos, seg\u00fan queramos EclipseLink o hibernate. \ud83c\udf00 <code>&lt;class&gt;</code> Lo utilizamos para poner las clases que van a ser persistentes. \ud83c\udf00 <code>&lt;properties&gt;</code> Contiene los par\u00e1metros de conexi\u00f3n a la base de datos. Para ello, podemos usar bien propiedades generales definidas por JPA, o bien propiedades espec\u00edficas del proveedor de persistencia que usemos, es decir, propiedades espec\u00edficas de hibernate, de EclipseLink, etc. Yo he indicado las propiedades generales de JPA. <p>El fichero es parte del standard y existir\u00e1 en cualquier implementaci\u00f3n de JPA que se utilice.</p> <p>En resumen, para crear un EntityManager necesario tener un archivo llamado persistence.xml con el formato que se acaba de describir. Adem\u00e1s, hay que crear un EntityManagerFactory configur\u00e1ndolo a partir de una unidad de persistencia incluida en el fichero persistence.xml, el cual nos permitir\u00e1 obtener el EntityManager.</p> <p>Codigo.java<pre><code>EntityManagerFactory emf = Persistence.createEntityManagerFactory(\u201cdefault\u201d); //Es el nombre que hemos puesto en &lt;persistence-unit&gt; en el fichero persistence.xml\nEntityManager em = emf.createEntityManager();\n</code></pre> Ejemplo de c\u00f3digo para crear un EntityManager a partir del fichero anterior persistence.xml.</p>"},{"location":"ud3/32jpa/#transacciones-y-excepciones","title":"\ud83d\udd05 Transacciones y excepciones","text":"<p>En aplicaciones locales EntityManager dispone del m\u00e9todo <code>getTransaction</code> para obtener la transacci\u00f3n en curso, si la hay, o para crear una de lo contrario. Una vez creada, la transacci\u00f3n se activa invocando el m\u00e9todo begin y finaliza cuando se invoca commit.</p> <p>Todas las excepciones generadas por JPA son de tipo <code>RuntimeException</code>. Este tipo de excepci\u00f3n presenta la particularidad de que no se declarar\u00e1 en la firma del m\u00e9todo y, por tanto, el uso de try-catch no es obligatorio.</p> <p></p> <p>Este tipo de transacciones presentan la ventaja de poder escribir un c\u00f3digo m\u00e1s limpio (sin sentencias try-catch intermedias), pero por el contrario el desarrollador tiene que ir mucho m\u00e1s cuidado de no olvidarse de hacer el tratamiento de las excepciones. </p> <p>Ayuda</p> <p>Para facilitar este tratamiento, todas las excepciones JPA heredan de un antecesor com\u00fan llamado <code>PersistenceException</code>.</p>"},{"location":"ud3/32jpa/#implementaciones-de-jpa","title":"Implementaciones de JPA","text":"<p>La principal ventaja que JPA nos proporciona es que, si las bibliotecas de persistencia que utilices siguen la especificaci\u00f3n JPA, podr\u00e1s cambiar de una a otra, con m\u00e1s rendimiento o caracter\u00edsticas mejores, sin tener que tocar tu c\u00f3digo, simplemente cambiando las referencias.</p> <p>Existen diversas implementaciones disponibles, como DataNucleus, ObjectDB, o Apache OpenJPA, pero las dos m\u00e1s utilizadas son EclipseLink y sobre todo Hibernate.</p> <p>Hibernate, en la actualidad es casi el \"est\u00e1ndar\" de facto, puesto que es la m\u00e1s utilizada, sobre todo en las empresas. Es tan popular que existen hasta versiones para otras plataformas, como NHibernate para la plataforma .NET. Es un proyecto muy maduro (de hecho, la especificaci\u00f3n JPA original parti\u00f3 de \u00e9l), muy bien documentado y que tiene un gran rendimiento.</p> <p>Importante \ud83e\udd14</p> <p>Hibernate y HQL se crearon antes de la especificaci\u00f3n JPA. Hasta la versi\u00f3n Hibernate 3, JPQL es un subconjunto de HQL.</p>"},{"location":"ud3/33hibernate/","title":"3.4.- Hibernate. Contexto de persistencia","text":"<p>\ud83d\udc3b\u200d\u2744\ufe0f Hibernate, como una soluci\u00f3n ORM, efectivamente \"se ubica entre\" la capa de acceso a datos de la aplicaci\u00f3n Java y la base de datos relacional, como se puede ver en el diagrama siguiente.</p> <p>\ud83c\udf10 Documentaci\u00f3n oficial</p>"},{"location":"ud3/33hibernate/#arquitectura","title":"\u2699\ufe0f Arquitectura","text":"<p>La arquitectura \"completa\" abstrae la aplicaci\u00f3n de las APIs de JDBC/JTA y permite que Hibernate se encargue de los detalles. Hibernate usa JDBC para conectar con la BBDD y ejecutar querys.</p>"},{"location":"ud3/33hibernate/#clases-persistentes-pojos-entidades","title":"\ud83d\udce6 Clases persistentes (POJOs, entidades)","text":"<p>En JPA/Hibernate, una clase persistente es una clase \u201cnormal\u201d (POJO) que el ORM gestiona para leer/escribir su estado en la base de datos. Habitualmente la marcamos con anotaciones JPA y la llamamos entidad.</p>"},{"location":"ud3/33hibernate/#requisitos-basicos-de-una-entidad-jpa","title":"\u26a0\ufe0f Requisitos b\u00e1sicos de una entidad JPA","text":"<ul> <li><code>@Entity</code> en la clase (y opcional <code>@Table</code> para nombrar la tabla).</li> <li>Identificador con <code>@Id</code> (+ <code>@GeneratedValue</code> si es autogenerado).</li> <li>\ud83d\ude80 Incluir atributos de clase con visibilidad privada, private.</li> <li>\ud83d\ude80 Incluir getters y setters.</li> <li>Constructor no-args <code>public</code> o <code>protected</code> (lo usa el ORM).</li> <li>Clase no final y, si vas a usar proxies de Hibernate, m\u00e9todos no final (para <code>LAZY</code>).</li> <li>Evita l\u00f3gica pesada en constructor/no-args.</li> <li>Decide acceso por campo (anotaciones sobre atributos) o por propiedad (anotaciones en getters).</li> </ul>"},{"location":"ud3/33hibernate/#sesiones-y-estados-de-un-objeto","title":"\ud83e\udde0 Sesiones y estados de un objeto","text":"<p>En JPA la unidad de trabajo es el EntityManager (EM); en Hibernate cl\u00e1sico, la Session. Ambos gestionan el contexto de persistencia (cach\u00e9 de 1er nivel) y el ciclo de vida de las entidades.</p>"},{"location":"ud3/33hibernate/#persistence-context","title":"\ud83c\udff7\ufe0f Persistence Context","text":"<ul> <li>Es el conjunto de entidades gestionadas (managed) por un Session.</li> </ul>"},{"location":"ud3/33hibernate/#estados-de-una-entidad-y-transiciones","title":"\ud83e\udde8 Estados de una entidad y transiciones","text":""},{"location":"ud3/33hibernate/#transient-o-new","title":"\ud83e\udde3 <code>Transient</code> (o new)","text":"<p>Objeto creado con <code>new</code>, no est\u00e1 en BD ni gestionado por el EM. <pre><code>Usuario u = new Usuario(\"Ana\", \"ana@example.com\"); // transient\n</code></pre></p>"},{"location":"ud3/33hibernate/#managed-o-persistente","title":"\ud83e\udde3 <code>Managed</code> (o persistente)","text":"<p>Bajo control del EM; cambios se detectan (dirty checking) y se sincronizan. <pre><code>em.persist(u);               // transient -&gt; managed (INSERT en flush/commit)\nUsuario v = em.find(Usuario.class, 1L); // managed\nv.setNombre(\"Ana Maria\");    // se hace UPDATE al sincronizar\n</code></pre></p>"},{"location":"ud3/33hibernate/#detached-separado","title":"\ud83e\udde3 <code>Detached</code> (separado)","text":"<p>Entidad que estuvo managed pero ya no (cerrar EM, <code>clear()</code>, <code>detach()</code>). <pre><code>em.clear(); // todas pasan a detached\n// v ahora es detached\nUsuario w = em.merge(v); // devuelve una copia managed con los cambios\n</code></pre></p>"},{"location":"ud3/33hibernate/#removed","title":"\ud83e\udde3 <code>Removed</code>","text":"<p>Marcada para borrado; se ejecuta <code>DELETE</code> al sincronizar. <pre><code>em.remove(v); // managed -&gt; removed (DELETE en flush/commit)\n</code></pre></p>"},{"location":"ud3/33hibernate/#clase-hibernateutil","title":"Clase <code>HibernateUtil</code>","text":"<p>Crearemos esta clase de utilidad <code>HibernateUtil</code> para inicializar una sola vez el SessionFactory de Hibernate y exponerlo al resto de la aplicaci\u00f3n. Usaremos el patr\u00f3n Singleton. </p> <p>As\u00ed evitaremos crear SessionFactory repetidamente y mantenemos centralizado d\u00f3nde se configura/gestiona Hibernate.</p> <pre><code>public final class HibernateUtil {\nprivate static volatile SessionFactory sessionFactory;\nprivate static volatile StandardServiceRegistry registry;\nprivate HibernateUtil() { }\npublic static SessionFactory getSessionFactory() {\nif (sessionFactory == null) {\nProperties props = loadAppProperties();\ninit(props);\n}\nreturn sessionFactory;\n}\nprivate static synchronized void init(Properties properties) {\nif (sessionFactory == null) {\nregistry = new StandardServiceRegistryBuilder()\n.applySettings(properties)\n.build();\nsessionFactory = new MetadataSources(registry)\n.addAnnotatedClass(Customer.class)//entidades a cargar\n.addAnnotatedClass(Order.class)\n.buildMetadata()\n.buildSessionFactory();\n}\n}\nprivate static Properties loadAppProperties() {\ntry (InputStream in = Thread.currentThread()\n.getContextClassLoader()\n.getResourceAsStream(\"application.properties\")) {\nif (in == null) {\nthrow new IllegalStateException(\"No se encuentra application.properties en el classpath\");\n}\nProperties p = new Properties();\np.load(in);\nreturn p;\n} catch (Exception e) {\nthrow new RuntimeException(\"Error cargando application.properties\", e);\n}\n}\npublic static void close() {\n//Closes caches and connections pools\ngetSessionFactory().close();\n}\n}\n</code></pre> <p>Resumen de operaciones - <code>persist(x)</code> \u2192 transient \u2192 managed - <code>remove(x)</code> \u2192 managed \u2192 removed - <code>merge(x)</code> \u2192 (detached/new) \u2192 managed (devuelve otra instancia) - <code>detach(x)</code> / <code>clear()</code> \u2192 managed \u2192 detached - <code>refresh(x)</code> \u2192 recarga desde BD (descarta cambios no sincronizados) - <code>flush()</code> \u2192 fuerza sincronizaci\u00f3n ahora</p> <p></p>"},{"location":"ud3/34dao/","title":"Patr\u00f3n DAO - Data access object","text":"<p>Si bien es posible inyectar el acceso a la fuente de datos donde los necesitemos, no es una buena idea -de hecho resulta horrible- ir repartiendo su uso por el c\u00f3digo de nuestro proyecto sin seguir criterio alguno. Crearemos un caos que violar\u00e1 los principios de encapsulaci\u00f3n y desacoplamiento de la programaci\u00f3n orientado a objetos.</p> <p>Incluso habr\u00e1 ocasiones en las que necesitaremos tener m\u00e1s de una fuente de datos o la fuente de datos que tenemos variar\u00e1, lo que nos obligar\u00eda a refactorizar gran parte del c\u00f3digo.</p> <p>La soluci\u00f3n est\u00e1ndar consiste en recurrir al patr\u00f3n de dise\u00f1o Data Access Object (objeto de acceso a datos), m\u00e1s conocido por las siglas DAO. Las clases DAO son las responsables de implementar todas las operaciones con una fuente y\\o almacenamiento de datos. Fuera de ellas, el c\u00f3digo no tiene conocimiento sobre c\u00f3mo se realiza la persistencia; puede ser una base de datos relacional o \u00abno SQL\u00bb, ficheros de texto, etc\u00e9tera. </p> <p></p> <p>Exponemos una API y todo lo dem\u00e1s queda encapsulado y abstra\u00eddo en los DAOs, los cuales, generalmente, obtendremos con una factor\u00eda. Por lo com\u00fan, cuando la fuente de datos es una base de datos relacional, una clase DAO contiene todas las operaciones centradas en una tabla, es decir, crearemos un DAO para cada entidad que lo requiera.</p>"},{"location":"ud3/34dao/#transacciones-en-la-capa-service-no-en-daos","title":"Transacciones en la capa service, no en DAOs","text":"<p>El l\u00edmite de la transacci\u00f3n (abrir, confirmar, deshacer) debe estar en la capa de servicio (caso de uso), no dentro de cada m\u00e9todo DAO. As\u00ed, un \u00fanico @Transactional envuelve todas las operaciones que forman el caso de uso y o bien se confirman todas, o se deshacen todas.</p>"},{"location":"ud3/34dao/#por-que-asi","title":"\u00bfPor qu\u00e9 as\u00ed?","text":"<p>Un caso de uso suele tocar varios DAOs. Si cada DAO hiciera su propia transacci\u00f3n, tendr\u00edas commits parciales y perder\u00edas atomicidad.</p> <p>Centralizar la transacci\u00f3n en el servicio simplifica el DAO (solo hace CRUD) y la regla de negocio queda claramente delimitada.</p> <p>El DAO debe ser fino y reutilizable; no debe decidir reglas de negocio. Encapsula acceso a datos y propaga (o traduce) errores t\u00e9cnicos</p>"},{"location":"ud3/34dao/#1-creacion-de-las-interfaces-dao","title":"\ud83e\ude80 1. Creaci\u00f3n de las interfaces DAO","text":"<p>Lo primero que haremos ser\u00e1 crear las interfaces de las entidades que requieran acceso a la base de datos. Creamos interfaces para exponerlas en forma de API sus operaciones. Ya que la implementaci\u00f3n de \u00e9stas estar\u00e1 en otras clases para encapsular las operaciones.</p> <p>Usaremos los ejemplos de clase <code>Person</code> y <code>Address</code> que ten\u00edan una relaci\u00f3n muchos a muchos.</p> PersonDao.java<pre><code>public interface PersonDao {\nOptional&lt;Person&gt; findById(Session s, Long id);\nvoid saveNew(Session s, Person person);\nvoid update(Session s, Person person);\nvoid deleteById(Session s, Long id);\nvoid delete(Session s, Person person);\n}\n</code></pre> <p>Nota</p> <p>En el DAO suelen ir las operaciones comunes usadas para la entidad. La nomenclatura suele ser nombre de la entidad seguido de la palabra <code>Dao</code>.</p>"},{"location":"ud3/34dao/#2-implementacion-de-las-interfaces-dao","title":"\ud83e\ude80 2. Implementaci\u00f3n de las interfaces DAO","text":"<p>Cada interfaz DAO tendr\u00e1 su implementaci\u00f3n. Las clases que implementan las interfaces ser\u00e1n nombradas como entidad + DAO + Impl: <code>PersonDaoImpl</code>.</p> PersonDaoImpl.java<pre><code>public class PersonDaoImpl implements PersonDao {\n@Override\npublic Optional&lt;Person&gt; findById(Session s, Long id) {\nreturn Optional.ofNullable(s.get(Person.class, id));\n}\n@Override\npublic void saveNew(Session s, Person person) {\ns.persist(person); // INSERT en flush/commit\n}\n@Override\npublic void update(Session s, Person person) {\ns.merge(person);   // devuelve instancia managed (si la necesitas, cambia la firma a Person)\n}\n@Override\npublic void deleteById(Session s, Long id) {\nPerson ref = s.byId(Person.class).getReference(id); // sin SELECT\ns.remove(ref);\n}\n@Override\npublic void delete(Session s, Person person) {\nif (s.contains(person)) s.remove(person);\nelse s.remove(s.merge(person)); // asegura managed\n}\n}\n</code></pre> <p>Si hici\u00e9ramos lo mismo para la entidad <code>Address</code>, es decir, cre\u00e1ramos la interfaz <code>AddressDao</code> y su implementaci\u00f3n <code>AddressDaoImpl</code> nos dar\u00edamos cuenta de que las clases ser\u00edan muy parecidas a <code>PersonDao</code> y <code>PersonDaoImpl</code>, ya que contendr\u00eda los mismos m\u00e9todos con la \u00fanica diferencia de que cambia la entidad. Entonces estar\u00edamos creando mucha cantidad de c\u00f3digo redundante.</p>"},{"location":"ud3/34dao/#3-creacion-de-un-dao-generico","title":"\ud83e\ude80 3. Creaci\u00f3n de un DAO gen\u00e9rico","text":"<p>Para mejorar la reusabilidad y legilibidad del c\u00f3digo deber\u00edamos hacer uso de los gen\u00e9ricos que nos ofrece Java. Por tanto, se ha de crear un DAO general que incluya las funcionalidades m\u00e1s gen\u00e9ricas de los DAO, <code>GenericDao</code>.</p> GenericDao.java<pre><code>public interface GenericDao&lt;T, ID extends Serializable&gt; {\nOptional&lt;T&gt; findById(Session s, ID id);\nList&lt;T&gt; findAll(Session s);\nT saveNew(Session s, T entity);    // nuevos -&gt; persist\nT update(Session s, T entity);     // detached/upsert -&gt; merge (devuelve managed)\nvoid deleteById(Session s, ID id);\nboolean delete(Session s, T entity);\nboolean existsById(Session s, ID id);\nlong count(Session s);\n}\n</code></pre> <p>Todos los DAOs heredar\u00e1n de <code>GenericDao</code>, lo que quiere decir que todos los DAO contendr\u00e1n esos m\u00e9todos, cumplir\u00e1n con esas funciones.</p>"},{"location":"ud3/34dao/#4-implementacion-del-dao-generico","title":"\ud83e\ude80 4. Implementaci\u00f3n del DAO gen\u00e9rico","text":"GenericDaoHibernate.java<pre><code>public class GenericDaoHibernate&lt;T, ID extends Serializable&gt;\nimplements GenericDao&lt;T, ID&gt; {\nprivate final Class&lt;T&gt; entityClass;\npublic GenericDaoHibernate(Class&lt;T&gt; entityClass) {\nthis.entityClass = entityClass;\n}\n@Override\npublic Optional&lt;T&gt; findById(Session s, ID id) {\nreturn Optional.ofNullable(s.find(entityClass, id));\n}\n@Override\npublic List&lt;T&gt; findAll(Session s) {\nString hql = \"from \" + entityClass.getName();\nreturn s.createQuery(hql, entityClass).getResultList();\n}\n@Override\npublic T saveNew(Session s, T entity) {\ns.persist(entity);\ns.flush();\nreturn (ID) s.getIdentifier(entity);\n}\n@Override\npublic T update(Session s, T entity) {\nreturn s.merge(entity);\n}\n@Override\npublic void delete(Session s, T entity) {\ns.remove(entity);\n}\n@Override\npublic boolean deleteById(Session s, ID id) {\nT found = s.find(entityClass, id);\nif (found != null) {\ns.remove(found);\nreturn true;\n}\nreturn false;\n}\n@Override\npublic boolean existsById(Session s, ID id) {\n// opci\u00f3n r\u00e1pida sin traer toda la entidad\nString hql = \"select 1 from \" + entityClass.getName() + \" e where e.id = :id\";\nInteger one = s.createQuery(hql, Integer.class)\n.setParameter(\"id\", id)\n.setMaxResults(1)\n.uniqueResult();\nreturn one != null;\n}\n@Override\npublic long count(Session s) {\nString hql = \"select count(e) from \" + entityClass.getName() + \" e\";\nreturn s.createQuery(hql, Long.class).getSingleResult();\n}\n}\n</code></pre> <p>Para usarlo en el service:  </p> <pre><code>GenericDao&lt;Person, Long&gt; personDao = new GenericDaoHibernate&lt;&gt;(Person.class);\npersonDao.saveNew(s, new Person(\"Ana\", \"ana@example.com\"));\n</code></pre> <p>La creaci\u00f3n de esta clase gen\u00e9rica conlleva los siguientes cambios en las clases DAO:</p> AddressDao.java<pre><code>public interface AddressDao extends GenericDao&lt;Address, Long&gt; {\n}\n</code></pre> AddressDaoImpl.java<pre><code>public class AddressDaoImpl extends GenericDaoHibernate&lt;Address, Long&gt; implements AddressDao {\npublic AddressDaoImpl() {\nsuper(Address.class);\n}\n}\n</code></pre> <p>Ahora mismo la clase <code>AddressDao</code> no definir\u00eda ning\u00fan m\u00e9todo nuevo, solo los que ya hereda de GenericDAO. Por tanto, \u00bfpara qu\u00e9 nos sirve tener esta clase? Ahora mismo, podr\u00edamos eliminarla, ya que no tiene ninguna funcionalidad extra, pero en un futuro si queremos realizar una operaci\u00f3n muy espec\u00edfica, o una query relacionada con esa tabla, deberemos definir ese m\u00e9todo dentro de <code>AddressDaoImpl</code>.</p>"},{"location":"ud3/35service/","title":"\ud83d\udd2e Capa de servicios","text":"<p>Es conveniente separar la l\u00f3gica del c\u00f3digo de la aplicaci\u00f3n con las operaciones que acceden a la base de datos. Para ello, se puede crear una capa intermedia llamada service.</p> <p>En nuestro proyecto deberemos crear un paquete llamado <code>service</code> que contendr\u00e1 las clases necesarias para interactuar con los objetos DAO.</p> <p>Dentro del paquete service, creamos la clase <code>PersonalDataService</code> con atributos de tipo DAO y m\u00e9todos para realizar diferentes operaciones necesarias en la aplicaci\u00f3n que adem\u00e1s a\u00f1adir\u00e1n l\u00f3gica de negocio.</p> PersonalDataService.java<pre><code>public class PersonService {\nprivate final SessionFactory sf;\nprivate final PersonDao personDao;\npublic PersonService() {\nthis.sf = HibernateUtil.getSessionFactory();\nthis.personDao = new PersonDaoImpl();\n}\npublic Long create(Person p) {\nTransaction tx = null;\ntry {\nSession s = sf.getCurrentSession();      tx = s.beginTransaction();            personDao.saveNew(s, p);              tx.commit();\nreturn p.getId();\n} catch (PersistenceException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();\nthrow e;\n}\n}\npublic Optional&lt;Person&gt; findById(Long id) {\nTransaction tx = null;\ntry {\nSession s = sf.getCurrentSession();\ntx = s.beginTransaction();\nOptional&lt;Person&gt; res = personDao.findById(s, id);\ntx.commit();\nreturn res;\n} catch (PersistenceException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();\nthrow e;\n}\n}\npublic void update(Person p) {\nTransaction tx = null;\ntry {\nSession s = sf.getCurrentSession();\ntx = s.beginTransaction();\npersonDao.update(s, p);\ntx.commit();\n} catch (PersistenceException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();\nthrow e;\n}\n}\npublic void deleteById(Long id) {\nTransaction tx = null;\ntry {\nSession s = sf.getCurrentSession();\ntx = s.beginTransaction();\npersonDao.deleteById(s, id);\ntx.commit();\n} catch (PersistenceException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();\nthrow e;\n}\n}\npublic void delete(Person p) {\nTransaction tx = null;\ntry {\nSession s = sf.getCurrentSession();\ntx = s.beginTransaction();\npersonDao.delete(s, p);\ntx.commit();\n} catch (PersistenceException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();\nthrow e;\n}\n}\n}\n</code></pre> <ul> <li>SessionFactory = se crea 1 vez al inicio, se comparte; no se crea por m\u00e9todo.</li> <li>El service recibe el <code>SessionFactory</code> (y los DAOs) por constructor y abre/cierra la transacci\u00f3n por cada caso de uso.</li> </ul>"},{"location":"ud3/35service/#dao-vs-service-estructura-recomendada","title":"\u2699\ufe0f DAO vs Service \u2013 Estructura recomendada","text":""},{"location":"ud3/35service/#dao-data-access-object","title":"\ud83e\udde9 DAO (Data Access Object)","text":"<ul> <li>\ud83d\udcc4 Uno por entidad o agregado (SpaceDao, UserDao, BookingDao\u2026)        </li> <li>\ud83c\udfaf Responsabilidad: acceso a datos (persist, find, remove, queries).      </li> <li>\ud83d\udeab Sin transacciones ni l\u00f3gica de negocio.        </li> <li>\ud83d\udd04 Reutilizable desde distintos servicios.        </li> </ul>"},{"location":"ud3/35service/#service-capa-de-negocio","title":"\ud83e\udde0 Service (Capa de negocio)","text":"<ul> <li>\ud83e\udde9 Debe existir uno por caso de uso / l\u00f3gica de negocio, no necesariamente por entidad.           </li> <li>\ud83c\udfaf Responsabilidad: Agrupa y orquesta varios DAOs.         </li> <li>\ud83d\udca1 Define casos de uso completos, no solo operaciones CRUD.       </li> <li>\ud83e\uddfe Contiene la transacci\u00f3n (beginTransaction / commit / rollback).        </li> <li>\ud83d\udd10 Aplica validaciones y reglas de negocio.       </li> </ul>"},{"location":"ud3/35service/#testeo-de-la-aplicacion","title":"\ud83d\udd2e Testeo de la aplicaci\u00f3n","text":"<p>Para probar el c\u00f3digo simplemente tendremos que crear un objeto de la clase service y ejecutar los m\u00e9todos convenientes:</p> Test.java<pre><code>public class Main {\npublic static void main(String[] args) {\ntry {\nPersonService service = new PersonService();\n// usar el servicio (abrir\u00e1 transacciones con sf)\nservice.create(new Person(\"Ana\", \"ana@example.com\"));\n} catch(PersistenceException e) {\n//imprimo la excepci\u00f3n\n} finally {\nHibernateUtil.close(); // al terminar la app\n}\n}\n}\n</code></pre>"},{"location":"ud3/installation/","title":"\ud83d\udd39 Configuraci\u00f3n e instalaci\u00f3n de Hibernate. Mapeo de entidades","text":"<p>En este bloque aprenderemos a instalar y configurar Hibernate, adem\u00e1s de explorar dos formas de definir el mapeo: mediante ficheros XML y mediante anotaciones en las clases Java.</p>"},{"location":"ud3/installation/#1instalacion-y-configuracion-de-hibernate","title":"\u2699\ufe0f 1.Instalaci\u00f3n y configuraci\u00f3n de Hibernate","text":""},{"location":"ud3/installation/#dependencias","title":"Dependencias","text":"<p>La forma m\u00e1s habitual es incluir Hibernate y JPA en un proyecto Maven o Gradle.</p> <p>Ejemplo con Maven (<code>pom.xml</code>):</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n&lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n&lt;version&gt;${hibernate.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n&lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;\n&lt;version&gt;${hibernate.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.mysql&lt;/groupId&gt;\n&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n&lt;version&gt;9.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n&lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n&lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n&lt;version&gt;2.23.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"ud3/installation/#configuracion-mediante-hibernatecfgxml","title":"Configuraci\u00f3n mediante <code>hibernate.cfg.xml</code>","text":"<p>El fichero debe estar en el classpath (Maven/Gradle los copian a <code>target/classes/</code>). El fichero .cfg.xml debe crearse y hibernate debe colocarse en el classpath del proyecto, en:</p> <ul> <li>Hibernate (cl\u00e1sico) \u2192 <code>src/main/resources/hibernate.cfg.xml</code> </li> </ul> <p>Es el fichero principal de configuraci\u00f3n de Hibernate cuando trabajas sin JPA puro. En \u00e9l defines: - Conexi\u00f3n a la base de datos (driver, URL, usuario, contrase\u00f1a). - Dialecto de Hibernate. - Estrategia de creaci\u00f3n/actualizaci\u00f3n del esquema (hbm2ddl.auto). - Otras propiedades opcionales (show_sql, format_sql, etc.).</p> <pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;!DOCTYPE hibernate-configuration PUBLIC\n        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n&lt;hibernate-configuration&gt;\n&lt;session-factory&gt;\n&lt;!-- JDBC --&gt;\n&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;\n&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/mibd&lt;/property&gt;\n&lt;property name=\"hibernate.connection.username\"&gt;patri&lt;/property&gt;\n&lt;property name=\"hibernate.connection.password\"&gt;1234&lt;/property&gt;\n&lt;!-- Dialecto --&gt;\n&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n&lt;!-- Generaci\u00f3n de esquema (solo desarrollo) --&gt;\n&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;\n&lt;!-- Logging de SQL (para aprender / depurar) --&gt;\n&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;\n&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;\n&lt;!-- Zona horaria consistente --&gt;\n&lt;property name=\"hibernate.jdbc.time_zone\"&gt;UTC&lt;/property&gt;\n&lt;!-- Pool de conexiones (HikariCP) --&gt;\n&lt;property name=\"hibernate.connection.provider_class\"&gt;\norg.hibernate.hikaricp.internal.HikariCPConnectionProvider\n    &lt;/property&gt;\n&lt;property name=\"hibernate.hikari.maximumPoolSize\"&gt;10&lt;/property&gt;\n&lt;!-- Entidades anotadas --&gt;\n&lt;mapping class=\"com.ejemplo.Usuario\"/&gt;\n&lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre>"},{"location":"ud3/installation/#configuracion-mediante-applicationproperties","title":"Configuraci\u00f3n mediante <code>application.properties</code>","text":"<p>En vez de crear el fichero hibernate.cfg.xml, podemos meter toda la configuraci\u00f3n en un fichero .properties.</p> <p>Para ello, el fichero debe estar dentro de /src/main/resources/application.properties con el siguiente contenido de configuraci\u00f3n:</p> <pre><code># --- Hibernate usa Hikari internamente ---\nhibernate.connection.provider_class=org.hibernate.hikaricp.internal.HikariCPConnectionProvider\nhibernate.hikari.dataSourceClassName=com.mysql.cj.jdbc.MysqlDataSource\nhibernate.hikari.dataSource.url=jdbc:mysql://localhost:3306/newada\nhibernate.hikari.dataSource.user=root\nhibernate.hikari.dataSource.password=admin\nhibernate.hikari.autoCommit=false\n# Pool\nhibernate.hikari.maximumPoolSize=15\nhibernate.hikari.minimumIdle=5\nhibernate.hikari.idleTimeout=600000\nhibernate.hikari.maxLifetime=1700000\nhibernate.hikari.connectionTimeout=30000\n# Hibernate, La sesi\u00f3n se abre al empezar la transacci\u00f3n y se cierra al hacer commit/rollback.\nhibernate.current_session_context_class=thread\nhibernate.dialect=org.hibernate.dialect.MySQLDialect\nhibernate.hbm2ddl.auto=update\nhibernate.show_sql=false\nhibernate.format_sql=false\nhibernate.jdbc.batch_size=25\nhibernate.order_inserts=true\nhibernate.order_updates=true\nhibernate.generate_statistics=false\nhibernate.connection.provider_disables_autocommit=true\n# Opciones m\u00e1s comunes de hibernate.hbm2ddl.auto:\n#create \u2192 crea el esquema desde cero en cada arranque (borra y crea lo anterior).\n#create-drop \u2192 como create, pero adem\u00e1s borra al parar la app (borra -crea - borra, \u00fatil en tests).\n#update \u2192 crea y altera tablas/columnas necesarias sin borrar datos (ojo: no es un migrador).\n#validate \u2192 valida \u00fanicamente (Hibernate compara esquemas y falla si falta algo).\n#none (o no ponerla) \u2192 no hace nada.\n</code></pre>"},{"location":"ud3/installation/#mapeo-basado-en-anotaciones","title":"\ud83c\udff7\ufe0f Mapeo basado en anotaciones","text":"<p>El mapeo basado en anotaciones consiste en definir la correspondencia clase \u2194 tabla y atributo \u2194 columna directamente en el c\u00f3digo Java usando anotaciones de JPA/Jakarta</p>"},{"location":"ud3/installation/#1-entidad-basica","title":"\ud83d\udcc4 1 Entidad b\u00e1sica","text":"<ul> <li><code>@Entity</code> \u2192 Marca la clase como persistente.    </li> <li><code>@Table(name=\"...\")</code> \u2192 Cambia el nombre de la tabla y permite uniqueConstraints/indexes.    </li> </ul> <p>Identidad:   - <code>@Id</code> \u2192 Clave primaria.    - <code>@GeneratedValue(strategy=\u2026)</code> \u2192 Estrategia de generaci\u00f3n:          - IDENTITY (auto-increment en MySQL),        - SEQUENCE (PostgreSQL/Oracle; suele usarse con @SequenceGenerator),       - AUTO (deja que el proveedor decida),       - TABLE (tabla de secuencias).    </p> <p>Mapeo de columnas:     - <code>@Column(name=\"...\", nullable=\u2026, length=\u2026, unique=\u2026)</code> \u2192 Personaliza la columna.      - <code>@Transient</code> \u2192 No persistir el atributo.       - <code>@Enumerated(EnumType.STRING)</code> \u2192 Guarda el nombre del enum (mejor que ORDINAL).  - <code>@Lob</code> \u2192 CLOB/BLOB para textos o binarios grandes.      </p> <pre><code>@Entity @Table(name = \"usuarios\")\npublic class Usuario {\n@Id @GeneratedValue(strategy = GenerationType.IDENTITY) // MySQL\nprivate Long id;\n@Column(name=\"nombre\", nullable = false, length = 100)\nprivate String nombre;\n@Column(name=\"email\", nullable = false, unique = true, length = 150)\nprivate String email;\n@Column(name=\"tipo\")\n@Enumerated(EnumType.STRING) //guarda el nombre en forma de string, en vez de un ordinal\nprivate Tipo tipo;\n}\n</code></pre>"},{"location":"ud3/installation/#2-relaciones","title":"\ud83d\udcc4 2 Relaciones","text":"<p>N:1 (muchos-a-uno) <pre><code>@ManyToOne(fetch = FetchType.LAZY, optional = false)\n@JoinColumn(name = \"usuario_id\", nullable = false)\nprivate Usuario usuario;\n</code></pre></p> <p>1:N (uno-a-muchos) <pre><code>@OneToMany(mappedBy = \"usuario\", cascade = CascadeType.ALL, orphanRemoval = true)\nprivate List&lt;Pedido&gt; pedidos = new ArrayList&lt;&gt;();\n</code></pre></p> <p>1:1 (uno-a-uno) <pre><code>@OneToOne(fetch = FetchType.LAZY, optional = false)\n@JoinColumn(name = \"perfil_id\", unique = true)\nprivate Perfil perfil;\n</code></pre></p> <p>N:N (muchos-a-muchos) sin atributos en la relaci\u00f3n <pre><code>@ManyToMany\n@JoinTable(name = \"usuarios_roles\",\njoinColumns = @JoinColumn(name = \"usuario_id\"),\ninverseJoinColumns = @JoinColumn(name = \"rol_id\"))\nprivate Set&lt;Rol&gt; roles = new HashSet&lt;&gt;();\n</code></pre></p> <p>N:N (muchos-a-muchos) con atributos que salen de la relaci\u00f3n <pre><code>@Entity\n@Table(name = \"asignaturas\")\npublic class Asignatura {\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\nprivate String nombre;\n// Relaci\u00f3n 1:N con la entidad intermedia\n@OneToMany(mappedBy = \"asignatura\", cascade = CascadeType.ALL, orphanRemoval = true)\nprivate Set&lt;Matricula&gt; matriculas = new HashSet&lt;&gt;();\n// getters, setters, equals/hashCode...\n}\n@Entity\n@Table(name = \"alumnos\")\npublic class Alumno {\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\nprivate String nombre;\n// Relaci\u00f3n 1:N con la entidad intermedia\n@OneToMany(mappedBy = \"alumno\", cascade = CascadeType.ALL, orphanRemoval = true)\nprivate Set&lt;Matricula&gt; matriculas = new HashSet&lt;&gt;();\n// getters, setters, equals/hashCode...\n}\n@Entity\n@Table(\nname = \"matriculas\",\nuniqueConstraints = {\n@UniqueConstraint(columnNames = {\"alumno_id\", \"asignatura_id\"})//unicidad, no se permite dos filas\n//con el mismo alumno misma asignatura\n}\n)\npublic class Matricula {\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n// Muchos Matricula \u2192 Un Alumno\n@ManyToOne(fetch = FetchType.LAZY, optional = false)\n@JoinColumn(name = \"alumno_id\", nullable = false)\nprivate Alumno alumno;\n// Muchos Matricula \u2192 Una Asignatura\n@ManyToOne(fetch = FetchType.LAZY, optional = false)\n@JoinColumn(name = \"asignatura_id\", nullable = false)\nprivate Asignatura asignatura;\n// \ud83d\udd39 Atributos que \u201cnacen\u201d de la relaci\u00f3n\n@Column(nullable = false)\nprivate Double nota;\n@Column(name = \"fecha_matricula\", nullable = false)\nprivate LocalDate fechaMatricula;\n// getters, setters, equals/hashCode...\n}\n</code></pre></p>"},{"location":"ud3/installation/#buenas-practicas","title":"\ud83d\udccc Buenas pr\u00e1cticas","text":"<ul> <li>Define \u00edndices en FKs/columnas de b\u00fasqueda.  </li> <li>Evita bidireccionales innecesarias; no metas colecciones en <code>equals/hashCode</code>.  </li> <li>Usa DTOs para lecturas complejas; no expongas entidades en controladores.</li> <li>La PK (id) identifica a la entidad en BD.</li> <li>Para <code>equals()</code>/<code>hashCode()</code>:</li> <li>Si tienes una clave natural inmutable (p.ej., <code>dni</code>, <code>email</code> \u00fanico), puedes usarla.</li> <li>Si usas PK autogenerada, no la uses antes de existir; una estrategia com\u00fan es:<ul> <li>Si <code>id == null</code>, usa identidad de objeto (super) o un UUID ef\u00edmero.</li> <li>Si <code>id != null</code>, compara por <code>id</code>.</li> </ul> </li> </ul> <p>Objetivo: que un objeto no \u201ccambie de identidad\u201d dentro de colecciones (<code>Set</code>, <code>Map</code>) al persistirlo.</p> <ul> <li><code>@ManyToOne</code>, <code>@OneToMany</code>, <code>@OneToOne</code>, <code>@ManyToMany</code> con <code>@JoinColumn</code>/<code>@JoinTable</code>.</li> <li>Due\u00f1o de la relaci\u00f3n = quien tiene la FK.</li> <li>Colecciones: por defecto usa <code>Set</code> (sin duplicados). Usa <code>List + @OrderColumn</code> si el orden es parte del negocio.</li> <li>Helpers para mantener la bidireccionalidad:   <pre><code>public void addPedido(Pedido p){ pedidos.add(p); p.setUsuario(this); }\npublic void removePedido(Pedido p){ pedidos.remove(p); p.setUsuario(null); }\n</code></pre></li> </ul>"},{"location":"ud3/jakartajpa/","title":"\ud83c\udfdb\ufe0f Jakarta \u2013 JPA (Java Persistence API)","text":"<p>JPA es una especificaci\u00f3n que define c\u00f3mo debe gestionarse la persistencia de objetos en aplicaciones Java. \ud83d\udc49 Al ser una especificaci\u00f3n, JPA no es una librer\u00eda concreta: necesita un proveedor (implementaci\u00f3n) como Hibernate, EclipseLink, OpenJPA, etc.</p> <p>Renombrado: En 2019 Java EE pas\u00f3 a la Eclipse Foundation y JPA se renombr\u00f3 a Jakarta Persistence. Desde Jakarta Persistence 3.0 (2020), los paquetes cambiaron de <code>javax.persistence</code> a <code>jakarta.persistence</code>.</p>"},{"location":"ud3/jakartajpa/#que-cubre-jpa","title":"\ud83e\udde0 \u00bfQu\u00e9 cubre JPA?","text":"<ul> <li>API (interfaces, anotaciones) en <code>jakarta.persistence</code> </li> <li>Lenguaje de consultas JPQL (Java Persistence Query Language)  </li> <li>Metadatos para el mapeo objeto/relacional (anotaciones o XML)</li> </ul> <p>Importante</p> <p>JPA define interfaces (p. ej., <code>EntityManager</code>), no clases de uso directo. Para usarlas necesitas una implementaci\u00f3n (Hibernate, EclipseLink\u2026).</p>"},{"location":"ud3/jakartajpa/#arquitectura-general","title":"\ud83e\uddf1 Arquitectura general","text":"<p>Componentes clave: - Entidades (<code>@Entity</code>): clases cuyo estado queremos guardar en BD. - EntityManagerFactory (EMF): f\u00e1brica de <code>EntityManager</code>. Es pesada, thread\u2011safe y suele existir una por persistence unit en toda la aplicaci\u00f3n. - EntityManager (EM): gestiona el contexto de persistencia (first\u2011level cache) y el ciclo de vida de las entidades. No es thread\u2011safe; se usa por transacci\u00f3n / petici\u00f3n. - Persistence Context: conjunto de entidades gestionadas (estado managed) que el <code>EntityManager</code> sincroniza con la BD.</p>"},{"location":"ud3/jakartajpa/#entidades-entity","title":"\ud83e\udde9 Entidades (<code>@Entity</code>)","text":"<p>Para JPA, una entidad es un objeto cuyo estado se persiste en una tabla. Toda entidad necesita una identidad (PK).</p> <pre><code>import jakarta.persistence.*;\n@Entity\n@Table(name = \"usuarios\")\npublic class Usuario {\n@Id @GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n@Column(nullable = false, length = 100)\nprivate String nombre;\n@Column(nullable = false, unique = true, length = 150)\nprivate String email;\n// getters/setters\n}\n</code></pre> <ul> <li>Las entidades pueden tener relaciones (<code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>) y tipos embebidos (<code>@Embeddable</code>).  </li> <li>El dise\u00f1o de la identidad (PK) es clave para el rendimiento y la igualdad (<code>equals/hashCode</code>).</li> </ul>"},{"location":"ud3/jakartajpa/#entitymanagerfactory-y-entitymanager","title":"\ud83c\udfed EntityManagerFactory y EntityManager","text":"<ul> <li> <p>EMF se crea normalmente al arrancar la aplicaci\u00f3n: <pre><code>EntityManagerFactory emf =\nPersistence.createEntityManagerFactory(\"default\");\n</code></pre>   Mant\u00e9n una \u00fanica instancia (por persistence unit) y ci\u00e9rrala al apagar la app.</p> </li> <li> <p>EM se crea cuando necesitas operar con datos y no se comparte entre hilos: <pre><code>EntityManager em = emf.createEntityManager();\ntry {\nem.getTransaction().begin();\n// ... usar em.persist/merge/find/query\nem.getTransaction().commit();\n} finally {\nem.close();\n}\n</code></pre></p> </li> </ul> <p>Regla pr\u00e1ctica: EMF = singleton de la app; EM = por petici\u00f3n/uso/tx.</p>"},{"location":"ud3/jakartajpa/#persistence-context-firstlevel-cache","title":"\ud83e\uddf0 Persistence Context (First\u2011Level Cache)","text":"<ul> <li>El <code>EntityManager</code> mantiene un conjunto de entidades gestionadas.  </li> <li>La sincronizaci\u00f3n con la BD ocurre al <code>commit</code> o al <code>flush()</code>.  </li> <li>Dirty checking: si cambias un atributo de una entidad managed, JPA genera el <code>UPDATE</code> autom\u00e1ticamente al sincronizar.</li> </ul> <p>Para conseguir que alguno de nuestros objetos pase a ubicarse dentro del PersistenceContext bastar\u00e1 con invocar los m\u00e9todos persist, merge, sobre \u00e9l.</p> <p>Operaciones t\u00edpicas: <pre><code>em.persist(ent);   // transient -&gt; managed (INSERT en flush/commit)\nem.merge(detached);// detached/new -&gt; managed (SELECT/INSERT/UPDATE)\nem.remove(ent);    // managed -&gt; removed (DELETE en flush/commit)\nem.flush();        // fuerza sincronizaci\u00f3n ahora\nem.clear();        // vac\u00eda el contexto (pasa managed -&gt; detached)\n</code></pre></p> <p></p>"},{"location":"ud3/jakartajpa/#estados-de-las-entidades","title":"\ud83d\udd04 Estados de las entidades","text":"Estado Significado Ejemplo Transient (transitorio) El objeto existe en memoria, pero no en la BD ni en la sesi\u00f3n. <code>Customer c = new Customer(\"Ada\");</code> Persistent (persistente) Est\u00e1 asociada a una <code>Session</code> (o <code>EntityManager</code>) y Hibernate la rastrea. Si cambias un atributo, el cambio se guardar\u00e1 al hacer <code>commit()</code>. <code>session.persist(c);</code> Detached (desasociado) Exist\u00eda en la BD, pero ya no est\u00e1 siendo gestionada (por ejemplo, la sesi\u00f3n se cerr\u00f3). Objeto obtenido con <code>find()</code> pero fuera del contexto. Removed (eliminado) Est\u00e1 marcada para eliminarse en el commit. <code>session.remove(c);</code> <p>Relaci\u00f3n con m\u00e9todos:</p> M\u00e9todo Qu\u00e9 hace Estado que afecta <code>persist(entity)</code> Inserta la entidad en el contexto (nuevo \u2192 persistente). transient \u2192 persistent <code>find(Entidad.class, id)</code> Busca en BD y la mete en el contexto. detached \u2192 persistent <code>merge(entity)</code> Reasocia una entidad detached, actualizando los cambios. detached \u2192 persistent <code>remove(entity)</code> Marca la entidad para borrado al commit. persistent \u2192 removed <code>refresh(entity)</code> Relee los valores desde la BD. persistent <code>detach(entity)</code> La saca del contexto (deja de estar gestionada). persistent \u2192 detached <code>clear()</code> Saca todas las entidades del contexto. persistent \u2192 detached <code>flush()</code> Sincroniza el contexto con la BD sin cerrar la sesi\u00f3n. \u2014"},{"location":"ud3/jakartajpa/#fichero-de-persistencia-persistencexml","title":"\ud83e\uddea Fichero de persistencia: <code>persistence.xml</code>","text":"<p>El <code>EntityManagerFactory</code> se configura mediante unidades de persistencia en <code>META-INF/persistence.xml</code>:</p> META-INF/persistence.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence xmlns=\"https://jakarta.ee/xml/ns/persistence\"\nversion=\"3.0\"&gt;\n&lt;persistence-unit name=\"default\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n&lt;class&gt;es.severo.entity.Tramite&lt;/class&gt;\n&lt;properties&gt;\n&lt;property name=\"jakarta.persistence.jdbc.driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n&lt;property name=\"jakarta.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3306/testdb2\"/&gt;\n&lt;property name=\"jakarta.persistence.jdbc.user\" value=\"root\"/&gt;\n&lt;property name=\"jakarta.persistence.jdbc.password\" value=\"root\"/&gt;\n&lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n&lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;\n&lt;/properties&gt;\n&lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>Claves del XML - <code>&lt;persistence-unit name=\"...\"&gt;</code>: identifica la unidad; ese nombre se usa en <code>createEntityManagerFactory(...)</code>. - <code>transaction-type</code>:   - <code>RESOURCE_LOCAL</code> \u2192 transacciones locales controladas por la app.   - <code>JTA</code> \u2192 transacciones gestionadas por un application server. - <code>&lt;class&gt;</code>: lista de entidades (algunos runtimes permiten auto-scan). - <code>&lt;properties&gt;</code>: conexi\u00f3n, dialect, DDL, pooling, etc.</p> <p>Puedes tener varias persistence units si conectas a distintas BDs o necesitas configuraciones separadas.</p>"},{"location":"ud3/jakartajpa/#jpql-y-consultas","title":"\ud83d\udd0e JPQL y consultas","text":"<p>JPQL consulta entidades y sus atributos, no tablas. JPA traduce JPQL \u2192 SQL.</p> <pre><code>// B\u00fasqueda por email\nTypedQuery&lt;Usuario&gt; q = em.createQuery(\n\"SELECT u FROM Usuario u WHERE u.email = :email\", Usuario.class);\nq.setParameter(\"email\", \"ana@example.com\");\nUsuario u = q.getSingleResult();\n</code></pre> <ul> <li>JOINs siguen las relaciones del modelo: <code>SELECT p FROM Pedido p JOIN p.usuario u WHERE u.nombre = :n</code> </li> <li>Criteria API (tipado, din\u00e1mico) tambi\u00e9n est\u00e1 disponible.</li> </ul>"},{"location":"ud3/jakartajpa/#transacciones-y-excepciones","title":"\u2699\ufe0f Transacciones y excepciones","text":"<p>En modo <code>RESOURCE_LOCAL</code>: <pre><code>em.getTransaction().begin();\ntry {\n// ... operaciones\nem.getTransaction().commit();\n} catch (RuntimeException ex) {\nif (em.getTransaction().isActive()) em.getTransaction().rollback();\nthrow ex;\n}\n</code></pre></p> <ul> <li>Las excepciones de JPA son <code>RuntimeException</code>, con ra\u00edz com\u00fan <code>PersistenceException</code>.  </li> <li>En <code>JTA</code>, las transacciones las gestiona el contenedor (por ejemplo, usando anotaciones <code>@Transactional</code> en Jakarta EE/Spring).</li> </ul>"},{"location":"ud3/jakartajpa/#concurrencia-y-thread-safety","title":"\ud83e\uddf5 Concurrencia y thread-safety","text":"<ul> <li><code>EntityManagerFactory</code> \u2192 thread\u2011safe; una instancia por persistence unit.  </li> <li><code>EntityManager</code> \u2192 no thread\u2011safe; no usar como <code>static</code> ni compartir entre hilos. Crear por uso/petici\u00f3n/tx.  </li> <li>Cerrar siempre <code>EntityManager</code> en un <code>finally</code> (o equivalente del marco).</li> </ul>"},{"location":"ud3/jakartajpa/#implementaciones-de-jpa-providers","title":"\ud83e\uddf0 Implementaciones de JPA (providers)","text":"<ul> <li>Hibernate (el m\u00e1s extendido; HQL, gran ecosistema).  </li> <li>EclipseLink (referencia de Jakarta).  </li> <li>OpenJPA, DataNucleus, ObjectDB (alcances espec\u00edficos).</li> </ul> <p>Ventaja de JPA: intercambiabilidad de proveedores con cambios m\u00ednimos si sigues la especificaci\u00f3n.</p>"},{"location":"ud3/operacionescrud/","title":"\ud83e\uddea Operaciones CRUD con objetos en Hibernate","text":"<p>En este bloque ver\u00e1s c\u00f3mo cargar, guardar, actualizar y borrar entidades con JPA/Hibernate.</p>"},{"location":"ud3/operacionescrud/#1-create-insertar-registros","title":"\ud83e\udde9 1\ufe0f\u20e3 CREATE (Insertar registros)","text":""},{"location":"ud3/operacionescrud/#persist","title":"\ud83d\udcd8 <code>persist</code>","text":"<p>Inserta nuevas entidades en la base de datos. Hibernate se encarga de generar el <code>INSERT</code> SQL autom\u00e1ticamente.</p> <pre><code>Usuario u = new Usuario(\"Ana\", \"ana@example.com\");\nsession.beginTransaction();\nsession.persist(u);          // INSERT en flush/commit\nsession.getTransaction().commit();\n</code></pre>"},{"location":"ud3/operacionescrud/#notas","title":"\ud83e\udde9 Notas","text":"<ul> <li><code>persist()</code> no devuelve el ID (asigna el ID a la entidad en memoria).   </li> <li>Marca la entidad como \u201cmanaged\u201d, lista para sincronizar con la BD al hacer <code>commit()</code>.    </li> <li>Id autogenerado: no conf\u00edes en \u00e9l hasta el <code>flush</code> (o tras commit).   </li> </ul>"},{"location":"ud3/operacionescrud/#2-read-leer-registros","title":"\ud83e\uddfe 2\ufe0f\u20e3 READ (Leer registros)","text":""},{"location":"ud3/operacionescrud/#findgetreference","title":"\ud83d\udcd8 <code>find/getReference</code>","text":"<p>Recupera entidades desde la base de datos.</p> <p>Se utilizan los m\u00e9todos find/getReference:      </p> <p><code>find(Entidad.class, id)</code> \u2192 ACCESO REAL (SELECT inmediato):        - Ejecuta enseguida un SELECT ... FROM customer WHERE id = 1.    - Devuelve el objeto completo, ya inicializado.    - Si no existe, devuelve null.     - El objeto est\u00e1 gestionado por el EntityManager/Session.</p> <p><code>getReference(...)</code> \u2192 PROXY (carga diferida / lazy, no SELECT hasta acceso):     - NO ejecuta ning\u00fan SELECT todav\u00eda.    - Devuelve un proxy (un objeto \u201cfantasma\u201d que simula ser el <code>Usuario</code>).     - El proxy solo contiene el ID y un mecanismo interno para hacer SELECT m\u00e1s tarde, si tocas alg\u00fan campo que necesita los datos.     </p> <pre><code>Usuario u = session.find(Usuario.class, 1L);          // SELECT inmediato\nUsuario p = session.getReference(Usuario.class, 1L);  // Proxy LAZY\n</code></pre>"},{"location":"ud3/operacionescrud/#3-update-actualizar-registros","title":"\ud83d\udd01 3\ufe0f\u20e3 UPDATE (Actualizar registros)","text":""},{"location":"ud3/operacionescrud/#merge-o-entidad-en-estado-managed","title":"\ud83d\udcd8 <code>merge</code> o entidad en estado managed","text":"<p>Modifica una entidad existente. Hibernate detecta los cambios autom\u00e1ticamente si la entidad est\u00e1 en estado \u201cmanaged\u201d.</p> <ul> <li>Entidad detached: usa <code>merge(detached)</code>. Devuelve otra instancia managed.</li> </ul> <pre><code>// managed\nTransaction tx = session.beginTransaction();\nUser user = session.find(User.class, 1L); //entidad user en estado managed\nuser.setEmail(\"nuevoemail@example.com\"); // Hibernate detecta el cambio\ntx.commit(); // Hibernate ejecuta el UPDATE autom\u00e1ticamente\n</code></pre>"},{"location":"ud3/operacionescrud/#si-la-entidad-no-esta-en-sesion","title":"\u2699\ufe0f Si la entidad no est\u00e1 en sesi\u00f3n","text":"<p>Usa <code>merge()</code> para sincronizar los datos con el contexto: <pre><code>User detachedUser = new User();\ndetachedUser.setId(1L);\ndetachedUser.setEmail(\"nuevoemail@example.com\");\nsession.merge(detachedUser); // sincroniza y actualiza\n</code></pre></p>"},{"location":"ud3/operacionescrud/#4-delete-eliminar-registros","title":"\u274c 4\ufe0f\u20e3 DELETE (Eliminar registros)","text":""},{"location":"ud3/operacionescrud/#remove","title":"<code>remove</code>","text":"<p>Borra una entidad de la base de datos.</p> <ul> <li><code>remove(managed)</code> \u2192 marca removed \u2192 <code>DELETE</code> en flush/commit.</li> </ul> <pre><code>Usuario u = session.find(Usuario.class, 1L);\nif (u != null) {\nsession.remove(u); // DELETE\n}\n</code></pre>"},{"location":"ud3/operacionescrud/#precaucion","title":"\u26a0\ufe0f Precauci\u00f3n","text":"<ul> <li>Si la entidad tiene relaciones (<code>@OneToMany</code>, etc.), el borrado puede cascadar si usas <code>cascade = CascadeType.REMOVE</code>.</li> <li>Si no existe en BD, <code>find()</code> devuelve <code>null</code> (no lanza error).</li> </ul>"},{"location":"ud3/operacionescrud/#flush-clear","title":"<code>flush()</code>, <code>clear()</code>","text":"<ul> <li><code>flush()</code> \u2192 sincroniza ahora con la BD.</li> <li><code>clear()</code> \u2192 vac\u00eda el contexto (managed \u2192 detached).</li> </ul>"},{"location":"ud3/operacionescrud/#ciclo-de-vida-de-una-entidad","title":"\ud83d\udd04 Ciclo de vida de una entidad","text":"Estado Descripci\u00f3n Ejemplo Transient No est\u00e1 asociada al contexto ni en la BD. <code>new User()</code> Persistent (Managed) Asociada a una sesi\u00f3n activa (<code>persist</code>, <code>find</code>). <code>session.persist(user)</code> Detached Ya no gestionada (sesi\u00f3n cerrada). despu\u00e9s de <code>session.close()</code> Removed Marcada para eliminaci\u00f3n. <code>session.remove(user)</code>"},{"location":"ud3/operacionescrud/#buenas-practicas","title":"\ud83e\udde0 Buenas pr\u00e1cticas","text":"<ul> <li>Usa transacciones (<code>beginTransaction</code> / <code>commit</code>) para todas las operaciones de escritura.  </li> <li>Cierra siempre la sesi\u00f3n (<code>session.close()</code>) para liberar recursos.  </li> <li>Evita <code>session.flush()</code> manual salvo que sea necesario.  </li> <li>Usa DAO y servicios para encapsular la l\u00f3gica CRUD.</li> <li>Usa <code>getReference</code> para asociar por id sin SELECT extra.</li> </ul>"},{"location":"ud3/operacionescrud/#conclusion","title":"\ud83e\uddfe Conclusi\u00f3n","text":"<ul> <li>Hibernate gestiona autom\u00e1ticamente las operaciones CRUD bas\u00e1ndose en el estado de la entidad.  </li> <li>La mayor\u00eda de los <code>INSERT</code>, <code>UPDATE</code> y <code>DELETE</code> se ejecutan autom\u00e1ticamente al hacer <code>commit()</code>.  </li> <li>Usar patrones DAO/Service mantiene un c\u00f3digo limpio, mantenible y desacoplado.</li> </ul>"},{"location":"ud3/operacionescrud/#gestion-de-transacciones","title":"\ud83d\udd10 Gesti\u00f3n de transacciones","text":"<p>Hibernate trabaja con sesiones. Abres una transacci\u00f3n con session.beginTransaction(), trabajas con la sesi\u00f3n (las operaciones quedan en el contexto de persistencia), y al commit() Hibernate hace un flush autom\u00e1tico que env\u00eda los INSERT/UPDATE/DELETE a la BD; si hay error, haces rollback() y se descartan los cambios</p> <ul> <li>beginTransaction() inicia una transacci\u00f3n asociada a la Session.</li> <li>commit() hace un flush autom\u00e1tico (emite INSERT/UPDATE/DELETE pendientes) y confirma.</li> <li>rollback() revierte todo lo hecho en la transacci\u00f3n si hay error.</li> <li>Usa siempre try-with-resources para cerrar la Session; no reutilices sesiones entre hilos.</li> <li>Comprueba tx.isActive() antes de hacer rollback().</li> </ul> <pre><code>Transaction tx = null;\ntry (Session session = sessionFactory.openSession()) {\ntx = session.beginTransaction();\n// --- trabajo con la BD ---\n// session.persist(entidad);\n// session.merge(detached);\n// session.remove(entidad);\n// consultas HQL/Criteria/Native\n// --------------------------\ntx.commit();                 // hace flush impl\u00edcito y confirma cambios\n} catch (RuntimeException e) {\nif (tx != null &amp;&amp; tx.isActive()) tx.rollback();  // revierte la tx\nthrow e;                      // vuelve a lanzar para que la capa superior decida\n}\n</code></pre>"},{"location":"ud3/queries/","title":"\ud83e\udde9 Formas de realizar consultas en Hibernate","text":""},{"location":"ud3/queries/#objetivo","title":"\ud83c\udfaf Objetivo","text":"<p>Aprender las principales formas de crear consultas (querys) en Hibernate 6 / Jakarta JPA: - JPQL / HQL - Criteria API - SQL Nativo - @NamedQuery  </p> <p>Adem\u00e1s, se explica qu\u00e9 tipo de datos devuelve cada una (entidad, DTO, <code>Object[]</code>, <code>Tuple</code>, etc.).</p>"},{"location":"ud3/queries/#1-jpql-hql-hibernate-query-language","title":"1\ufe0f\u20e3 JPQL / HQL (Hibernate Query Language)","text":""},{"location":"ud3/queries/#que-es","title":"\ud83d\udcd8 Qu\u00e9 es","text":"<p>JPQL (Java Persistence Query Language) se inspir\u00f3 en las primeras versiones de HQL y es un subconjunto del HQL moderno. Lenguaje orientado a entidades y atributos, no a tablas SQL.  </p> <p>Hibernate usa un poderoso lenguaje de consulta (HQL) que es similar en apariencia a SQL. Sin embargo, en comparaci\u00f3n con SQL, HQL est\u00e1 completamente orientado a objetos y comprende nociones como herencia, polimorfismo y asociaci\u00f3n.</p>"},{"location":"ud3/queries/#ejemplo","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>String jpql = \"SELECT s FROM Space s WHERE s.active = true AND s.capacity &gt;= :min\";\nList&lt;Space&gt; result = session.createQuery(jpql, Space.class)\n.setParameter(\"min\", 5)\n.getResultList();\n</code></pre> named parameters<pre><code>//JPQL\nTypedQuery&lt;Usuario&gt; q = session.createQuery(\n\"SELECT u FROM Usuario u WHERE u.email LIKE :mail ORDER BY u.nombre\",\nUsuario.class);\nq.setParameter(\"mail\", \"%@example.com%\");\nq.setMaxResults(50).setFirstResult(0); // paginaci\u00f3n\nList&lt;Usuario&gt; usuarios = q.getResultList();\n</code></pre> ordinal parameters<pre><code>    TypedQuery&lt;Tramite&gt; query = session.createQuery(\n\"from Tramite where tipo = ?1\",\nTramite.class)\n.setParameter(1, \"Cr\u00e9dito\");\n</code></pre> <p>Warning</p> <p>No es una buena idea mezclar named parameters y ordinales en una sola consulta.</p> <p>JOIN y proyecciones (DTO): <pre><code>List&lt;UsuarioPedidoDTO&gt; dtos = session.createQuery(\n\"SELECT new com.acme.dto.UsuarioPedidoDTO(u.id, u.nombre, COUNT(p)) \" +\n\"FROM Usuario u LEFT JOIN u.pedidos p \" +\n\"GROUP BY u.id, u.nombre \" +\n\"ORDER BY COUNT(p) DESC\",\nUsuarioPedidoDTO.class\n).getResultList();\n//tambi\u00e9n se puede hacer el join impl\u00edcito  (INNER JOIN) navegando con \".\": r.event.name, navegamos \n//desde Registration, por Event hasta el atributo de name en la entidad Event.\nString jpql = \"SELECT r.event.name, r.event.organizer.name, r.registrationDate, r.attendee.name \" +\n\"FROM Registration r \" +\n\"WHERE r.event.organizer.email = ?1 \" +\n\"AND r.status = 'confirmed' \" +\n\"ORDER BY r.event.name\";\n</code></pre></p>"},{"location":"ud3/queries/#tipo-de-dato-devuelto","title":"\ud83e\udde9 Tipo de dato devuelto","text":""},{"location":"ud3/queries/#entidad-completa","title":"Entidad completa","text":"<pre><code>List&lt;Customer&gt; list = session.createQuery(\n\"select c from Customer c where c.active = true\", Customer.class\n).getResultList();\n</code></pre>"},{"location":"ud3/queries/#varios-campos-object-por-defecto","title":"Varios campos --&gt; Object[] por defecto","text":"<pre><code>List&lt;Object[]&gt; rows = session.createQuery(\n\"select c.name, c.email from Customer c where c.active = true\", Object[].class\n).getResultList();\nfor (Object[] row : rows) {\nString name   = (String) row[0];\nString email  = (String) row[1];\n}\n</code></pre>"},{"location":"ud3/queries/#dto-directo-preferido","title":"DTO directo --&gt; preferido \u2705","text":"<pre><code>String hql =\n\"select new com.acme.CustomerDto(c.id, c.name, c.email) \" +\n\"from Customer c where c.active = true\";\nTypedQuery&lt;CustomerDto&gt; q = session.createQuery(hql, CustomerDto.class);\nList&lt;CustomerDto&gt; rows = q.getResultList();\n</code></pre>"},{"location":"ud3/queries/#tuple","title":"Tuple","text":"<pre><code>TypedQuery&lt;Tuple&gt; q = session.createQuery(\n\"select c.name as name, c.email as email from Customer c\", Tuple.class\n);\nList&lt;Tuple&gt; rows = q.getResultList(); for (Tuple t : rows) {\nString name = t.get(\"name\", String.class);\n}\n</code></pre> Tipo de consulta Devuelve <code>SELECT s FROM Space s</code> <code>List&lt;Space&gt;</code> (entidades gestionadas) <code>SELECT s.name FROM Space s</code> <code>List&lt;String&gt;</code> <code>SELECT s.id, s.name FROM Space s</code> <code>List&lt;Object[]&gt;</code> o <code>Tuple</code> <code>SELECT new es.coworking.SpaceDTO(s.id, s.name)</code> <code>List&lt;SpaceDTO&gt;</code>"},{"location":"ud3/queries/#ventajas-hqljpql","title":"\u2705 Ventajas HQL/JPQL","text":"<ul> <li>Legible y portable entre SGBD.  </li> <li>Permite joins, subconsultas, funciones agregadas.  </li> <li>Compatible con proyecciones (DTOs).</li> </ul>"},{"location":"ud3/queries/#2-criteria-api-jpa","title":"2\ufe0f\u20e3 Criteria API (JPA)","text":""},{"location":"ud3/queries/#que-es_1","title":"\ud83d\udcd8 Qu\u00e9 es","text":"<p>API program\u00e1tica y tipada para construir queries tipadas y din\u00e1micas con objetos Java. Ideal cuando los filtros dependen de condiciones del usuario o se generan en tiempo de ejecuci\u00f3n.</p>"},{"location":"ud3/queries/#pasos","title":"\ud83d\udeb6 Pasos","text":"<ol> <li>Consigue el CriteriaBuilder de la session.</li> </ol> <p><code>CriteriaBuilder</code> es la f\u00e1brica de construcciones (builder) stateless de la API de Criteria de JPA/Hibernate. Sirve para crear de forma tipada todos los \u201cladrillos\u201d de una consulta. Cada llamada devuelve objetos nuevos. No guarda configuraci\u00f3n ni estado global.</p> Categor\u00eda M\u00e9todo Uso / Ejemplo SQL equivalente Select / Agregaci\u00f3n <code>cb.count(expr)</code> Cuenta filas <code>COUNT(*)</code> <code>cb.countDistinct(expr)</code> Cuenta sin duplicados <code>COUNT(DISTINCT x)</code> <code>cb.sum(expr)</code> / <code>cb.avg(expr)</code> Suma / media <code>SUM(x)</code> / <code>AVG(x)</code> <code>cb.max(expr)</code> / <code>cb.min(expr)</code> M\u00e1ximo / m\u00ednimo <code>MAX(x)</code> / <code>MIN(x)</code> Comparaci\u00f3n <code>cb.equal(x, y)</code> / <code>cb.notEqual(x, y)</code> Igual / distinto <code>=</code>, <code>&lt;&gt;</code> <code>cb.greaterThan(x,y)</code>, <code>cb.gt</code> / <code>cb.ge</code>, <code>cb.greaterThanOrEqualTo</code> Mayor / mayor o igual <code>&gt;</code>, <code>&gt;=</code> <code>cb.lessThan(x, y)</code>, <code>cb/lt</code> / <code>cb.le</code>, <code>cb.lessThanOrEqualTo</code> Menor / menor o igual <code>&lt;</code>, <code>&lt;=</code> <code>cb.between(x, a, b)</code> Dentro de un rango <code>BETWEEN a AND b</code> Booleanos <code>cb.isTrue(expr)</code> Comprueba <code>true</code> <code>WHERE col = true</code> <code>cb.isFalse(expr)</code> Comprueba <code>false</code> <code>WHERE col = false</code> Nulos y colecciones <code>cb.isNull(expr)</code> / <code>cb.isNotNull(expr)</code> Valor nulo / no nulo <code>IS NULL</code> / <code>IS NOT NULL</code> <code>cb.isEmpty(collection)</code> / <code>cb.isNotEmpty(collection)</code> Colecci\u00f3n vac\u00eda / no vac\u00eda <code>NOT EXISTS(...)</code> / <code>EXISTS(...)</code> <code>cb.isMember(elem, collection)</code> / <code>cb.isNotMember(elem, collection)</code> Pertenencia a colecci\u00f3n <code>elem IN (subquery)</code> Texto / cadenas <code>cb.like(expr, pattern)</code> / <code>cb.notLike(expr, pattern)</code> Coincidencia parcial <code>LIKE</code> / <code>NOT LIKE</code> <code>cb.lower(expr)</code> / <code>cb.upper(expr)</code> Min\u00fasculas / may\u00fasculas <code>LOWER()</code> / <code>UPPER()</code> <code>cb.concat(a, b)</code> Concatenaci\u00f3n de cadenas <code>CONCAT(a, b)</code> <code>cb.length(expr)</code> Longitud de cadena <code>LENGTH(expr)</code> <code>cb.locate(str, sub)</code> Posici\u00f3n de substring <code>LOCATE(sub, str)</code> Fechas / tiempos <code>cb.currentDate()</code> / <code>cb.currentTimestamp()</code> Fecha/hora actual <code>CURRENT_DATE</code> / <code>CURRENT_TIMESTAMP</code> <code>cb.greaterThan(date1, date2)</code> Comparar fechas <code>&gt;</code> L\u00f3gicos <code>cb.and(p1, p2, \u2026)</code> Conjunci\u00f3n <code>AND</code> <code>cb.or(p1, p2, \u2026)</code> Disyunci\u00f3n <code>OR</code> <code>cb.not(p)</code> Negaci\u00f3n <code>NOT</code> Subconsultas <code>cb.exists(subquery)</code> / <code>cb.not(cb.exists(...))</code> Comprobar existencia <code>EXISTS(subquery)</code> Ordenaci\u00f3n <code>cb.asc(expr)</code> / <code>cb.desc(expr)</code> Orden asc / desc <code>ORDER BY col ASC/DESC</code> <pre><code>CriteriaBuilder cb = session.getCriteriaBuilder();\n</code></pre> <ol> <li>Crea la consulta (elige el tipo de resultado):</li> </ol> <p>CriteriaQuery es la representaci\u00f3n en Java de una consulta JPQL.</p> <pre><code>CriteriaQuery&lt;Usuario&gt; cq = cb.createQuery(Usuario.class); // tipada\n// o: CriteriaQuery&lt;Tuple&gt; cq = cb.createTupleQuery();      // tuplas\n// o: CriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class); // arrays\n// o: CriteriaQuery&lt;TopSpaceRevenueDto&gt; d = cb.createQuery(TopSpaceRevenueDto.class); //Dto\n</code></pre> <ol> <li>Define la ra\u00edz (Root)</li> </ol> <p>La ra\u00edz siempre es una entidad. Es el FROM de la query SQL.</p> <pre><code>Root&lt;Usuario&gt; u = cq.from(Usuario.class);\n</code></pre> <ol> <li>Define las uniones JOIN, si las necesitas</li> </ol> <pre><code>Root&lt;Booking&gt; root = criteria.from(Booking.class);\nJoin&lt;Booking, Space&gt; join = root.join(\"space\");//nombre del objeto en la clase Booking\n</code></pre> <ol> <li>Selecciona lo que quieres devolver</li> </ol> <pre><code>cq.select(u); // opcional si solo hay un root, devuelve todo el objeto, como poner * en una select\ncq.select(u.get(\"email\")); //devuelve un campo\ncq.multiselect(u.get(\"id\"), u.get(\"nombre\")); // -&gt; devuelve varios campos en forma de Tuple\ncq.select(cb.construct(UserDTO.class, u.get(\"id\"), u.get(\"nombre\"))); //Como DTO/wrapper (lo m\u00e1s limpio)\n</code></pre> <ol> <li>A\u00f1ade filtros (predicados)</li> </ol> <pre><code> cq.multiselect(\nroot.get(\"nombre\"),\ncb.count(root.get(\"id\"))\n)\n.where(cb.and(cb.isNull(root.get(\"fechaFin\")),\ncb.ge(root.get(\"capacidad\"),10)))     //decimos que la fechaFin no sea nula y que capacidad sea mayor que 10\n</code></pre> <ol> <li>Orden</li> </ol> <pre><code>cq.orderBy(cb.asc(u.get(\"nombre\")));\nTypedQuery&lt;Usuario&gt; q = session.createQuery(cq);\n</code></pre> <ol> <li>Ejecuta</li> </ol> <pre><code>List&lt;Usuario&gt; resultados = session.createQuery(cq).getResultList();\n</code></pre>"},{"location":"ud3/queries/#ejemplos","title":"\ud83e\udde0 Ejemplos","text":"<pre><code>CriteriaBuilder cb = session.getCriteriaBuilder();\nCriteriaQuery&lt;Space&gt; cq = cb.createQuery(Space.class);\nRoot&lt;Space&gt; root = cq.from(Space.class);\ncq.select(root)\n.where(cb.and(\ncb.isTrue(root.get(\"active\")),\ncb.ge(root.get(\"capacity\"), 5)\n));\nList&lt;Space&gt; result = session.createQuery(cq).getResultList();\n</code></pre>"},{"location":"ud3/queries/#join","title":"JOIN","text":"<pre><code>CriteriaBuilder cb = session.getCriteriaBuilder();\nCriteriaQuery&lt;Space&gt; cq = cb.createQuery(Space.class);\nRoot&lt;Space&gt; root = cq.from(Space.class);\nJoin&lt;Space, Venue&gt; jVenue = root.join(\"venue\");//INNER JOIN\ncq.select(root)\n.where(cb.equal(jVenue.get(\"city\"), \"Zaragoza\"));\n</code></pre>"},{"location":"ud3/queries/#proyeccion-a-dto","title":"Proyecci\u00f3n a DTO","text":"<pre><code>CriteriaQuery&lt;SpaceCardDto&gt; cq3 = cb.createQuery(SpaceCardDto.class);\nRoot&lt;Space&gt; r3 = cq3.from(Space.class);\ncq3.select(cb.construct(\nSpaceCardDto.class,\nr3.get(\"code\"), r3.get(\"name\"), r3.get(\"hourlyPrice\")\n));\nList&lt;SpaceCardDto&gt; rows2 = session.createQuery(cq3).getResultList();\nSystem.out.println(rows2);\n</code></pre>"},{"location":"ud3/queries/#between-y-like","title":"BETWEEN y LIKE","text":"<pre><code>//BETWEEN, espacios en los que el precio por hora est\u00e1 entre 10 y 30\ncq.select(root)\n.where(cb.between(root.get(\"hourlyPrice\"),\nnew BigDecimal(\"10\"), new BigDecimal(\"30\")));\n//LIKE\nString keyword = \"meeting\";\ncq.select(root)\n.where(cb.like(cb.lower(root.get(\"name\")), \"%\" + keyword.toLowerCase() + \"%\"));\n</code></pre>"},{"location":"ud3/queries/#count","title":"COUNT","text":"<pre><code>CriteriaQuery&lt;Long&gt; cqCount = cb.createQuery(Long.class);\nRoot&lt;Space&gt; rCount = cqCount.from(Space.class);\ncqCount.select(cb.count(rCount))\n.where(cb.isTrue(rCount.get(\"active\")));\nLong total = session.createQuery(cqCount).getSingleResult();\n</code></pre>"},{"location":"ud3/queries/#resultado-como-tuple","title":"Resultado como TUPLE","text":"<pre><code>//resultado como tuple\nCriteriaQuery&lt;Tuple&gt; cqTuple = cb.createTupleQuery();\nRoot&lt;Space&gt; rT = cqTuple.from(Space.class);\nJoin&lt;Space, Venue&gt; vT = rT.join(\"venue\");\ncqTuple.multiselect(\nrT.get(\"id\").alias(\"id\"),\nrT.get(\"name\").alias(\"name\"),\nvT.get(\"name\").alias(\"venueName\")\n);\nList&lt;Tuple&gt; rows3 = session.createQuery(cqTuple).getResultList();\nfor (Tuple t : rows3) {\nLong id = t.get(\"id\", Long.class);\nString name = t.get(\"name\", String.class);\nString venueName = t.get(\"venueName\", String.class);\nSystem.out.println(id + \"  \"  + name + \"   \" + venueName);\n}\n</code></pre>"},{"location":"ud3/queries/#group-by-having","title":"Group By, Having","text":"<pre><code>CriteriaQuery&lt;Object[]&gt; cq2 = cb.createQuery(Object[].class);\nRoot&lt;Space&gt; s2 = cq2.from(Space.class);\nJoin&lt;Space, Venue&gt; v2 = s2.join(\"venue\");\nExpression&lt;BigDecimal&gt; avgPrice = cb.avg(s2.get(\"price\")).as(BigDecimal.class);\ncq2.multiselect(v2.get(\"city\"), avgPrice)\n.groupBy(v2.get(\"city\"))\n.having(cb.greaterThan(avgPrice, new BigDecimal(\"20\")));\n</code></pre>"},{"location":"ud3/queries/#tipo-de-dato-devuelto_1","title":"\ud83e\udde9 Tipo de dato devuelto","text":"<ul> <li>Si defines <code>CriteriaQuery&lt;Space&gt;</code> \u2192 <code>List&lt;Space&gt;</code> </li> <li>Si seleccionas varios atributos (<code>cb.tuple(...)</code>) \u2192 <code>List&lt;Tuple&gt;</code> </li> <li>Si seleccionas columnas espec\u00edficas \u2192 <code>List&lt;Object[]&gt;</code> </li> <li>Tambi\u00e9n puede proyectarse a un DTO usando <code>cb.construct(...)</code>.</li> </ul>"},{"location":"ud3/queries/#ventajas","title":"\u2705 Ventajas","text":"<ul> <li>Type-safe (detecta errores en compilaci\u00f3n).  </li> <li>Ideal para consultas din\u00e1micas.  </li> <li>100% est\u00e1ndar JPA.</li> </ul>"},{"location":"ud3/queries/#tabla-resumen","title":"\u27a1\ufe0f Tabla Resumen","text":"<ul> <li>CriteriaBuilder (<code>cb</code>) \u2192 f\u00e1brica de piezas: <code>Predicate</code>, <code>Expression</code>, <code>Order</code>, etc.   </li> <li>CriteriaQuery (<code>cq</code>) \u2192 plano de la consulta: <code>select</code>, <code>from</code>, <code>where</code>, <code>groupBy</code>, <code>having</code>, <code>orderBy</code>, <code>distinct</code>.   </li> <li>Desde el <code>from</code> (un Root/Join) sacas rutas (Path) y haces joins.      </li> </ul> Clase Qu\u00e9 es Qui\u00e9n la crea D\u00f3nde se usa Ejemplo corto <code>CriteriaBuilder</code> F\u00e1brica y helpers <code>em.getCriteriaBuilder()</code> En todas partes para construir cosas <code>cb.equal(\u2026), cb.and(\u2026), cb.sum(\u2026)</code> <code>CriteriaQuery&lt;T&gt;</code> Plano tipado de la query <code>SELECT</code> <code>cb.createQuery(T.class)</code> <code>select</code>, <code>where</code>, <code>groupBy</code>, \u2026 <code>cq.select(u).where(pred)</code> <code>Root&lt;T&gt;</code> Ra\u00edz de <code>FROM</code> (tabla principal) <code>cq.from(T.class)</code> Para acceder a campos y hacer joins <code>Root&lt;User&gt; u = cq.from(User.class)</code> <code>Join&lt;X,Y&gt;</code> Join tipado a una relaci\u00f3n <code>root.join(\"roles\")</code> Igual que tabla unida <code>Join&lt;User,Role&gt; r = u.join(\"roles\")</code> <code>Path&lt;X&gt;</code> Ruta a un atributo (columna) <code>root.get(\"email\")</code> Alimenta <code>Expression</code>, <code>Predicate</code> <code>Path&lt;String&gt; p = u.get(\"name\")</code> <code>Expression&lt;X&gt;</code> Valor calculado (sum, lower, etc) <code>cb.lower(path)</code>, <code>cb.sum(\u2026)</code> <code>select</code>, <code>groupBy</code>, <code>orderBy</code>, <code>having</code> <code>Expression&lt;String&gt; e = cb.lower(p)</code> <code>Predicate</code> Condici\u00f3n booleana <code>cb.equal(\u2026)</code>, <code>cb.and(\u2026)</code> <code>where</code>, <code>having</code> <code>Predicate p = cb.equal(u.get(\"active\"), true)</code> <code>Order</code> Ordenaci\u00f3n <code>cb.asc(expr)</code>, <code>cb.desc(expr)</code> <code>orderBy</code> <code>cq.orderBy(cb.desc(u.get(\"createdAt\")))</code> <code>Subquery&lt;X&gt;</code> Subconsulta <code>cq.subquery(X.class)</code> Como parte de <code>where</code>, <code>select</code> <code>Subquery&lt;Long&gt; sq = cq.subquery(Long.class)</code> <code>CompoundSelection&lt;T&gt;</code> Selecci\u00f3n compuesta (DTO/tuple) <code>cb.construct(Dto.class, \u2026)</code> <code>select</code> / <code>multiselect</code> <code>cq.select(cb.construct(Dto.class, u.get(\"id\"), \u2026))</code> <code>Tuple</code> y <code>TupleQuery</code> Fila heterog\u00e9nea y su query <code>cb.createTupleQuery()</code> Cuando quieres columnas sueltas <code>TupleQuery tq = cb.createTupleQuery()</code>"},{"location":"ud3/queries/#3-sql-nativo-createnativequery","title":"3\ufe0f\u20e3 SQL Nativo (<code>createNativeQuery</code>)","text":""},{"location":"ud3/queries/#que-es_2","title":"\ud83d\udcd8 Qu\u00e9 es","text":"<p>Permite ejecutar SQL directamente sobre la base de datos. Se usa cuando necesitas funciones espec\u00edficas del motor o rendimiento extremo.</p>"},{"location":"ud3/queries/#ejemplo_1","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>String sql = \"SELECT * FROM spaces WHERE active = 1 AND capacity &gt;= ?\";\nList&lt;Space&gt; result = session.createNativeQuery(sql, Space.class)\n.setParameter(1, 5)\n.getResultList();\nList&lt;Object[]&gt; filas = session.createNativeQuery(\n\"SELECT id, nombre FROM usuarios WHERE email LIKE ?\")\n.setParameter(1, \"%@example.com%\")\n.getResultList();\n</code></pre>"},{"location":"ud3/queries/#tipo-de-dato-devuelto_2","title":"\ud83e\udde9 Tipo de dato devuelto","text":"Par\u00e1metro usado Devuelve <code>createNativeQuery(sql)</code> <code>List&lt;Object[]&gt;</code> <code>createNativeQuery(sql, Space.class)</code> <code>List&lt;Space&gt;</code> (entidades gestionadas) <code>createNativeQuery(sql, Tuple.class)</code> <code>List&lt;Tuple&gt;</code>"},{"location":"ud3/queries/#ventajas_1","title":"\u2705 Ventajas","text":"<ul> <li>Acceso total al SQL y funciones nativas.  </li> <li>Permite mapear a entidades o DTOs.  </li> <li>\u00datil para consultas complejas o migraciones.</li> </ul>"},{"location":"ud3/queries/#desventajas","title":"\u26a0\ufe0f Desventajas","text":"<ul> <li>No es portable entre bases de datos.  </li> <li>No aprovecha completamente el contexto de persistencia.</li> </ul>"},{"location":"ud3/queries/#4-namedquery","title":"4\ufe0f\u20e3 @NamedQuery","text":""},{"location":"ud3/queries/#que-es_3","title":"\ud83d\udcd8 Qu\u00e9 es","text":"<p>Consultas JPQL predefinidas, declaradas en la propia entidad. Hibernate las valida al iniciar la aplicaci\u00f3n.</p>"},{"location":"ud3/queries/#ejemplo_2","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>@Entity\n@NamedQuery(\nname = \"Space.findActive\",\nquery = \"FROM Space s WHERE s.active = true\"\n)\npublic class Space { ... }\n// Uso\nList&lt;Space&gt; spaces = em.createNamedQuery(\"Space.findActive\", Space.class)\n.getResultList();\n</code></pre>"},{"location":"ud3/queries/#tipo-de-dato-devuelto_3","title":"\ud83e\udde9 Tipo de dato devuelto","text":"<ul> <li>Igual que JPQL: entidad (<code>List&lt;Space&gt;</code>), atributo (<code>List&lt;String&gt;</code>), DTO (<code>List&lt;Object[]&gt;</code> o <code>List&lt;DTO&gt;</code>).</li> </ul>"},{"location":"ud3/queries/#ventajas_2","title":"\u2705 Ventajas","text":"<ul> <li>Centraliza consultas reutilizables.  </li> <li>Validaci\u00f3n temprana (errores detectados al arrancar).  </li> <li>Buenas pr\u00e1cticas para queries compartidas.</li> </ul>"},{"location":"ud3/queries/#ejecutando-la-consulta","title":"\ud83c\udf90 EJECUTANDO la consulta","text":"<p>Dentro de la query se puede restringir el n\u00famero de resultados que devuelve con la opci\u00f3n <code>setMaxResults(int maxResults)</code>. Ejemplo:</p> <pre><code>String sql = \"SELECT * FROM spaces WHERE active = 1 AND capacity &gt;= ?\";\nSpace result = session.createNativeQuery(sql, Space.class)\n.setParameter(1, 5)\n.setMaxResults(1);\n.getSingleResultOrNull();\n</code></pre> <p>La interfaz <code>TypedQuery</code> se utiliza para controlar la ejecuci\u00f3n de la consulta. Ofrece tres tipos de resultados:</p> <ul> <li><code>getResultList()</code>: devuelve una lista con los resultados (lista vac\u00eda si no hay filas). No lanza excepci\u00f3n por \u201ccero resultados\u201d..</li> <li><code>getSingleResult()</code>: es solo para casos en los que la consulta siempre devuelve exactamente un resultado. Lanza excepci\u00f3n si no hay ninguno o si hay m\u00e1s de uno.</li> <li><code>getSingleResultOrNull()</code> \u2192 devuelve el \u00fanico resultado o null si no hay ninguno; sigue lanzando excepci\u00f3n si hay m\u00e1s de uno.</li> <li><code>getResultStream()</code>: permite que los resultados se recuperen de forma incremental, utilizando un cursor de base de datos.</li> </ul> <p>Warning</p> <p>El m\u00e9todo <code>getResultStream()</code> no suele ser \u00fatil. Casi siempre es una mala idea mantener abierto el cursor de una base de datos.</p>"},{"location":"ud3/queries/#comparativa-general","title":"\ud83e\uddfe Comparativa general","text":"Tipo de Query Sintaxis Tipo de retorno Uso t\u00edpico Ventajas Desventajas JPQL/HQL Texto (entidades) <code>List&lt;Entidad&gt;</code>, <code>List&lt;Object[]&gt;</code>, <code>List&lt;Tuple&gt;</code>, <code>List&lt;DTO&gt;</code> Consultas est\u00e1ndar Legible y portable No tipo-segura Criteria API Program\u00e1tica (Java) <code>List&lt;Entidad&gt;</code>, <code>List&lt;Tuple&gt;</code>, <code>List&lt;DTO&gt;</code> Filtros din\u00e1micos Tipo-segura y est\u00e1ndar Verbosa SQL Nativo SQL directo <code>List&lt;Object[]&gt;</code>, <code>List&lt;Tuple&gt;</code>, <code>List&lt;Entidad&gt;</code> Casos complejos o rendimiento Potente y flexible No portable @NamedQuery Declarativa Igual que JPQL Consultas reutilizables Validada al inicio Menos flexible"},{"location":"ud3/queries/#conclusion","title":"\ud83d\udcda Conclusi\u00f3n","text":"<ul> <li>Usa JPQL/HQL para la mayor\u00eda de los casos.  </li> <li>Usa Criteria API cuando necesites construir filtros din\u00e1micos.  </li> <li>Usa SQL nativo cuando necesites funciones espec\u00edficas o rendimiento extremo.  </li> <li>Usa @NamedQuery para centralizar y reutilizar consultas comunes.</li> </ul>"},{"location":"ud3/relations/","title":"\ud83e\udde9 Relaciones avanzadas en Hibernate","text":"<p>Este documento explica de forma clara y visual los conceptos m\u00e1s importantes relacionados con las relaciones entre entidades en Hibernate, incluyendo:</p> <ul> <li>\ud83c\udfaf Estrategias de carga (<code>fetch</code>)</li> <li>\ud83d\udd17 Cascadas (<code>cascade</code>)</li> <li>\ud83e\uddf9 Eliminaci\u00f3n de hu\u00e9rfanos (<code>orphanRemoval</code>)</li> <li>\ud83e\uddf1 Atributos disponibles en cada tipo de relaci\u00f3n</li> <li>\ud83d\udd12 Uso de <code>optional</code> y <code>nullable</code> correctamente</li> </ul>"},{"location":"ud3/relations/#1-estrategias-de-carga-fetchtypelazy-vs-fetchtypeeager","title":"\ud83c\udfaf 1. Estrategias de carga (<code>FetchType.LAZY</code> vs <code>FetchType.EAGER</code>)","text":"<p>Determinan cu\u00e1ndo se cargan las entidades relacionadas. Se puede usar en todas las relaciones, pero no tiene el mismo sentido ni las mismas \u201cconsecuencias\u201d seg\u00fan el tipo.</p> <ul> <li><code>FetchType.LAZY</code> (perezoso): se devuelve un proxy o una colecci\u00f3n perezosa y la relaci\u00f3n solo se carga cuando accedes al getter.</li> <li><code>FetchType.EAGER</code> (ansioso): cuando cargas la entidad principal, siempre se carga tambi\u00e9n la relaci\u00f3n, en la misma consulta (JOIN o varias consultas internas).</li> </ul> <p>Proxy es un objeto \u201cfalso\u201d que Hibernate coloca en lugar de la entidad real cuando usamos LAZY. Solo guarda el id y una referencia a la sesi\u00f3n.</p>"},{"location":"ud3/relations/#relaciones-manytoone-y-onetoone-to-one","title":"\ud83c\udff7\ufe0f Relaciones @ManyToOne y @OneToOne (To-One)","text":"<p>Defaults JPA:       - <code>@ManyToOne</code> \u2192 EAGER por defecto.      - <code>@OneToOne</code> \u2192 EAGER por defecto.      </p> <p>En Hibernate es totalmente v\u00e1lido y muy recomendable usar fetch = LAZY en @ManyToOne y @OneToOne, salvo que de verdad necesites siempre esa relaci\u00f3n.</p>"},{"location":"ud3/relations/#relaciones-onetomany-y-manytomany-colecciones","title":"\ud83c\udff7\ufe0f Relaciones @OneToMany y @ManyToMany (colecciones)","text":"<p>Defaults JPA:          - <code>@OneToMany</code> \u2192 LAZY por defecto.       - <code>@ManyToMany</code> \u2192 LAZY por defecto.       </p> <p>\u00bfPor qu\u00e9 casi nunca interesa EAGER aqu\u00ed? Si pones EAGER en colecciones, cada vez que cargues la entidad principal, Hibernate tendr\u00e1 que hacer joins complejos, o lanzar queries adicionales para cada colecci\u00f3n.</p>"},{"location":"ud3/relations/#resumen-en-tabla","title":"\ud83d\udcc4 Resumen en tabla","text":"Tipo de relaci\u00f3n Default JPA \u00bfSe puede poner LAZY? \u00bfSe puede poner EAGER? Recomendaci\u00f3n real en Hibernate <code>@ManyToOne</code> EAGER S\u00ed (muy usado) S\u00ed LAZY casi siempre <code>@OneToOne</code> EAGER S\u00ed (Hibernate lo soporta) S\u00ed LAZY casi siempre <code>@OneToMany</code> (colecci\u00f3n) LAZY S\u00ed (default) S\u00ed LAZY siempre, evitar EAGER <code>@ManyToMany</code> LAZY S\u00ed (default) S\u00ed LAZY siempre, evitar EAGER <p>Note</p> <p><code>LazyInitializationException</code> se obtiene cuando cuando se dan estas dos condiciones: tienes algo mapeado como LAZY (un @ManyToOne, @OneToMany, @ManyToMany, etc.) e intentas acceder a esa relaci\u00f3n cuando la Session ya est\u00e1 cerrada (o la entidad est\u00e1 detach). El proxy intenta inicializarse \u2192 necesita ir a BD. Pregunta a Hibernate por la <code>Session</code>. No hay sesi\u00f3n \u279c \ud83d\udca3 <code>LazyInitializationException</code></p>"},{"location":"ud3/relations/#ejemplo","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>@Entity\npublic class Departamento {\n@Id @GeneratedValue\nprivate Long id;\nprivate String nombre;\n@OneToMany(mappedBy = \"departamento\", fetch = FetchType.LAZY)\nprivate List&lt;Empleado&gt; empleados = new ArrayList&lt;&gt;();\n}\n@Entity\npublic class Empleado {\n@Id @GeneratedValue\nprivate Long id;\nprivate String nombre;\n@ManyToOne(fetch = FetchType.EAGER)\n@JoinColumn(name = \"departamento_id\")\nprivate Departamento departamento;\n}\n</code></pre> <p>\ud83d\udc49 Al cargar un <code>Departamento</code>, los <code>Empleados</code> no se traen hasta que accedemos a ellos con el m\u00e9todo  <code>getEmpleados()</code>. \ud83d\udc49 Al obtener un <code>Empleado</code>, su <code>departamento</code> se carga inmediatamente.</p> <pre><code>Departamento d = session.get(Departamento.class, 1L); // empleados no se cargan\nSystem.out.println(d.getNombre());\nSystem.out.println(d.getEmpleados().size()); // aqu\u00ed Hibernate lanza otra query y carga los empleados\n</code></pre> <p>\ud83d\udca1 Consejo: Usa <code>LAZY</code> por defecto. Solo cambia a <code>EAGER</code> si realmente necesitas los datos siempre. Un mal uso puede causar el problema N+1 queries.</p>"},{"location":"ud3/relations/#2-cascadas-cascade","title":"\ud83d\udd17 2. Cascadas (<code>cascade</code>)","text":"<p>Cuando t\u00fa haces una operaci\u00f3n sobre una entidad padre, Hibernate mira sus relaciones y dice:</p> <p>\u201c\u00bfDebo aplicar tambi\u00e9n esta operaci\u00f3n sobre la entidad hija?\u201d</p> <p>Si la respuesta es s\u00ed por el tipo de cascade configurado \u2192 Hibernate ejecuta autom\u00e1ticamente esa operaci\u00f3n en la entidad hija SIN que t\u00fa lo pidas expl\u00edcitamente.</p>"},{"location":"ud3/relations/#tipos-de-cascadetype","title":"\u2b50 Tipos de <code>CascadeType</code>","text":"Tipo Descripci\u00f3n <code>PERSIST</code> Cuando hago <code>persist()</code> en el padre \u2192 Hibernate hace <code>persist()</code> en los hijos. Relaciones 1:1 o 1:N donde el hijo no existe sin el padre <code>MERGE</code> Cuando hago <code>merge()</code> en el padre \u2192 Hibernate hace <code>merge()</code> en los hijos. <code>REMOVE</code> Cuando hago <code>remove()</code> en el padre \u2192 Hibernate borra tambi\u00e9n los hijos. Es la cascada m\u00e1s peligrosa. Si la usas mal en: <code>@ManyToOne</code>, <code>@ManyToMany</code> \ud83d\udca3 puedes borrar media base de datos sin querer. <code>REFRESH</code> Cuando hago <code>refresh()</code> en el padre \u2192 Hibernate vuelve a leer de BD el padre y sus hijos. Es la cascada menos usada. <code>DETACH</code> Las elimina o saca del contexto de persistencia. <code>ALL</code> PERSIST + MERGE + REMOVE + REFRESH + DETACH. Es decir, todas las operaciones se propagan al hijo. Este es el m\u00e1s usado en agregados, pero el m\u00e1s peligroso si lo pones en relaciones equivocadas."},{"location":"ud3/relations/#donde-si-y-donde-no-poner-cascade-reglas-finales","title":"\u2b50 D\u00d3NDE S\u00cd Y D\u00d3NDE NO PONER cascade (reglas finales)","text":"<p>\u2705 1. <code>@OneToOne</code> \u2014 S\u00cd se pueden usar cascades:      - \u2714\ufe0f \u00dasalo cuando el hijo pertenece 100% al ciclo de vida del padre    - \u274c NO usar cascades en <code>@OneToOne</code> cuando las dos entidades viven por separado      </p> <p>\u2705 2. <code>@OneToMany</code> \u2014 S\u00cd se usan cascades en agregados reales:          - \u2714\ufe0f \u00dasalo cuando los hijos solo existen por el padre      - \u274c NO usar cascade en <code>@OneToMany</code> si los hijos NO dependen del padre       </p> <p>\u274c 3. <code>@ManyToOne</code> \u2014 NUNCA usar cascades.</p> <p>\u274c 4. <code>@ManyToMany</code> \u2014 JAM\u00c1S usar cascades.</p>"},{"location":"ud3/relations/#ejemplo_1","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>@Entity\npublic class Pedido {\n@Id @GeneratedValue\nprivate Long id;\nprivate String cliente;\n@OneToMany(mappedBy = \"pedido\", cascade = CascadeType.ALL)\nprivate List&lt;LineaPedido&gt; lineas = new ArrayList&lt;&gt;();\n}\n@Entity\npublic class LineaPedido {\n@Id @GeneratedValue\nprivate Long id;\nprivate String producto;\n@ManyToOne\n@JoinColumn(name = \"pedido_id\")\nprivate Pedido pedido;\n}\n</code></pre> <p>\ud83d\udc49 Al guardar un <code>Pedido</code>, se guardan tambi\u00e9n sus <code>LineaPedido</code> gracias al <code>cascade</code>.</p>"},{"location":"ud3/relations/#uso","title":"\u2696\ufe0f Uso","text":"<pre><code>Pedido p = new Pedido();\np.setCliente(\"Juan\");\nLineaPedido l1 = new LineaPedido();\nl1.setProducto(\"Teclado\");\nl1.setCantidad(2);\nl1.setPedido(p);\np.getLineas().add(l1);\nsession.persist(p); // \u2705 Gracias al cascade, tambi\u00e9n se guarda LineaPedido\n</code></pre>"},{"location":"ud3/relations/#3-eliminacion-de-huerfanos-orphanremoval","title":"\ud83e\uddf9 3. Eliminaci\u00f3n de hu\u00e9rfanos (<code>orphanRemoval</code>)","text":"<p>Cuando se elimina un objeto de una colecci\u00f3n en el lado del padre, o cuando se desconecta o desvincula una relaci\u00f3n, por ejemplo, al establecer un campo a null o al asignar una nueva entidad. Si esa colecci\u00f3n tiene <code>orphanRemoval=true</code>, Hibernate lo borra tambi\u00e9n de la BD.</p>"},{"location":"ud3/relations/#en-que-tipos-de-relacion-se-puede-usar-orphanremoval","title":"\u2705 \u00bfEn qu\u00e9 tipos de relaci\u00f3n se puede usar <code>orphanRemoval</code>?","text":"<p>Solo tiene sentido (y est\u00e1 soportado por JPA/Hibernate) en:        - <code>@OneToOne</code>  - <code>@OneToMany</code> </p> <p>Da igual si:           - Es el lado propietario (@JoinColumn)     - O el lado mappedBy        </p> <p>Lo importante es que sea una relaci\u00f3n 1:1 o 1:N donde el hijo dependa del padre.</p>"},{"location":"ud3/relations/#ejemplo_2","title":"\ud83e\udde0 Ejemplo","text":"<pre><code>@OneToMany(mappedBy = \"pedido\", orphanRemoval = true)\nprivate List&lt;LineaPedido&gt; lineas = new ArrayList&lt;&gt;();\n// Uso\npedido.getLineas().remove(0); //\nsession.flush(); // \ud83e\uddf9 La l\u00ednea quitada de la lista en pedido desaparece de la BD\n</code></pre> <p>\u26a0\ufe0f Importante: <code>orphanRemoval</code> solo funciona con relaciones tipo <code>@OneToOne</code> o <code>@OneToMany</code>.</p>"},{"location":"ud3/relations/#uso_1","title":"\u2696\ufe0f Uso","text":"<pre><code>Pedido p = session.find(Pedido.class, 1L);\nLineaPedido l = p.getLineas().get(0);\np.getLineas().remove(l); // \u274c se elimina de la lista de l\u00edneas del pedido\nsession.flush(); // \ud83e\uddf9 Hibernate borra la LineaPedido de la BD\np.setLines(new ArrayList&lt;&gt;()); //\u2192 borras todas las l\u00edneas en BD.\np.getLines().clear(); // DELETE de todas las l\u00edneas\n//Relaciones 1:1\n@Entity\npublic class User {\n@OneToOne(mappedBy = \"user\",\norphanRemoval = true)\nprivate AccessCard accessCard;\n}\nuser.setAccessCard(null); \u2192 la AccessCard se borra en BD.\n</code></pre>"},{"location":"ud3/relations/#4-que-atributos-se-pueden-usar-en-cada-relacion","title":"\ud83e\uddf1 4. Qu\u00e9 atributos se pueden usar en cada relaci\u00f3n","text":"Relaci\u00f3n mappedBy cascade fetch orphanRemoval JoinColumn JoinTable optional nullable <code>@ManyToOne</code> \u274c \u2705 \u2705 \u274c \u2705 \u274c \u2705 \u2705 <code>@OneToMany</code> \u2705/\u274c \u2705 \u2705 \u2705 \u2705 (solo unidireccional) \u2705 (si no hay mappedBy) \u274c \u26a0\ufe0f solo si unidireccional <code>@OneToOne</code> \u2705/\u274c \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u2705 <code>@ManyToMany</code> \u2705/\u274c \u2705 \u2705 \u274c \u274c \u2705 \u274c \u274c <p>\ud83d\udcd8 Notas r\u00e1pidas - <code>mappedBy</code> \u2192 se usa en el lado no propietario (donde no est\u00e1 la FK). - <code>cascade</code> y <code>fetch</code> \u2192 se pueden usar en todas. - <code>orphanRemoval</code> \u2192 solo en @OneToOne / @OneToMany. - <code>JoinColumn</code> \u2192 define la columna FK (solo en el lado propietario). - <code>JoinTable</code> \u2192 se usa en relaciones @ManyToMany (y algunas unidireccionales).  </p>"},{"location":"ud3/relations/#5-optional-y-nullable","title":"\ud83d\udd12 5. <code>optional</code> y <code>nullable</code>","text":"<ul> <li> <p><code>@JoinColumn(nullable = false)</code> \u2192 Regla de base de datos/DDL: la columna FK es NOT NULL. La validaci\u00f3n \u201cdura\u201d sucede en la BD (ConstraintViolation) al hacer <code>flush</code> o <code>commit</code>. Asegura el esquema f\u00edsico de BD (si la columna puede ser NULL en la tabla).</p> </li> <li> <p><code>@ManyToOne(optional = false)</code> \u2192 Regla de modelo JPA (runtime): esta asociaci\u00f3n no puede ser null. Le da pistas a Hibernate para validar antes, optimizar joins y evitar selects innecesarios con LAZY. No garantiza que en la BD la FK sea NOT NULL (si la relaci\u00f3n puede ser null en el modelo de objetos).</p> </li> </ul> <p>Se aconseja su uso conjunto.</p> Atributo Capa Significado <code>optional</code> Hibernate (en tiempo de ejecuci\u00f3n) Si la referencia puede ser <code>null</code> en memoria. <code>nullable</code> Base de datos (DDL) Si la columna FK permite <code>NULL</code>. <p>\ud83e\udde9 Si la relaci\u00f3n es obligatoria, usa los dos: <code>optional = false</code> + <code>@JoinColumn(nullable = false)</code></p>"},{"location":"ud3/relations/#solo-nullable-false-sin-poner-optional-false","title":"Solo <code>nullable = false</code> sin poner <code>optional = false</code>","text":"<p>Persistes una entindad con la relaci\u00f3n a <code>null</code> \u2192 Hibernate hace <code>INSERT ...</code> con <code>relacion_id</code> = null \u2192 la BD lanza el error (ConstraintViolation) en el <code>flush</code>. Has hecho un viaje a BD para nada y el mensaje suele ser menos expresivo.</p> <p>Si hubiera puesto los dos, Hibernate sabe que es ilegal en el modelo y puede lanzar una <code>PropertyValueException</code> antes o durante la preparaci\u00f3n del insert, sin depender de la BD. Mensaje m\u00e1s claro y te ahorras roundtrip.</p>"},{"location":"ud3/relations/#solo-optional-false-sin-poner-nullable-false","title":"Solo <code>optional = false</code> sin poner <code>nullable = false</code>","text":"<p>Modelo JPA: marcas la relaci\u00f3n como obligatoria; si llega <code>venue == null</code>, el proveedor fallar\u00e1 (normalmente al <code>flush</code>) con una excepci\u00f3n de JPA/Hibernate.</p> <p>Esquema de BD: no garantizas nada. La columna puede seguir siendo NULL en la tabla si no has puesto <code>@JoinColumn(nullable=false)</code> (y no debes asumir que el proveedor de BD traducir\u00e1 optional=false a NOT NULL en el DDL; no est\u00e1 garantizado por la especificaci\u00f3n). </p> <p>Integridad real: si alguien inserta/actualiza por fuera de JPA, por ejemplo, de forma manual directamente en la BD, podr\u00e1 meter NULLs en la FK y romper tu invariante.</p> <p>Efectos colaterales: si acaban entrando NULLs, tus consultas que asumen relaci\u00f3n obligatoria (INNER JOIN, filtros, etc.) pueden dar resultados incoherentes.</p>"},{"location":"ud3/relations/#recomendacion-usar-las-dos-optional-false-y-nullable-false","title":"Recomendaci\u00f3n usar las dos <code>optional = false</code> y <code>nullable = false</code>","text":"<p>Garantiza:   - Plan de consulta y rendimiento   - Coherencia entre capas y herramientas   </p>"},{"location":"ud3/relations/#ejemplo-obligatorio","title":"\ud83e\udde0 Ejemplo obligatorio","text":"<pre><code>@ManyToOne(optional = false, fetch = FetchType.LAZY)\n@JoinColumn(name = \"departamento_id\", nullable = false)\nprivate Departamento departamento;\n@ManyToOne(fetch = FetchType.LAZY, optional = false)     // Regla en el modelo JPA (runtime/optimizaci\u00f3n)\n@JoinColumn(name = \"venue_id\", nullable = false)          // Regla f\u00edsica en BD (NOT NULL)\nprivate Venue venue;\n</code></pre> <p>\ud83d\udccc En colecciones (<code>@OneToMany</code>, <code>@ManyToMany</code>) no se usa <code>optional</code>, solo <code>nullable</code> en el lado hijo si hay <code>JoinColumn</code>.</p>"},{"location":"ud3/relations/#6-resumen-visual","title":"\u2705 6. Resumen visual","text":"Concepto Aplica a Efecto principal Capa <code>fetch</code> Todas Controla cu\u00e1ndo se carga la relaci\u00f3n ORM <code>cascade</code> Todas Propaga operaciones (guardar, eliminar...) ORM <code>orphanRemoval</code> OneToOne / OneToMany Elimina hijos al quitarlos del padre ORM <code>optional</code> OneToOne / ManyToOne Define si la referencia puede ser null ORM <code>nullable</code> Todas (FK) Define si la columna permite null BD <code>mappedBy</code> OneToOne / OneToMany / ManyToMany Marca el lado inverso de la relaci\u00f3n ORM"},{"location":"ud3/relations/#romper-relaciones","title":"\ud83e\uddf7 Romper relaciones","text":"<p>Romper una relaci\u00f3n significa desvincular dos entidades que antes estaban asociadas.</p>"},{"location":"ud3/relations/#concepto-clave","title":"\ud83e\udde9 Concepto clave","text":"<p>Cuando modificas una relaci\u00f3n en Java, por ejemplo:</p> <pre><code>//En User\n@OneToOne(mappedBy = \"user\", fetch = FetchType.LAZY)\nprivate AccessCard accessCard;\n//En AccessCard\n@OneToOne\n@JoinColumn(name = \"user_id\", nullable = true, unique = true)\nprivate User user;\n//en el service intentamos poner a null la relaci\u00f3n desde User\nuser.setAccessCard(null);\n</code></pre> <p>Esto solo cambia el valor del atributo en memoria. Lo que realmente ocurra en la base de datos depende de:         </p> <ol> <li>Qui\u00e9n es el propietario de la relaci\u00f3n (<code>@JoinColumn</code>)           </li> <li>Si has modificado el lado propietario o el lado inverso (<code>mappedBy</code>)     </li> <li>Si hay o no <code>orphanRemoval</code> </li> <li>Si la FK permite <code>NULL</code> (<code>nullable</code>)             </li> </ol>"},{"location":"ud3/relations/#1-el-lado-propietario-es-el-que-manda-sobre-la-fk","title":"\ud83e\udde9 1. El lado propietario es el que manda sobre la FK","text":"<p>Ejemplo de relaci\u00f3n 1:1:</p> <pre><code>// User (lado inverso)\n@OneToOne(mappedBy = \"user\", fetch = FetchType.LAZY)\nprivate AccessCard accessCard;\n// AccessCard (lado propietario, tiene la FK)\n@OneToOne\n@JoinColumn(name = \"user_id\", nullable = true, unique = true)\nprivate User user;\n</code></pre> <ul> <li>Propietario de la relaci\u00f3n: <code>AccessCard.user</code> </li> <li>Solo este lado controla qu\u00e9 valor se escribe en la FK (<code>user_id</code>).</li> </ul>"},{"location":"ud3/relations/#romper-la-relacion-solo-desde-el-inverso-no-actualiza-la-bd","title":"\u2757 Romper la relaci\u00f3n SOLO desde el inverso NO actualiza la BD","text":"<pre><code>User user = session.find(User.class, 2L);\nuser.setAccessCard(null);   // solo lado inverso\nsession.getTransaction().commit();\n</code></pre> <p>\u27a1\ufe0f En memoria la relaci\u00f3n se rompe, pero en la BD NO se pone <code>user_id = NULL</code>, porque no has tocado el owner.</p> <p>Hibernate solo sincroniza la FK desde el lado propietario.</p>"},{"location":"ud3/relations/#2-como-desvincular-correctamente-sin-borrar","title":"\ud83e\udde9 2. C\u00f3mo desvincular correctamente (sin borrar)","text":"<pre><code>User user = session.find(User.class, 2L);\nAccessCard card = user.getAccessCard();\nuser.setAccessCard(null);   // lado inverso\ncard.setUser(null);         // \u2714\ufe0f Lado propietario \u2192 actualiza la FK\nsession.getTransaction().commit();\n</code></pre> <p>Esto generar\u00e1:</p> <pre><code>UPDATE access_card SET user_id = NULL WHERE id = ?;\n</code></pre> <p>\ud83d\udc49 No hace falta ning\u00fan <code>cascade</code> para poner la FK a <code>null</code>. Lo importante es modificar el lado propietario.</p>"},{"location":"ud3/relations/#problema-n1-queries-en-hibernate","title":"\ud83d\udca5 Problema N+1 Queries en Hibernate","text":"<p>El problema N+1 queries es uno de los errores de rendimiento m\u00e1s comunes al usar Hibernate. Sucede cuando Hibernate ejecuta una query para obtener la entidad principal y luego N queries adicionales, una por cada entidad relacionada.</p>"},{"location":"ud3/relations/#que-significa-n1","title":"\u26a0\ufe0f \u00bfQu\u00e9 significa \u201cN+1\u201d?","text":"<ul> <li><code>1</code> \u2192 la primera query para obtener la lista principal.  </li> <li><code>N</code> \u2192 una query adicional por cada elemento para cargar sus relaciones.</li> </ul> <p>Ejemplo: Si cargas 10 departamentos, Hibernate ejecutar\u00e1 1 (departamentos) + 10 (empleados) = 11 queries.</p>"},{"location":"ud3/relations/#ejemplo-clasico","title":"\ud83e\udde9 Ejemplo cl\u00e1sico","text":"<pre><code>@Entity\npublic class Departamento {\n@Id @GeneratedValue\nprivate Long id;\nprivate String nombre;\n@OneToMany(mappedBy = \"departamento\", fetch = FetchType.LAZY)\nprivate List&lt;Empleado&gt; empleados;\n}\n@Entity\npublic class Empleado {\n@Id @GeneratedValue\nprivate Long id;\nprivate String nombre;\n@ManyToOne\n@JoinColumn(name = \"departamento_id\")\nprivate Departamento departamento;\n}\n</code></pre> <p>C\u00f3digo en el servicio:</p> <pre><code>List&lt;Departamento&gt; departamentos = session.createQuery(\n\"FROM Departamento\", Departamento.class).getResultList();\nfor (Departamento d : departamentos) {\nSystem.out.println(d.getNombre() + \" \u2192 \" + d.getEmpleados().size());//aqu\u00ed har\u00e1 una consulta para traerse empleados.\n}\n</code></pre>"},{"location":"ud3/relations/#lo-que-pasa-internamente","title":"\ud83d\udd0d Lo que pasa internamente","text":"<p>1\ufe0f\u20e3 Hibernate lanza: <pre><code>SELECT * FROM departamento;\n</code></pre></p> <p>2\ufe0f\u20e3 Luego, por cada departamento: <pre><code>SELECT * FROM empleado WHERE departamento_id = ?;\n</code></pre></p> <p>\u27a1\ufe0f Resultado: N+1 queries (una por cada departamento). \u27a1\ufe0f En listas grandes, esto puede ser muy lento.</p>"},{"location":"ud3/relations/#como-evitar-el-n1","title":"\ud83d\ude80 C\u00f3mo evitar el N+1","text":""},{"location":"ud3/relations/#opcion-1-usar-join-fetch","title":"\u2705 Opci\u00f3n 1: Usar <code>JOIN FETCH</code>","text":"<pre><code>List&lt;Departamento&gt; deps = session.createQuery(\n\"SELECT d FROM Departamento d JOIN FETCH d.empleados\",\nDepartamento.class\n).getResultList();\n</code></pre> <p>Hibernate genera: <pre><code>SELECT d.*, e.*\nFROM departamento d\nLEFT JOIN empleado e ON e.departamento_id = d.id;\n</code></pre></p> <p>\u27a1\ufe0f Todo se carga en una sola query.  </p> <p>\ud83d\udca1 Es la soluci\u00f3n m\u00e1s directa y recomendada para evitar el problema N+1.</p>"},{"location":"ud3/relations/#opcion-2-cambiar-fetch-eager-con-precaucion","title":"\u2705 Opci\u00f3n 2: Cambiar <code>fetch = EAGER</code> (con precauci\u00f3n)","text":"<pre><code>@OneToMany(mappedBy = \"departamento\", fetch = FetchType.EAGER)\nprivate List&lt;Empleado&gt; empleados;\n</code></pre> <p>Hibernate har\u00e1 autom\u00e1ticamente el JOIN, pero: \u26a0\ufe0f Puede generar joins masivos e innecesarios si hay muchas relaciones. Se recomienda solo cuando siempre necesitas los datos relacionados.</p>"},{"location":"ud4/41introduccionspring/","title":"\ud83d\uddb2\ufe0f Introducci\u00f3n a Spring Framework - Web oficial","text":"<p>Debido al aumento de la complejidad que presentan la mayor\u00eda de los sistemas web, tanto en temas de seguridad, funcionalidad y gr\u00e1ficas, la comunidad de desarrolladores se vio en la necesidad de dise\u00f1ar ciertas ayudas, a fin de no tener que repetir c\u00f3digo, reduciendo de este modo el tiempo y el espacio para el desarrollo de aplicaciones.</p> <p>Lanzado por primera vez, como una plataforma de c\u00f3digo abierto Java, en el mes de Junio del a\u00f1o 2003 bajo la licencia Apache 2.0, se convirti\u00f3 desde entonces en el framework m\u00e1s popular para Java empresarial, para crear c\u00f3digo de alto rendimiento, liviano y reutilizable. </p> <p>Su finalidad es estandarizar, agilizar, manejar y resolver los problemas que puedan ir surgiendo en el trayecto de la programaci\u00f3n.</p> <p>Spring se puede considerar como el padre del los frameworks Java, ya que da soporte a varios frameworks como: Hibernate, Struts, Tapestry, EJB, JSF entre otros.</p> <p>La versi\u00f3n actual de Spring Framework es la 6.x.x, esta versi\u00f3n requiere Java 17+ y puedes obtener la documentaci\u00f3n desde su web oficial.</p>"},{"location":"ud4/41introduccionspring/#modulos-de-spring","title":"\ud83e\ude94 M\u00f3dulos de Spring","text":"<p>Spring est\u00e1 compuesto por muchas librer\u00edas y cada una de ellas est\u00e1 destinada a una finalidad: Bases de datos, Seguridad, Servicios Web, etc. As\u00ed, estas librer\u00edas se engloban en distintos m\u00f3dulos listos para usar. \u00c9stos son algunos de ellos:</p> <ul> <li>Spring Core Container: IoC Container (Inversi\u00f3n de Control): Administra la creaci\u00f3n, configuraci\u00f3n y destrucci\u00f3n de objetos (beans) en una aplicaci\u00f3n. DI (Inyecci\u00f3n de Dependencias): Permite la inyecci\u00f3n de dependencias en los objetos, facilitando la configuraci\u00f3n y el mantenimiento.</li> <li>Spring AOP (Aspect-Oriented Programming): Facilita la programaci\u00f3n orientada a aspectos, permitiendo separar preocupaciones transversales como la seguridad y el registro del c\u00f3digo principal.</li> <li>Spring Data: Proporciona librer\u00edas necesarias para trabajar con bases de datos relacionales y no relacionales.</li> <li>Spring Cloud: Facilita el despliegue de aplicaciones Spring en plataformas ubicadas en la nube.  </li> <li>Spring Security: Ofrece librer\u00edas que facilitan la seguridad en aplicaciones Spring, en relaci\u00f3n a controles de acceso y autenticaci\u00f3n.</li> <li>Spring Batch: Se utiliza para automatizar tareas batch. Estas tareas normalmente s ejecutan en horar\u00edos nocturnos y donde se manejan grandes cantidades de datos. </li> <li>Spring Model-View-Controller (MVC): Ofrece una implementaci\u00f3n del patr\u00f3n MVC para el desarrollo de aplicaciones web.</li> <li>Spring Test: Ofrece soporte para la escritura y ejecuci\u00f3n de pruebas unitarias y de integraci\u00f3n para componentes de Spring.</li> </ul> <p>Estos m\u00f3dulos pueden reducir dr\u00e1sticamente el tiempo de desarrollo de una aplicaci\u00f3n.</p>"},{"location":"ud4/41introduccionspring/#que-es-spring-boot","title":"\ud83e\ude94 \u00bfQu\u00e9 es Spring Boot?","text":"<p>Spring Boot es b\u00e1sicamente una extensi\u00f3n del marco Spring, que elimina las configuraciones repetitivas necesarias para configurar una aplicaci\u00f3n Spring.</p>"},{"location":"ud4/41introduccionspring/#como-arranca-spring-boot","title":"\u00bfC\u00f3mo arranca Spring Boot?","text":"<p>El punto de entrada de una aplicaci\u00f3n Spring Boot es la clase anotada con @SpringBootApplication. De forma predeterminada, Spring Boot utiliza un contenedor integrado para ejecutar la aplicaci\u00f3n. En este caso, Spring Boot utiliza el punto de entrada principal p\u00fablico est\u00e1tico y vac\u00edo para iniciar un servidor web integrado.</p> <p>Otra caracter\u00edstica de Spring Boot es que escanea autom\u00e1ticamente todas las clases en el mismo paquete o subpaquetes de la clase principal en busca de componentes.</p>"},{"location":"ud4/41introduccionspring/#requisitos-para-crear-un-proyecto-con-spring","title":"\ud83e\ude94 Requisitos para crear un proyecto con Spring","text":"<p>Para crear un proyecto con Spring debemos realizar una serie de pasos:</p> <ol> <li>Elegir el tipo de proyecto, es decir, elegir la herramienta de construcci\u00f3n del proyecto: Maven o Gradle y la versi\u00f3n de Java.</li> <li>Seleccionar las dependencias que necesitamos y su versi\u00f3n.</li> <li>Construir la estructura de directorios de nuestro proyecto, donde estar\u00e1 el c\u00f3digo fuente, los ficheros properties, plantillas, etc.</li> <li>Uso y configuraci\u00f3n de beans.</li> </ol>"},{"location":"ud4/41introduccionspring/#beans","title":"\ud83e\ude94 Beans","text":"<p>Para entender el concepto de bean en Spring necesitamos entender antes una serie algunos conceptos y c\u00f3mo administra Spring los objetos beans.</p>"},{"location":"ud4/41introduccionspring/#dependency-injection-di","title":"\ud83e\ude83 Dependency Injection (DI)","text":"<p>La inyecci\u00f3n de dependencias es un patr\u00f3n de dise\u00f1o que tiene como objetivo tomar la responsabilidad de crear las instancias de las clases que otro objeto necesita y suministr\u00e1rselo para que esta clase los pueda utilizar.</p> <p>Habitualmente nuestras clases dependen de otras para funcionar. Este patr\u00f3n permite que una clase no sea responsable de crear o administrar sus dependencias, sino que estas le sean inyectadas desde el exterior.</p>"},{"location":"ud4/41introduccionspring/#ejemplo-de-di","title":"Ejemplo de DI","text":"<p>Por ejemplo, una clase que necesita buscar un registro en la base de datos necesitar\u00e1 de otra que se encargue de buscarlo.</p> <p>Pensemos en estas dos clases. Llamemos a la primera <code>PersonalDataService</code> que es la encargada de tomar decisiones sobre el negocio y a la segunda <code>PersonaDAO</code>, la cual se encargar\u00e1 de acceder a la base de datos. </p> <p>La clase <code>PersonalDataService</code> depende de la clase <code>PersonaDAO</code> para lograr el acceso a los datos en la base de datos, es decir, la clase <code>PersonalDataService</code> ser\u00eda la responsable de crear una instancia de la clase <code>PersonaDAO</code>.</p> <p>En la inyecci\u00f3n de dependencias \u2018alguien\u2019 externo se encarga de las dependencias que las clases necesitan.</p>"},{"location":"ud4/41introduccionspring/#inversion-of-control-ioc","title":"\ud83e\ude83 Inversion of Control (IoC)","text":"<p>Spring tambi\u00e9n maneja el concepto de inversi\u00f3n de control ocup\u00e1ndose de mantener en su \u2018contexto\u2019 (application context) todas las instancias de nuestra aplicaci\u00f3n y de inyectarle esa instancia a quien la necesite.</p> <p>Spring llama a estas instancias beans.</p> <p></p> <p>Los beans son las instancias de las clases que est\u00e1n disponibles para ser reutilizados y son gestionados dentro del contenedor de Spring (Spring container). Spring sabe qu\u00e9 dependencias existen entre las instancias y se encarga de satisfacerlas.</p> <p>Note</p> <p>IoC es el trabajo que realiza Spring buscando estas dependencias entre los objetos y realizando el \u2018set\u2019 de estos beans en quien los requiera. Busca en su contenedor de beans la instancia adecuada y se la agrega al objeto cumpliendo as\u00ed con la inyecci\u00f3n de dependencias.</p>"},{"location":"ud4/41introduccionspring/#definir-un-bean","title":"\ud83e\ude83 Definir un Bean","text":"<p>Para definir un nuevo bean en Spring tenemos dos opciones:</p> <ul> <li>Podemos definir expl\u00edcitamente un nuevo bean mediante la anotaci\u00f3n <code>@Bean</code>.</li> <li>Podemos marcar una clase Java como un bean, y permitir a Spring que lo descubra, esto se hace mediante el escaneo de componentes.</li> </ul> <p>Estas son dos t\u00e9cnicas diferentes para a\u00f1adir beans a nuestro contexto.</p>"},{"location":"ud4/41introduccionspring/#que-es-un-componente-component-en-spring","title":"\ud83e\ude94 \u00bfQu\u00e9 es un componente <code>@Component</code> en Spring?","text":"<p>Spring define un conjunto de anotaciones core que categorizan cada uno de los componentes asociandoles una responsabilidad concreta, es lo que llamamos Spring stereotypes.</p> <p>Una clase con la anotaci\u00f3n <code>@Component</code> es un candidato a ser escaneado mediante el proceso de negociaci\u00f3n, e instanciado como un bean y a\u00f1adido al contexto.</p> <p>Cuando indicamos que una clase es un <code>@Component</code>, lo que hacemos es decirle a Spring que queremos que cree una instancia y la gestione.</p> <p><pre><code>@Component\npublic class MyClass {\npublic void doSomething() {\n//.. \n}\n}\n</code></pre> Al momento de inicializar la aplicaci\u00f3n, Spring har\u00e1 lo siguiente:</p> <ul> <li>Buscar\u00e1 dentro de la aplicaci\u00f3n las clases anotadas con<code>@Component</code></li> <li>Crear\u00e1 una instancia de los componentes</li> <li>Dejar\u00e1 el componente en su contexto</li> <li>Buscar\u00e1 qui\u00e9n necesita esos componentes y los inyectar\u00e1 en qui\u00e9n los necesite.</li> </ul>"},{"location":"ud4/41introduccionspring/#spring-stereotypes","title":"\ud83e\ude83 Spring Stereotypes","text":"<p>Los estereotipos (Stereotypes) son componentes que extienden de <code>@Component</code>.</p> <p>Existen cuatro:</p> <ol> <li> <p>@Component: estereotipo general.</p> </li> <li> <p>@Repository: ser\u00e1 parte de la \u2018capa\u2019 de persistencia cuya funci\u00f3n ser\u00e1 el acceso a los datos.</p> </li> <li> <p>@Service: ser\u00e1 parte de la \u2018capa\u2019 de servicios encargado de gestionar las operaciones de negocio m\u00e1s importantes a nivel de la aplicaci\u00f3n y aglutina llamadas a varios repositorios de forma simult\u00e1nea.</p> </li> <li> <p>@Controller: realiza las tareas de controlador y gesti\u00f3n de la comunicaci\u00f3n entre el usuario y el aplicativo. Existe <code>@RestController</code> que es una especializaci\u00f3n de controller.</p> </li> </ol> <p></p>"},{"location":"ud4/41introduccionspring/#como-crear-un-proyecto-con-spring-en-intellij","title":"\ud83e\ude94 C\u00f3mo crear un proyecto con Spring en IntelliJ","text":"<p>Podemos ayudarnos de la herramienta spring initializr para crear el proyecto. Seleccionamos la siguiente configuraci\u00f3n:</p> <p></p> <p>La exportamos y extraemos para abrir como un proyecto nuevo en IntelliJ.</p> <p>Instalamos los plugins en IntelliJ llamados JPA Buddy y Lombok que ser\u00e1n de gran ayuda para desarrollar algunas funcionalidades y ahorrarnos boilerplate.</p>"},{"location":"ud4/41introduccionspring/#autoconfiguracion-del-proyecto","title":"\ud83e\ude94 Autoconfiguraci\u00f3n del proyecto","text":"<p>La anotaci\u00f3n <code>@SpringBootApplication</code> habilita el mecanismo de configuraci\u00f3n autom\u00e1tica de la aplicaci\u00f3n en funci\u00f3n de las dependencias jar que encuentre en el classpath y se encarga del escaneo de componentes.</p>"},{"location":"ud4/41introduccionspring/#estructura-del-proyecto","title":"\ud83e\ude94 Estructura del proyecto","text":"<p>La estructura de un proyecto en Spring debe contener los siguientes paquetes entre otros:</p> <p></p>"},{"location":"ud4/42repository/","title":"\u2668\ufe0f Trabajando con Spring Data JPA","text":"<p>Gracias a Spring Data JPA, que facilita el uso de tecnolog\u00edas de acceso a datos, bases de datos relacionales y no relacionales, servicios de datos basados en la nube, etc., podemos trabajar con Spring Data JPA repositories. El objetivo del repositorio de Spring Data es reducir significativamente la cantidad de c\u00f3digo repetitivo necesario para implementar capas de acceso a datos de persistencia.</p> <p>La interfaz central en la abstracci\u00f3n del repositorio de Spring Data es <code>Repository</code>. Esta interfaz act\u00faa principalmente como una interfaz de marcador para capturar los tipos con los que trabajar y para ayudarlo a descubrir interfaces que ampl\u00edan esta. </p> <p>Las interfaces <code>CrudRepository</code> y <code>ListCrudRepository</code> brindan una funcionalidad CRUD sofisticada para la clase de entidad que se administra.</p> <p></p> <p>Adem\u00e1s de <code>CrudRepository</code>, hay una abstracci\u00f3n <code>PagingAndSortingRepository</code> que agrega m\u00e9todos adicionales para facilitar el acceso paginado a las entidades:</p> <p></p>"},{"location":"ud4/42repository/#definir-interfaces-de-repositorio","title":"\ud83d\udcae Definir interfaces de repositorio","text":"<p>Para definir una interfaz de repositorio, primero se debe crear una clase de dominio o entidad. La interfaz debe extender el <code>Repository</code> y el tipo debe ser la clase de dominio y el tipo de ID.</p> <p>Si desea exponer m\u00e9todos CRUD para ese tipo de dominio, se puede extender de <code>CrudRepository</code> o una de sus variantes en lugar de <code>Repository</code>. <code>JpaRepository</code> es una especializaci\u00f3n de <code>ListCrudRepository</code>.</p> PersonRepository.java<pre><code>public interface PersonRepository extends JpaRepository&lt;Todo, Long&gt; {\n//con esto heredamos todos los m\u00e9todos definidos en JpaRepository y las clases que se extienden en ella\n}\n</code></pre>"},{"location":"ud4/42repository/#anadir-entidades-en-intellij","title":"\ud83d\udcae A\u00f1adir entidades en IntelliJ","text":"<p>Dentro del paquete <code>entities</code> de proyecto, gracias al plugin que hemos instalado basta con hacer bot\u00f3n derecho sobre el paquete, New --&gt; JPA Entity, y nos crear\u00e1 una entidad.</p> <p>Para crear los campos de la entidad basta con hacer uso de la paleta de JPA. Para crear el atributo <code>id</code> de clave primaria hacemos doble click y rellenamos los campos.</p> <p></p> <p>Al utilizar Lombok nos podemos evitar escribir mucho c\u00f3digo boilerplate, ya que el plugin lo hace por nosotros. Para ellos, hacemos click en la palabra <code>Todo</code> de la clase java, se mostrar\u00e1n una serie de par\u00e1metros en la paleta JPA Inspector, hacemos check en las casillas de Getter, Setter y NoArgsConstructor.</p> <p></p> <p>Esto a\u00f1ade en la clase de la entidad las siguientes anotaciones: @Getter, @Setter y @NoArgsConstructor. </p> <p>Lo que implica que genera por nosotros los getters y setters de todos los campos como p\u00fablicos y el constructor por defecto.</p> Person.java<pre><code>@NoArgsConstructor\n@Getter\n@Setter\n@Entity\n@Table(name = \"person\")\npublic class Person {\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\n@Column(name = \"id\", nullable = false)\nprivate Long id;\n@Column(name = \"name\")\nprivate String name;\n@Column(name = \"active\")\nprivate Boolean active;\n}\n</code></pre>"},{"location":"ud4/42repository/#query-methods","title":"\ud83d\udcae Query Methods","text":"<p>El mecanismo de creaci\u00f3n de consultas integrado en la infraestructura del repositorio Spring Data es \u00fatil para crear consultas restrictivas sobre las entidades del repositorio.</p> <p>El an\u00e1lisis de nombres de queries de consulta se divide en sujeto y predicado. </p> <ul> <li>La primera parte (<code>find\u2026By</code>, <code>exists\u2026By</code>) define el sujeto de la consulta, </li> <li>La segunda parte forma el predicado. La cl\u00e1usula introductoria (sujeto) puede contener m\u00e1s expresiones. </li> </ul> <p>Cualquier texto entre <code>find</code> (u otras palabras clave introductorias) y <code>By</code> se considera descriptivo a menos que se use una de las palabras clave que limitan los resultados, como <code>Distinct</code> o <code>Top/First</code>.</p> <p>Ejemplos de Query Methods</p> PersonRespository.java<pre><code>interface PersonRepository extends Repository&lt;Person, Long&gt; {\nList&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n// Enables the distinct flag for the query\nList&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\nList&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n// Enabling ignoring case for an individual property\nList&lt;Person&gt; findByLastnameIgnoreCase(String lastname);\n// Enabling ignoring case for all suitable properties\nList&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n// Enabling static ORDER BY for a query\nList&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);\nList&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);\n// Like - where x.firstname like ?1 (parameter bound wrapped in %)\nList&lt;Person&gt; findByFirstnameContaining(String firstname);\n//Between -  where x.startDate between ?1 and ?2 - Busca las personas nacidas entre esas fechas\nList&lt;Person&gt; findByBirthDateBetween(LocalDate dateBegin, LocalDate dateEnd);\n}\n</code></pre> <p>En la documentaci\u00f3n oficial de Spring Data JPA encontramos la siguientes tablas con las palabras clave admitidas:</p> <ul> <li>Query subject keywords</li> <li>Query predicate keywords</li> </ul>"},{"location":"ud4/42repository/#limitacion-de-resultados","title":"Limitaci\u00f3n de resultados","text":"<p>Se puede limitar los resultados de los m\u00e9todos de consulta utilizando las palabras clave <code>first</code> o <code>top</code> indistintamente. Podemos agregar un valor num\u00e9rico opcional a <code>top</code> o <code>first</code> para especificar el tama\u00f1o m\u00e1ximo de resultado que devolver\u00e1 la consulta. </p> <p>Si se omite el n\u00famero, se asume un tama\u00f1o de resultado de 1. </p> <p>Ejemplos web oficial de Spring:</p> <pre><code>User findFirstByOrderByLastnameAsc();\nUser findTopByOrderByAgeDesc();\nPage&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);\nSlice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);\nList&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);\nList&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);\n</code></pre>"},{"location":"ud4/42repository/#streaming-los-resultados-de-las-consultas","title":"Streaming los resultados de las consultas","text":"<p>Podemos procesar los resultados de los m\u00e9todos de consulta utilizando Java 8 Stream como tipo de retorno."},{"location":"ud4/43rest/","title":"\ud83d\udd06 API Rest","text":""},{"location":"ud4/43rest/#que-es-una-api","title":"\u2695\ufe0f\u00bfQu\u00e9 es una API?","text":"<p>Una API (Application Programming Interface) es un conjunto de definiciones y protocolos que permite que diferentes aplicaciones o sistemas se comuniquen entre s\u00ed. Es decir, una API act\u00faa como intermediario que permite que dos programas interact\u00faen y compartan informaci\u00f3n o funcionalidades.</p> <p>Las APIs son esenciales en el desarrollo moderno, ya que permiten integrar servicios como pagos, mapas, redes sociales, etc.</p>"},{"location":"ud4/43rest/#elementos-clave-de-una-api","title":"\u2695\ufe0fElementos clave de una API","text":"<ul> <li>Interfaz: define c\u00f3mo los desarrolladores pueden interactuar con el software o sistema. Esto incluye las solicitudes que se pueden realizar y los formatos de datos aceptados.</li> <li>Protocolo: especifica las reglas para intercambiar los datos, como HTTP/HTTPS para APIs webs.</li> <li>Datos: las APIs permiten enviar y recibir datos en formatos comunes como JSON o XML.</li> <li>Funcionalidades: pueden ofrecer acceso a herramientas, servicios o informaci\u00f3n de un sistema externo, sin necesidad de que los usuarios conozcan su funcionamiento interno.</li> </ul>"},{"location":"ud4/43rest/#tipos-de-apis-mas-comunes","title":"\u2695\ufe0fTipos de APIs m\u00e1s comunes","text":"<ul> <li>REST (Representational State Transfer): utilizan HTTP y son muy populares por su simplicidad.</li> <li>SOAP (Simple Object Access Protocol): m\u00e1s complejo, usa XML para intercambiar datos.</li> <li>GraphQL: permite a los clientes especificar exactamente qu\u00e9 datos necesitan.</li> </ul>"},{"location":"ud4/43rest/#api-rest_1","title":"\u2695\ufe0fAPI Rest","text":"<p>Es un tipo de API que sigue los principios de la arquitectura REST, dise\u00f1ados para facilitar la comunicaci\u00f3n entre sistemas a trav\u00e9s de la web utilizando el protocolo HTTP. REST es un estilo de arquitectura que define c\u00f3mo se deben estructurar y consumir las APIs para que sean eficientes, simples y escalables. Son ampliamente utilizadas en el desarrollo de software moderno.</p> <p>A menudo se puede ver el nombre de API RESTful, RESTful es un adjetivo que describe a las APIs que siguen los principios y restricciones de la arquitectura REST.</p>"},{"location":"ud4/43rest/#principios-de-una-api-rest","title":"\u2695\ufe0fPrincipios de una API REST","text":"<ol> <li>Cliente-Servidor: el cliente (navegador web normalmente) solicita informaci\u00f3n o realiza acciones y el servidor procesa estas solicitudes y devuelve una respuesta. Ambos son independientes.</li> <li>Stateless (Sin estado): cada solicitud del cliente al servidor es independiente. El servidor no almacena informaci\u00f3n sobre el estado de las solicitudes anteriores.</li> <li>Interfaz uniforme: la comunicaci\u00f3n entre cliente-servidor se realiza de manera consistente. Los recursos se identifican mediante URLs, y se usan m\u00e9todos HTTP est\u00e1ndar para interactuar con ellos:<ul> <li>GET: obtener datos</li> <li>POST: enviar o crear datos</li> <li>PUT o PATCH: actualizar datos existentes</li> <li>DELETE: eliminar datos</li> </ul> </li> <li>Recursos identificados por URLs: los recursos (datos) en una API REST se identifican mediante direcciones \u00fanicas o endpoints, por ejemplo, este endpoint podr\u00eda devolver los datos del usuario con ID 123: GET https://api.miservicio.com/usuarios/123</li> <li>Representaci\u00f3n de recursos: la informaci\u00f3n se intercambia en un formato espec\u00edfico, generalmente JSON o XML. JSON es el m\u00e1s popular debido a su legibilidad.</li> </ol>"},{"location":"ud4/43rest/#spring-web","title":"\u2695\ufe0fSpring Web","text":"<p>El framework Spring ofrece el m\u00f3dulo Spring Web, que se utiliza para la creaci\u00f3n de APIs REST. Este m\u00f3dulo proporciona las herramientas y anotaciones necesarias para construir y exponer endpoints RESTful.</p>"},{"location":"ud4/43rest/#componentes-de-spring-para-crear-una-api-rest","title":"\u2695\ufe0fComponentes de Spring para crear una API REST","text":"<ol> <li>Controladores REST: los controladores son los responsables de manejar las solicitudes HTTP y devolver las respuestas adecuadas.</li> <li>Anotaciones clave:<ul> <li><code>@RestController</code>: marca una clase como controlador REST. Combina @Controller y @ResponseBody, indicando que los m\u00e9todos devolver\u00e1n datos directamente (en formato JSON o XML) en lugar de vistas HTML.</li> <li><code>@RequestMapping</code>: define la ruta de acceso base para los endpoints de un controlador.</li> <li>M\u00e9todos espec\u00edficos:<ul> <li><code>@GetMapping</code>: solicitudes HTTP GET</li> <li><code>@PostMapping</code>: solicitudes HTTP POST</li> <li><code>@PutMapping</code>: solicitudes HTTP PUT</li> <li><code>@DeleteMapping</code>: solicitudes HTTP DELETE</li> <li><code>@PatchMapping</code>: solicitudes HTTP PATCH</li> </ul> </li> </ul> </li> <li>Serializaci\u00f3n y Deserializaci\u00f3n: Spring utiliza Jackson de forma predeterminada para convertir objetos Java a JSON y viceversa. Es decir, un objeto <code>Usuario</code> puede enviarse como respuesta en formato JSON autom\u00e1ticamente.</li> <li>Inyecci\u00f3n de Dependencias y Servicios: los controladores suelen delegar la l\u00f3gica de negocio a las clases servicio, marcadas con <code>@Service</code>, para mantener el c\u00f3digo modular y limpio.</li> </ol> <p>Note</p> <p>Jackson es una biblioteca Java para trabajar con datos en formato JSON. Se utiliza para la serializaci\u00f3n (convertir objetos Java a JSON) y la deserializaci\u00f3n (convertir JSON a objetos Java). Viene configurada por defecto en Spring para el intercambio de datos en APIs REST.</p>"},{"location":"ud4/43rest/#como-crear-un-controlador-rest-en-spring","title":"\u2695\ufe0fC\u00f3mo crear un controlador rest en Spring","text":"<p>El primer paso para crear un \u2018controlador rest\u2019 es anotar la clase que con <code>@RestController</code>.</p> <p>Con esto Spring ya sabe que esa clase ser\u00e1 un componente encargado de recibir llamadas.</p> <p>En la clase tambi\u00e9n podemos definir la ruta ra\u00edz por la cu\u00e1l partir\u00e1n las llamadas externas con la anotaci\u00f3n <code>@RequestMapping</code>.</p> PersonController.java<pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class PersonController {\n}\n</code></pre> <p>Dentro del controlador a\u00f1adiremos los m\u00e9todos con lo que se mapear\u00e1n las diferentes rutas o paths.</p>"},{"location":"ud4/43rest/#tipos-de-mapeo-mapping-en-un-controlador-rest","title":"\u2695\ufe0fTipos de mapeo (mapping) en un controlador rest","text":"<p>Existen los siguientes tipos de mapeo que podemos usar en Spring:</p> <p></p> <ul> <li>Get: para solicitar informaci\u00f3n de un recurso.</li> <li>Post: para enviar informaci\u00f3n a fin de crear o de actualizar un recurso.</li> <li>Put: para enviar informaci\u00f3n a fin de modificar un recurso.</li> <li>Patch: actualiza una parte del recurso.</li> <li>Delete: elimina un recurso espec\u00edfico.</li> </ul>"},{"location":"ud4/43rest/#cual-es-la-diferencia-entre-post-put-patch","title":"\u00bfCu\u00e1l es la diferencia entre Post , Put, Patch?","text":"<p>Habitualmente la diferencia entre Post y Put radica en que Post lo usamos para a\u00f1adir un recurso y Put lo utilizamos para modificar un recurso en particular.</p> <p>Patch tambi\u00e9n lo utilizamos para actualizar un recurso pero solo una parcialidad del mismo.</p>"},{"location":"ud4/43rest/#ejemplos-de-mapeo","title":"\u2695\ufe0fEjemplos de mapeo","text":"PersonController.java<pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class PersonController {\nprivate final PersonService personService;//Inyecci\u00f3n de dependencias\npublic PersonController(PersonService personService) {\nthis.personService = personService;\n}\n@GetMapping\npublic List&lt;Person&gt; getPersons() {\nreturn personService.findAll();\n}\n@GetMapping(\"/person/{id}\")\npublic Person byId(@PathVariable(\"id\") Long id) {\nreturn personService.find(id).orElseThrow();\n}\n@PostMapping(\"/person/\")\npublic Person newPerson(@RequestBody Person person) {\nreturn personService.create(person);\n}\n@PutMapping(\"/person/\")\npublic Person update(@RequestBody Person person) {\nreturn personService.update(person);\n}\n@PatchMapping(\"/person/\")\npublic Person change(@RequestBody Person person) {\nreturn personService.change(person);\n}\n@DeleteMapping(\"/person/{id}\")\npublic boolean delete(@PathVariable(\"id\") Long id) {\nreturn personService.remove(id);\n}\n}\n</code></pre>"},{"location":"ud4/44queryresponse/","title":"\u2753 Anotaci\u00f3n @Query y \ud83c\udd97 Response","text":""},{"location":"ud4/44queryresponse/#la-anotacion-query-tiene-4-usos","title":"\u2753 La anotaci\u00f3n '@Query' tiene 4 usos","text":"<p>1 Consultas personalizadas: Puedes definir consultas personalizadas que van m\u00e1s all\u00e1 de los m\u00e9todos CRUD b\u00e1sicos proporcionados por Spring Data JPA. Esto es \u00fatil cuando necesitas realizar operaciones m\u00e1s complejas o espec\u00edficas que no se cubren autom\u00e1ticamente.</p> <pre><code>    @Query(\"SELECT t FROM Todo t WHERE t.completed = true\")//lenguaje objeto\nList&lt;Todo&gt; encontrarTodosCompletados();\n@Query(value = \"select t from Todo t where t.title = ?1\")\nTodo findByTitleQuery(String title);\n</code></pre> <p>2 Consultas nativas: Puedes ejecutar consultas SQL nativas utilizando la anotaci\u00f3n @Query. Esto es \u00fatil cuando necesitas aprovechar funcionalidades espec\u00edficas del motor de base de datos que no est\u00e1n cubiertas por JPQL.</p> <pre><code>    @Query(value = \"SELECT * FROM todo WHERE title LIKE %:texto%\", nativeQuery = true)\nList&lt;Todo&gt; encontrarPorTextoEnTitulo(String texto);\n@Query(value = \"select * from todo t where t.title = ?1\", nativeQuery = true)\nTodo findByTitle(String title);\n</code></pre> <p>3 Actualizaciones y eliminaciones personalizadas: Puedes usar @Query para definir consultas de actualizaci\u00f3n o eliminaci\u00f3n personalizadas.</p> <pre><code>    @Modifying //Indica que la consulta modificar\u00e1 el estado de la base de datos.\n@Transactional //Indica que la transacci\u00f3n debe estar activa para ejecutar esta consulta.\n@Query(\"UPDATE Todo t SET t.title = :nuevoTitulo WHERE t.id = :todoId\")\nint updateTitleById(Long todoId, String nuevoTitulo);\n</code></pre> <p>4 Mapeo de resultados personalizados: Puedes especificar c\u00f3mo se deben mapear los resultados de la consulta a objetos Java espec\u00edficos como DTOs.</p> <pre><code>    @Query(\"SELECT new es.severo.ud4.dto.TodoDTO(t.id, t.title) FROM Todo t WHERE t.completed = false\")\nList&lt;TodoDTO&gt; encontrarTodosNoCompletados();\n</code></pre>"},{"location":"ud4/44queryresponse/#response-de-una-api-rest","title":"\ud83c\udd97 Response de una API rest","text":"<p>Para responder a una petici\u00f3n de una api de un endpoint tenemos varias formas: ResponseEntity, @ResponeStatus y @ResponseBody.</p> <ul> <li> <p>ResponseEntity: es una clase que de forma flexible nos permite manejar la respuesta HTTP. Te permite controlar tanto el cuerpo de la respuesta como los encabezados y el estado HTTP. \u00datil con c\u00f3digos personalizados</p> </li> <li> <p>@ResponeStatus: es una anotaci\u00f3n que se puede utilizar en m\u00e9todos de controlador para especificar un c\u00f3digo de estado predeterminado para todas las respuestas generadas por ese m\u00e9todo. Es \u00fatil cuando deseas establecer un c\u00f3digo de estado espec\u00edfico para todas las respuestas sin necesidad de usar ResponseEntity.</p> </li> <li> <p>@ResponseBody: es una anotaci\u00f3n que se puede usar para indicar que el valor de retorno  de un m\u00e9todo de controlador debe ser serializado directamente en el cuerpo de la respuesta HTTP. Es \u00fatil cuando simplemente deseas devolver el cuerpo de la respuesta sin personalizaci\u00f3n adicional.</p> </li> </ul>"},{"location":"ud5/51modulo/","title":"Java Modules","text":"<p>El sistema de m\u00f3dulos en Java es una caracter\u00edstica que se introdujo en el JDK 9, y fue desarrollado bajo el nombre de c\u00f3digo de proyecto Jigsaw. Java 9 introdujo un nuevo componente de programa conocido como modules.</p> <p>A partir de esta caracter\u00edstica, las aplicaciones de Java se desarrollan como colecciones de m\u00f3dulos.</p> <p>El sistema de m\u00f3dulos fue dise\u00f1ado para tener una configuraci\u00f3n confiable, encapsulaci\u00f3n fuerte y ser modular. Su prop\u00f3sito es resolver los problemas t\u00edpicos relacionados con el desarrollo y la implementaci\u00f3n de aplicaciones anteriores a Java 9.</p> <p>Esta nueva caracter\u00edstica de Java 9 es conocida colectivamente como el Sistema de M\u00f3dulos de la Plataforma Java o JPMS.</p>"},{"location":"ud5/51modulo/#que-es-un-modulo","title":"\u00bfQu\u00e9 es un m\u00f3dulo?","text":"<p>Un m\u00f3dulo es una colecci\u00f3n nombrada de datos y c\u00f3digo. Los m\u00f3dulos pueden contener c\u00f3digo Java que est\u00e1 organizado como un conjunto de paquetes, que contienen clases Java, interfaces, etc. Un m\u00f3dulo es un contenedor de paquetes.</p> <p>Cada m\u00f3dulo debe tener la siguiente configuraci\u00f3n: - name: nombre \u00fanico del m\u00f3dulo. - inputs: qu\u00e9 necesita usar el m\u00f3dulo y qu\u00e9 es necesario para compilar y ejecutar el m\u00f3dulo. - outputs: lo que el m\u00f3dulo exporta a otros m\u00f3dulos.</p> <p>Los m\u00f3dulos est\u00e1ndar tienen nombres con el prefijo java. Ejemplos: java.sql, java.net, etc. Por ejemplo, todos los nombres de los m\u00f3dulos de JavaFX tienen el prefijo javafx.</p>"},{"location":"ud5/51modulo/#fichero-module-infojava","title":"Fichero module-info.java","text":"<p>Cada m\u00f3dulo viene con un archivo descriptor de m\u00f3dulo que describe el m\u00f3dulo y contiene metadatos sobre el m\u00f3dulo. Este fichero descriptor siempre se encuentra directamente en la carpeta ra\u00edz del m\u00f3dulo y siempre tiene el nombre de module-info.java.</p>"},{"location":"ud5/51modulo/#ventajas-de-usar-modulos","title":"Ventajas de usar m\u00f3dulos","text":"<ul> <li>Escalabilidad.</li> <li>Seguridad y mantenibilidad. </li> <li>Mejora el rendimiento de la aplicaci\u00f3n.</li> <li>Facilidad a la hora de desarrollar.</li> </ul>"},{"location":"ud5/51modulo/#declaracion-de-un-modulo","title":"Declaraci\u00f3n de un m\u00f3dulo","text":"<p>Para declarar un m\u00f3dulo se utiliza la palabra reservada module seguido del nombre del m\u00f3dulo y llaves. La sintaxis es la siguiente:</p> <pre><code>    [open] module &lt;moduleName&gt; {\n&lt;module-statement&gt;;\n&lt;module-statement&gt;;\n...\n}\n</code></pre> <ul> <li>[open]: es opcional, es el modificador que declara un m\u00f3dulo abierto, un m\u00f3dulo que exporta sus paquetes para los utilice el acceso reflexivo.</li> <li>: Es un campo obligatorio. No podemos tener dos m\u00f3dulos dentro del mismo c\u00f3digo base con el mismo nombre. Es una buena pr\u00e1ctica nombrar a los m\u00f3dulos con el mismo nombre que los paquetes. El nombre del m\u00f3dulo consta de uno o m\u00e1s identificadores de Java separados por el \".\", similar a c\u00f3mo se declaran los paquetes. Ejemplo: es.education.common <li>Dentro de las llaves se puede a\u00f1adir opcionalmente 0 o m\u00e1s metadatos sobre el m\u00f3dulo o module statements. Y estos statements o declaraciones pueden ser:<ul> <li>export statement: se usa para especificar los paquetes que exporta el m\u00f3dulo actual.</li> <li>opens statement: NO se puede usar en m\u00f3dulos abiertos (open modules) porque todos los paquetes est\u00e1n abiertos en un m\u00f3dulo abierto.</li> <li>requires statement: se usa para especificar el m\u00f3dulo que requiere el m\u00f3dulo actual. Si nuestro m\u00f3dulo depende de otros m\u00f3dulos, debemos especificarlo aqu\u00ed. Podemos usarlos tantas veces como m\u00f3dulos requiera el nuestro.</li> <li>uses statement: se usa para especificar el servicio que consume el m\u00f3dulo actual.</li> <li>provides statement: se usa para especificar las implementaciones de servicio que brindan los m\u00f3dulos actuales.</li> </ul> </li> <p>El nombre del m\u00f3dulo definido se puede usar en otras declaraciones de m\u00f3dulo para expresar relaciones entre m\u00f3dulos.</p> <p>En el siguiente diagrama se muestra una estructura de proyecto antes y despu\u00e9s de utilizar modules: </p> <p>Se trata de no crear aplicaciones como un gran proyecto java, sino de crear unidades modulares que funcionan juntas para formar una aplicaci\u00f3n.</p> <p> Idealmente, los m\u00f3dulos son componentes reutilizables que resuelven requisitos espec\u00edficos para esa aplicaci\u00f3n. </p>"},{"location":"ud5/51modulo/#tipos-de-modulos","title":"Tipos de m\u00f3dulos","text":"<p>Jigsaw defini\u00f3 dos tipos de m\u00f3dulos:</p>"},{"location":"ud5/51modulo/#named-modules-modulos-con-nombre","title":"Named modules (m\u00f3dulos con nombre)","text":"<p>Cada m\u00f3dulo tiene un nombre. Pueden ser normales o autom\u00e1ticos.  \u00c9stos m\u00f3dulos deben ser declarados en el fichero module-info.java.</p> <ul> <li> <p>Normal modules: (sin modificador open). No existen oficialmente como tal en JDK 9, hace referencia a los named modules que no son autom\u00e1ticos. Y hemos dicho que tienen un fichero descriptor, el module-info.java. Se declara usando la palabra reservada module. No exporta ninguno de sus paquetes por defecto. Y se divide entre m\u00f3dulos b\u00e1sicos y abiertos (basic and open modules).</p> <ul> <li>Basic modules: tampoco existe oficialmente, simplemente se usa el t\u00e9rmino para un m\u00f3dulo que no es abierto. Es decir, m\u00f3dulos que no son automatic modules ni tampoco open modules.</li> <li>Open modules:  muchas librer\u00edas de terceros como Hibernate o Spring usan la reflexi\u00f3n para acceder a las partes internas de JDK en tiempo de ejecuci\u00f3n. Estas librer\u00edas solo funcionan con m\u00f3dulos que son open. Se definen usando la palabra resevada open. Un m\u00f3dulo abierto hace que todos los paquetes dentro del m\u00f3dulo sean accesibles para una reflexi\u00f3n profunda. La palabra reservada open, se puede usar para un m\u00f3dulo o para declarar paquetes espec\u00edficos como open.</li> </ul> </li> <li> <p>Automatic modules: no tienen fichero descriptor. Se crean despu\u00e9s de agregar un fichero jar a la ruta del m\u00f3dulo. No se declara expl\u00edcitamente por el desarrollador dentro del fichero descriptor del m\u00f3dulo. M\u00e1s bien, se crea autom\u00e1ticamente cuando se coloca un fichero jar en la ruta del m\u00f3dulo. Requiere que por defecto todos los m\u00f3dulos de la plataforma, todos nuestros propios m\u00f3dulos y los dem\u00e1s m\u00f3dulos autom\u00e1ticos. Por defecto exporta todos sus paquetes. Son \u00fatiles para c\u00f3digo de terceros.</p> </li> </ul>"},{"location":"ud5/51modulo/#unnamed-modul-modul-sin-nombre","title":"Unnamed modul (m\u00f3dul sin nombre)","text":"<p>No tiene nombre y tampoco lo declaramos. Exporta todos sus paquetes y lee todos los m\u00f3dulos en el JDK y en la ruta del m\u00f3dulo. Es un m\u00f3dulo formado por ficheros jar de la ruta de clase, y todos estos archivos jar forman el m\u00f3dulo sin nombre. Un m\u00f3dulo con nombre NO PUEDE REQUERIR un m\u00f3dulo sin nombre.</p>"},{"location":"ud5/51modulo/#aggregator-modules","title":"Aggregator modules","text":"<p>Por \u00faltimo tenemos los m\u00f3dulos agregados. \u00c9stos existen por necesidad. Por ejemplo imaginad que nuestro m\u00f3dulo depende de 3 m\u00f3dulos. Podemos crear un aggregator module para esos tres m\u00f3dulos y de esta forma nuestro m\u00f3dulo solo depender\u00eda de este \u00fanico m\u00f3dulo agregado que contiene los otros tres.</p>"},{"location":"ud5/51modulo/#module-path-y-class-path","title":"Module Path y Class Path","text":"<p>JDK 9 introdujo el concepto de module path o ruta de m\u00f3dulo. Module Path puede representar:</p> <ul> <li>Una ruta a una secuencia de carpetas que contienen m\u00f3dulos.</li> <li>Una ruta a un fichero jar modular.</li> <li>Una ruta a un fichero jmod (versi\u00f3n extendida de JAR).</li> </ul> <p>El compilador utiliza una ruta de m\u00f3dulo para encontrar y resolver m\u00f3dulos. Cada m\u00f3dulo de un module path debe tener una declaraci\u00f3n (module-info.java).</p> <p>Class path representa una secuencia de ficheros java.</p>"},{"location":"ud5/51modulo/#crear-un-modulo-en-intellij","title":"Crear un m\u00f3dulo en IntelliJ","text":"<p>Con nuestra aplicaci\u00f3n abierta, seleccionamos File --&gt; New --&gt; Module. Se recomienda llamar a los paquetes igual que a los m\u00f3dulos.</p>"}]}